
bin/BareMetal.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006b4  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  20000000  20000000  000016b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  20000000  000006b4  00000000  2**0
                  ALLOC
  3 Heap          00002e00  20000000  000006b4  00002000  2**0
                  ALLOC
  4 Stack         00000200  20002e00  000006b4  00001e00  2**0
                  ALLOC
  5 .debug_info   00000b43  00000000  00000000  000016b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_abbrev 0000049b  00000000  00000000  000021f7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_aranges 00000080  00000000  00000000  00002692  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   000007f0  00000000  00000000  00002712  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    00000489  00000000  00000000  00002f02  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000044  00000000  00000000  0000338b  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002c  00000000  00000000  000033cf  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000310  00000000  00000000  000033fc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <vector>:
   0:	00 40 00 20 a3 05 00 00 39 06 00 00 41 06 00 00     .@. ....9...A...
	...
  2c:	39 06 00 00 00 00 00 00 00 00 00 00 39 06 00 00     9...........9...
  3c:	39 06 00 00 39 06 00 00 39 06 00 00 39 06 00 00     9...9...9...9...
  4c:	7f 01 00 00 39 06 00 00 39 06 00 00 39 06 00 00     ....9...9...9...
  5c:	39 06 00 00 39 06 00 00 39 06 00 00 39 06 00 00     9...9...9...9...
  6c:	39 06 00 00 39 06 00 00 39 06 00 00 39 06 00 00     9...9...9...9...
  7c:	39 06 00 00 39 06 00 00 39 06 00 00 39 06 00 00     9...9...9...9...
  8c:	39 06 00 00 39 06 00 00 39 06 00 00 39 06 00 00     9...9...9...9...
  9c:	39 06 00 00 39 06 00 00 39 06 00 00 39 06 00 00     9...9...9...9...
  ac:	39 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00     9...............
  bc:	00 00 00 00                                         ....

000000c0 <main>:
};

void Delay(int32_t);

int main()
{
  c0:	b580      	push	{r7, lr}
  c2:	af00      	add	r7, sp, #0
    IRQ_EnableGlobal();
  c4:	f000 f9e6 	bl	494 <IRQ_EnableGlobal>

    GPIO_Pin_Init(2, 2u, &LED_config, HSIOM_SEL_GPIO);
  c8:	4a1b      	ldr	r2, [pc, #108]	@ (138 <main+0x78>)
  ca:	2300      	movs	r3, #0
  cc:	2102      	movs	r1, #2
  ce:	2002      	movs	r0, #2
  d0:	f000 f982 	bl	3d8 <GPIO_Pin_Init>
    GPIO_Pin_Init(1, 6u, &LED_config, HSIOM_SEL_GPIO);
  d4:	4a18      	ldr	r2, [pc, #96]	@ (138 <main+0x78>)
  d6:	2300      	movs	r3, #0
  d8:	2106      	movs	r1, #6
  da:	2001      	movs	r0, #1
  dc:	f000 f97c 	bl	3d8 <GPIO_Pin_Init>
    GPIO_Pin_Init(3, 7u, &SW2_P3_7_config, HSIOM_SEL_GPIO);
  e0:	4a16      	ldr	r2, [pc, #88]	@ (13c <main+0x7c>)
  e2:	2300      	movs	r3, #0
  e4:	2107      	movs	r1, #7
  e6:	2003      	movs	r0, #3
  e8:	f000 f976 	bl	3d8 <GPIO_Pin_Init>

    NVIC_SetPriority(3u, 1u);
  ec:	2101      	movs	r1, #1
  ee:	2003      	movs	r0, #3
  f0:	f000 f9dc 	bl	4ac <NVIC_SetPriority>
    NVIC_SetPriority(2u, 1u);
  f4:	2101      	movs	r1, #1
  f6:	2002      	movs	r0, #2
  f8:	f000 f9d8 	bl	4ac <NVIC_SetPriority>
    NVIC_ClearPendingIRQ(3u);
  fc:	2003      	movs	r0, #3
  fe:	f000 fa05 	bl	50c <NVIC_ClearPendingIRQ>
    NVIC_ClearPendingIRQ(2u);
 102:	2002      	movs	r0, #2
 104:	f000 fa02 	bl	50c <NVIC_ClearPendingIRQ>
    NVIC_EnableIRQ(3u);
 108:	2003      	movs	r0, #3
 10a:	f000 fa15 	bl	538 <NVIC_EnableIRQ>
    NVIC_EnableIRQ(2u);
 10e:	2002      	movs	r0, #2
 110:	f000 fa12 	bl	538 <NVIC_EnableIRQ>

    for(;;)
    {
        GPIO_Set(1, 6u);
 114:	2106      	movs	r1, #6
 116:	2001      	movs	r0, #1
 118:	f000 f84a 	bl	1b0 <GPIO_Set>
        Delay(60000);
 11c:	4b08      	ldr	r3, [pc, #32]	@ (140 <main+0x80>)
 11e:	0018      	movs	r0, r3
 120:	f000 f810 	bl	144 <Delay>

        GPIO_Clr(1, 6u);
 124:	2106      	movs	r1, #6
 126:	2001      	movs	r0, #1
 128:	f000 f85c 	bl	1e4 <GPIO_Clr>
        Delay(60000);  
 12c:	4b04      	ldr	r3, [pc, #16]	@ (140 <main+0x80>)
 12e:	0018      	movs	r0, r3
 130:	f000 f808 	bl	144 <Delay>
        GPIO_Set(1, 6u);
 134:	46c0      	nop			@ (mov r8, r8)
 136:	e7ed      	b.n	114 <main+0x54>
 138:	00000690 	.word	0x00000690
 13c:	000006a8 	.word	0x000006a8
 140:	0000ea60 	.word	0x0000ea60

00000144 <Delay>:
    }
    return 0;
}

void Delay(int32_t delayNumber)
{
 144:	b580      	push	{r7, lr}
 146:	b084      	sub	sp, #16
 148:	af00      	add	r7, sp, #0
 14a:	6078      	str	r0, [r7, #4]
    for(int32_t i=0; i<delayNumber; i++);
 14c:	2300      	movs	r3, #0
 14e:	60fb      	str	r3, [r7, #12]
 150:	e002      	b.n	158 <Delay+0x14>
 152:	68fb      	ldr	r3, [r7, #12]
 154:	3301      	adds	r3, #1
 156:	60fb      	str	r3, [r7, #12]
 158:	68fa      	ldr	r2, [r7, #12]
 15a:	687b      	ldr	r3, [r7, #4]
 15c:	429a      	cmp	r2, r3
 15e:	dbf8      	blt.n	152 <Delay+0xe>
    for(int32_t i=0; i<delayNumber; i++);
 160:	2300      	movs	r3, #0
 162:	60bb      	str	r3, [r7, #8]
 164:	e002      	b.n	16c <Delay+0x28>
 166:	68bb      	ldr	r3, [r7, #8]
 168:	3301      	adds	r3, #1
 16a:	60bb      	str	r3, [r7, #8]
 16c:	68ba      	ldr	r2, [r7, #8]
 16e:	687b      	ldr	r3, [r7, #4]
 170:	429a      	cmp	r2, r3
 172:	dbf8      	blt.n	166 <Delay+0x22>
}
 174:	46c0      	nop			@ (mov r8, r8)
 176:	46c0      	nop			@ (mov r8, r8)
 178:	46bd      	mov	sp, r7
 17a:	b004      	add	sp, #16
 17c:	bd80      	pop	{r7, pc}

0000017e <ioss_interrupts_gpio_3_IRQHandler>:

void ioss_interrupts_gpio_3_IRQHandler(void)
{
 17e:	b580      	push	{r7, lr}
 180:	af00      	add	r7, sp, #0

    GPIO_ClearInterrupt(3, 7u);
 182:	2107      	movs	r1, #7
 184:	2003      	movs	r0, #3
 186:	f000 f967 	bl	458 <GPIO_ClearInterrupt>
    Delay(20000);
 18a:	4b08      	ldr	r3, [pc, #32]	@ (1ac <ioss_interrupts_gpio_3_IRQHandler+0x2e>)
 18c:	0018      	movs	r0, r3
 18e:	f7ff ffd9 	bl	144 <Delay>

    if((GPIO_Read(3, 7u) == 0u))
 192:	2107      	movs	r1, #7
 194:	2003      	movs	r0, #3
 196:	f000 f859 	bl	24c <GPIO_Read>
 19a:	1e03      	subs	r3, r0, #0
 19c:	d103      	bne.n	1a6 <ioss_interrupts_gpio_3_IRQHandler+0x28>
    {
        GPIO_Inv(2, 2u);
 19e:	2102      	movs	r1, #2
 1a0:	2002      	movs	r0, #2
 1a2:	f000 f839 	bl	218 <GPIO_Inv>
    }  

 1a6:	46c0      	nop			@ (mov r8, r8)
 1a8:	46bd      	mov	sp, r7
 1aa:	bd80      	pop	{r7, pc}
 1ac:	00004e20 	.word	0x00004e20

000001b0 <GPIO_Set>:
#include <stdint.h>
#include "gpio.h"

void GPIO_Set(uint8_t portNum, uint32_t pinNum)
{
 1b0:	b580      	push	{r7, lr}
 1b2:	b084      	sub	sp, #16
 1b4:	af00      	add	r7, sp, #0
 1b6:	0002      	movs	r2, r0
 1b8:	6039      	str	r1, [r7, #0]
 1ba:	1dfb      	adds	r3, r7, #7
 1bc:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 1be:	1dfb      	adds	r3, r7, #7
 1c0:	781b      	ldrb	r3, [r3, #0]
 1c2:	4a07      	ldr	r2, [pc, #28]	@ (1e0 <GPIO_Set+0x30>)
 1c4:	4694      	mov	ip, r2
 1c6:	4463      	add	r3, ip
 1c8:	021b      	lsls	r3, r3, #8
 1ca:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_SET(base) = GPIO_DR_MASK << pinNum;
 1cc:	2201      	movs	r2, #1
 1ce:	683b      	ldr	r3, [r7, #0]
 1d0:	409a      	lsls	r2, r3
 1d2:	68fb      	ldr	r3, [r7, #12]
 1d4:	641a      	str	r2, [r3, #64]	@ 0x40
}
 1d6:	46c0      	nop			@ (mov r8, r8)
 1d8:	46bd      	mov	sp, r7
 1da:	b004      	add	sp, #16
 1dc:	bd80      	pop	{r7, pc}
 1de:	46c0      	nop			@ (mov r8, r8)
 1e0:	00400400 	.word	0x00400400

000001e4 <GPIO_Clr>:

void GPIO_Clr(uint8_t portNum, uint32_t pinNum)
{
 1e4:	b580      	push	{r7, lr}
 1e6:	b084      	sub	sp, #16
 1e8:	af00      	add	r7, sp, #0
 1ea:	0002      	movs	r2, r0
 1ec:	6039      	str	r1, [r7, #0]
 1ee:	1dfb      	adds	r3, r7, #7
 1f0:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 1f2:	1dfb      	adds	r3, r7, #7
 1f4:	781b      	ldrb	r3, [r3, #0]
 1f6:	4a07      	ldr	r2, [pc, #28]	@ (214 <__HEAP_SIZE+0x14>)
 1f8:	4694      	mov	ip, r2
 1fa:	4463      	add	r3, ip
 1fc:	021b      	lsls	r3, r3, #8
 1fe:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_CLR(base) = GPIO_DR_MASK << pinNum;
 200:	2201      	movs	r2, #1
 202:	683b      	ldr	r3, [r7, #0]
 204:	409a      	lsls	r2, r3
 206:	68fb      	ldr	r3, [r7, #12]
 208:	645a      	str	r2, [r3, #68]	@ 0x44
}
 20a:	46c0      	nop			@ (mov r8, r8)
 20c:	46bd      	mov	sp, r7
 20e:	b004      	add	sp, #16
 210:	bd80      	pop	{r7, pc}
 212:	46c0      	nop			@ (mov r8, r8)
 214:	00400400 	.word	0x00400400

00000218 <GPIO_Inv>:

void GPIO_Inv(uint8_t portNum, uint32_t pinNum)
{
 218:	b580      	push	{r7, lr}
 21a:	b084      	sub	sp, #16
 21c:	af00      	add	r7, sp, #0
 21e:	0002      	movs	r2, r0
 220:	6039      	str	r1, [r7, #0]
 222:	1dfb      	adds	r3, r7, #7
 224:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 226:	1dfb      	adds	r3, r7, #7
 228:	781b      	ldrb	r3, [r3, #0]
 22a:	4a07      	ldr	r2, [pc, #28]	@ (248 <GPIO_Inv+0x30>)
 22c:	4694      	mov	ip, r2
 22e:	4463      	add	r3, ip
 230:	021b      	lsls	r3, r3, #8
 232:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_INV(base) = GPIO_DR_MASK << pinNum;
 234:	2201      	movs	r2, #1
 236:	683b      	ldr	r3, [r7, #0]
 238:	409a      	lsls	r2, r3
 23a:	68fb      	ldr	r3, [r7, #12]
 23c:	649a      	str	r2, [r3, #72]	@ 0x48
}
 23e:	46c0      	nop			@ (mov r8, r8)
 240:	46bd      	mov	sp, r7
 242:	b004      	add	sp, #16
 244:	bd80      	pop	{r7, pc}
 246:	46c0      	nop			@ (mov r8, r8)
 248:	00400400 	.word	0x00400400

0000024c <GPIO_Read>:

uint32_t GPIO_Read(uint8_t portNum, uint32_t pinNum)
{
 24c:	b580      	push	{r7, lr}
 24e:	b084      	sub	sp, #16
 250:	af00      	add	r7, sp, #0
 252:	0002      	movs	r2, r0
 254:	6039      	str	r1, [r7, #0]
 256:	1dfb      	adds	r3, r7, #7
 258:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 25a:	1dfb      	adds	r3, r7, #7
 25c:	781b      	ldrb	r3, [r3, #0]
 25e:	4a08      	ldr	r2, [pc, #32]	@ (280 <GPIO_Read+0x34>)
 260:	4694      	mov	ip, r2
 262:	4463      	add	r3, ip
 264:	021b      	lsls	r3, r3, #8
 266:	60fb      	str	r3, [r7, #12]
    return (GPIO_PRT_IN(base) >> (pinNum)) & GPIO_PS_MASK;
 268:	68fb      	ldr	r3, [r7, #12]
 26a:	685a      	ldr	r2, [r3, #4]
 26c:	683b      	ldr	r3, [r7, #0]
 26e:	40da      	lsrs	r2, r3
 270:	0013      	movs	r3, r2
 272:	2201      	movs	r2, #1
 274:	4013      	ands	r3, r2
}
 276:	0018      	movs	r0, r3
 278:	46bd      	mov	sp, r7
 27a:	b004      	add	sp, #16
 27c:	bd80      	pop	{r7, pc}
 27e:	46c0      	nop			@ (mov r8, r8)
 280:	00400400 	.word	0x00400400

00000284 <GPIO_SetDrivemode>:

void GPIO_SetDrivemode(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 284:	b580      	push	{r7, lr}
 286:	b088      	sub	sp, #32
 288:	af00      	add	r7, sp, #0
 28a:	60b9      	str	r1, [r7, #8]
 28c:	607a      	str	r2, [r7, #4]
 28e:	210f      	movs	r1, #15
 290:	187b      	adds	r3, r7, r1
 292:	1c02      	adds	r2, r0, #0
 294:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 296:	187b      	adds	r3, r7, r1
 298:	781b      	ldrb	r3, [r3, #0]
 29a:	4a19      	ldr	r2, [pc, #100]	@ (300 <GPIO_SetDrivemode+0x7c>)
 29c:	4694      	mov	ip, r2
 29e:	4463      	add	r3, ip
 2a0:	021b      	lsls	r3, r3, #8
 2a2:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum * GPIO_DRIVE_MODE_OFFSET;
 2a4:	68ba      	ldr	r2, [r7, #8]
 2a6:	0013      	movs	r3, r2
 2a8:	005b      	lsls	r3, r3, #1
 2aa:	189b      	adds	r3, r3, r2
 2ac:	61bb      	str	r3, [r7, #24]
    tempReg = ((((GPIO_PRT_Type*)(base))->PC) & ~(GPIO_PC_DM_MASK << pinLoc));
 2ae:	69fb      	ldr	r3, [r7, #28]
 2b0:	689b      	ldr	r3, [r3, #8]
 2b2:	2107      	movs	r1, #7
 2b4:	69ba      	ldr	r2, [r7, #24]
 2b6:	4091      	lsls	r1, r2
 2b8:	000a      	movs	r2, r1
 2ba:	43d2      	mvns	r2, r2
 2bc:	4013      	ands	r3, r2
 2be:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC) = tempReg | ((value & GPIO_PC_DM_MASK) << pinLoc);
 2c0:	687b      	ldr	r3, [r7, #4]
 2c2:	2207      	movs	r2, #7
 2c4:	401a      	ands	r2, r3
 2c6:	69bb      	ldr	r3, [r7, #24]
 2c8:	409a      	lsls	r2, r3
 2ca:	697b      	ldr	r3, [r7, #20]
 2cc:	431a      	orrs	r2, r3
 2ce:	69fb      	ldr	r3, [r7, #28]
 2d0:	609a      	str	r2, [r3, #8]

    tempReg = ((((GPIO_PRT_Type*)(base))->PC2) & ~(GPIO_PC_DM_IBUF_MASK << pinNum));
 2d2:	69fb      	ldr	r3, [r7, #28]
 2d4:	699b      	ldr	r3, [r3, #24]
 2d6:	2101      	movs	r1, #1
 2d8:	68ba      	ldr	r2, [r7, #8]
 2da:	4091      	lsls	r1, r2
 2dc:	000a      	movs	r2, r1
 2de:	43d2      	mvns	r2, r2
 2e0:	4013      	ands	r3, r2
 2e2:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC2) = tempReg | (((value & GPIO_DM_VAL_IBUF_DISABLE_MASK) >> GPIO_DRIVE_MODE_OFFSET) << pinNum);
 2e4:	687b      	ldr	r3, [r7, #4]
 2e6:	08db      	lsrs	r3, r3, #3
 2e8:	2201      	movs	r2, #1
 2ea:	401a      	ands	r2, r3
 2ec:	68bb      	ldr	r3, [r7, #8]
 2ee:	409a      	lsls	r2, r3
 2f0:	697b      	ldr	r3, [r7, #20]
 2f2:	431a      	orrs	r2, r3
 2f4:	69fb      	ldr	r3, [r7, #28]
 2f6:	619a      	str	r2, [r3, #24]
}
 2f8:	46c0      	nop			@ (mov r8, r8)
 2fa:	46bd      	mov	sp, r7
 2fc:	b008      	add	sp, #32
 2fe:	bd80      	pop	{r7, pc}
 300:	00400400 	.word	0x00400400

00000304 <GPIO_SetHSIOM>:


void GPIO_SetHSIOM(uint8_t portNum, uint32_t pinNum, uint8_t value)
{
 304:	b580      	push	{r7, lr}
 306:	b086      	sub	sp, #24
 308:	af00      	add	r7, sp, #0
 30a:	6039      	str	r1, [r7, #0]
 30c:	0011      	movs	r1, r2
 30e:	1dfb      	adds	r3, r7, #7
 310:	1c02      	adds	r2, r0, #0
 312:	701a      	strb	r2, [r3, #0]
 314:	1dbb      	adds	r3, r7, #6
 316:	1c0a      	adds	r2, r1, #0
 318:	701a      	strb	r2, [r3, #0]
    uint32_t HSIOM_portNum;
    uint32_t tempReg;
    HSIOM_PRT_Type* portAddrHSIOM;
    
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 31a:	1dfb      	adds	r3, r7, #7
 31c:	781b      	ldrb	r3, [r3, #0]
 31e:	4a15      	ldr	r2, [pc, #84]	@ (374 <GPIO_SetHSIOM+0x70>)
 320:	4694      	mov	ip, r2
 322:	4463      	add	r3, ip
 324:	021b      	lsls	r3, r3, #8
 326:	617b      	str	r3, [r7, #20]

    HSIOM_portNum = ((uint32_t)(base) - 0x40040000UL) / 0x00000100UL;
 328:	697b      	ldr	r3, [r7, #20]
 32a:	4a13      	ldr	r2, [pc, #76]	@ (378 <GPIO_SetHSIOM+0x74>)
 32c:	4694      	mov	ip, r2
 32e:	4463      	add	r3, ip
 330:	0a1b      	lsrs	r3, r3, #8
 332:	613b      	str	r3, [r7, #16]
    portAddrHSIOM = (HSIOM_PRT_Type*)(0x40020000UL + (0x00000100UL * HSIOM_portNum));
 334:	693b      	ldr	r3, [r7, #16]
 336:	4a11      	ldr	r2, [pc, #68]	@ (37c <GPIO_SetHSIOM+0x78>)
 338:	4694      	mov	ip, r2
 33a:	4463      	add	r3, ip
 33c:	021b      	lsls	r3, r3, #8
 33e:	60fb      	str	r3, [r7, #12]

    tempReg = (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) & ~(GPIO_HSIOM_MASK << (pinNum << GPIO_HSIOM_OFFSET));
 340:	68fb      	ldr	r3, [r7, #12]
 342:	681b      	ldr	r3, [r3, #0]
 344:	683a      	ldr	r2, [r7, #0]
 346:	0092      	lsls	r2, r2, #2
 348:	210f      	movs	r1, #15
 34a:	4091      	lsls	r1, r2
 34c:	000a      	movs	r2, r1
 34e:	43d2      	mvns	r2, r2
 350:	4013      	ands	r3, r2
 352:	60bb      	str	r3, [r7, #8]
    (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) = tempReg | (( (uint32_t) value & GPIO_HSIOM_MASK) << (pinNum << GPIO_HSIOM_OFFSET));
 354:	1dbb      	adds	r3, r7, #6
 356:	781b      	ldrb	r3, [r3, #0]
 358:	220f      	movs	r2, #15
 35a:	401a      	ands	r2, r3
 35c:	683b      	ldr	r3, [r7, #0]
 35e:	009b      	lsls	r3, r3, #2
 360:	409a      	lsls	r2, r3
 362:	68bb      	ldr	r3, [r7, #8]
 364:	431a      	orrs	r2, r3
 366:	68fb      	ldr	r3, [r7, #12]
 368:	601a      	str	r2, [r3, #0]
}
 36a:	46c0      	nop			@ (mov r8, r8)
 36c:	46bd      	mov	sp, r7
 36e:	b006      	add	sp, #24
 370:	bd80      	pop	{r7, pc}
 372:	46c0      	nop			@ (mov r8, r8)
 374:	00400400 	.word	0x00400400
 378:	bffc0000 	.word	0xbffc0000
 37c:	00400200 	.word	0x00400200

00000380 <GPIO_SetInterruptEdge>:

void GPIO_SetInterruptEdge(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 380:	b580      	push	{r7, lr}
 382:	b088      	sub	sp, #32
 384:	af00      	add	r7, sp, #0
 386:	60b9      	str	r1, [r7, #8]
 388:	607a      	str	r2, [r7, #4]
 38a:	210f      	movs	r1, #15
 38c:	187b      	adds	r3, r7, r1
 38e:	1c02      	adds	r2, r0, #0
 390:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 392:	187b      	adds	r3, r7, r1
 394:	781b      	ldrb	r3, [r3, #0]
 396:	4a0f      	ldr	r2, [pc, #60]	@ (3d4 <GPIO_SetInterruptEdge+0x54>)
 398:	4694      	mov	ip, r2
 39a:	4463      	add	r3, ip
 39c:	021b      	lsls	r3, r3, #8
 39e:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum << 0x1u;
 3a0:	68bb      	ldr	r3, [r7, #8]
 3a2:	005b      	lsls	r3, r3, #1
 3a4:	61bb      	str	r3, [r7, #24]
    tempReg = (((GPIO_PRT_Type*)(base))->INTR_CFG) & ~(0x3u << pinLoc);
 3a6:	69fb      	ldr	r3, [r7, #28]
 3a8:	68db      	ldr	r3, [r3, #12]
 3aa:	2103      	movs	r1, #3
 3ac:	69ba      	ldr	r2, [r7, #24]
 3ae:	4091      	lsls	r1, r2
 3b0:	000a      	movs	r2, r1
 3b2:	43d2      	mvns	r2, r2
 3b4:	4013      	ands	r3, r2
 3b6:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->INTR_CFG) = tempReg | ((value & 0x3u) << pinLoc);
 3b8:	687b      	ldr	r3, [r7, #4]
 3ba:	2203      	movs	r2, #3
 3bc:	401a      	ands	r2, r3
 3be:	69bb      	ldr	r3, [r7, #24]
 3c0:	409a      	lsls	r2, r3
 3c2:	697b      	ldr	r3, [r7, #20]
 3c4:	431a      	orrs	r2, r3
 3c6:	69fb      	ldr	r3, [r7, #28]
 3c8:	60da      	str	r2, [r3, #12]
}
 3ca:	46c0      	nop			@ (mov r8, r8)
 3cc:	46bd      	mov	sp, r7
 3ce:	b008      	add	sp, #32
 3d0:	bd80      	pop	{r7, pc}
 3d2:	46c0      	nop			@ (mov r8, r8)
 3d4:	00400400 	.word	0x00400400

000003d8 <GPIO_Pin_Init>:

void GPIO_Pin_Init(uint8_t portNum, uint32_t pinNum, const gpio_pin_config_t *config, uint8_t hsiom)
{
 3d8:	b590      	push	{r4, r7, lr}
 3da:	b085      	sub	sp, #20
 3dc:	af00      	add	r7, sp, #0
 3de:	60b9      	str	r1, [r7, #8]
 3e0:	607a      	str	r2, [r7, #4]
 3e2:	0019      	movs	r1, r3
 3e4:	240f      	movs	r4, #15
 3e6:	193b      	adds	r3, r7, r4
 3e8:	1c02      	adds	r2, r0, #0
 3ea:	701a      	strb	r2, [r3, #0]
 3ec:	230e      	movs	r3, #14
 3ee:	18fb      	adds	r3, r7, r3
 3f0:	1c0a      	adds	r2, r1, #0
 3f2:	701a      	strb	r2, [r3, #0]
    ((config -> outVal) == 0) ? GPIO_Clr(portNum, pinNum) : GPIO_Set(portNum,pinNum);
 3f4:	687b      	ldr	r3, [r7, #4]
 3f6:	681b      	ldr	r3, [r3, #0]
 3f8:	2b00      	cmp	r3, #0
 3fa:	d107      	bne.n	40c <GPIO_Pin_Init+0x34>
 3fc:	68ba      	ldr	r2, [r7, #8]
 3fe:	193b      	adds	r3, r7, r4
 400:	781b      	ldrb	r3, [r3, #0]
 402:	0011      	movs	r1, r2
 404:	0018      	movs	r0, r3
 406:	f7ff feed 	bl	1e4 <GPIO_Clr>
 40a:	e007      	b.n	41c <GPIO_Pin_Init+0x44>
 40c:	68ba      	ldr	r2, [r7, #8]
 40e:	230f      	movs	r3, #15
 410:	18fb      	adds	r3, r7, r3
 412:	781b      	ldrb	r3, [r3, #0]
 414:	0011      	movs	r1, r2
 416:	0018      	movs	r0, r3
 418:	f7ff feca 	bl	1b0 <GPIO_Set>
    GPIO_SetDrivemode(portNum, pinNum, config->driveMode);
 41c:	687b      	ldr	r3, [r7, #4]
 41e:	685a      	ldr	r2, [r3, #4]
 420:	68b9      	ldr	r1, [r7, #8]
 422:	240f      	movs	r4, #15
 424:	193b      	adds	r3, r7, r4
 426:	781b      	ldrb	r3, [r3, #0]
 428:	0018      	movs	r0, r3
 42a:	f7ff ff2b 	bl	284 <GPIO_SetDrivemode>
    GPIO_SetHSIOM(portNum, pinNum, hsiom);
 42e:	230e      	movs	r3, #14
 430:	18fb      	adds	r3, r7, r3
 432:	781a      	ldrb	r2, [r3, #0]
 434:	68b9      	ldr	r1, [r7, #8]
 436:	193b      	adds	r3, r7, r4
 438:	781b      	ldrb	r3, [r3, #0]
 43a:	0018      	movs	r0, r3
 43c:	f7ff ff62 	bl	304 <GPIO_SetHSIOM>
    GPIO_SetInterruptEdge(portNum, pinNum, config->intEdge);
 440:	687b      	ldr	r3, [r7, #4]
 442:	689a      	ldr	r2, [r3, #8]
 444:	68b9      	ldr	r1, [r7, #8]
 446:	193b      	adds	r3, r7, r4
 448:	781b      	ldrb	r3, [r3, #0]
 44a:	0018      	movs	r0, r3
 44c:	f7ff ff98 	bl	380 <GPIO_SetInterruptEdge>
}
 450:	46c0      	nop			@ (mov r8, r8)
 452:	46bd      	mov	sp, r7
 454:	b005      	add	sp, #20
 456:	bd90      	pop	{r4, r7, pc}

00000458 <GPIO_ClearInterrupt>:

void GPIO_ClearInterrupt(uint8_t portNum, uint32_t pinNum)
{
 458:	b580      	push	{r7, lr}
 45a:	b084      	sub	sp, #16
 45c:	af00      	add	r7, sp, #0
 45e:	0002      	movs	r2, r0
 460:	6039      	str	r1, [r7, #0]
 462:	1dfb      	adds	r3, r7, #7
 464:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 466:	1dfb      	adds	r3, r7, #7
 468:	781b      	ldrb	r3, [r3, #0]
 46a:	4a09      	ldr	r2, [pc, #36]	@ (490 <GPIO_ClearInterrupt+0x38>)
 46c:	4694      	mov	ip, r2
 46e:	4463      	add	r3, ip
 470:	021b      	lsls	r3, r3, #8
 472:	60fb      	str	r3, [r7, #12]
    /* Any INTR MMIO registers AHB clearing must be preceded with an AHB read access */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 474:	68fb      	ldr	r3, [r7, #12]
 476:	691b      	ldr	r3, [r3, #16]

    (((GPIO_PRT_Type*)(base))->INTR) = (0x01UL) << pinNum;
 478:	2201      	movs	r2, #1
 47a:	683b      	ldr	r3, [r7, #0]
 47c:	409a      	lsls	r2, r3
 47e:	68fb      	ldr	r3, [r7, #12]
 480:	611a      	str	r2, [r3, #16]

    /* This read ensures that the initial write has been flushed out to the hardware */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 482:	68fb      	ldr	r3, [r7, #12]
 484:	691b      	ldr	r3, [r3, #16]
 486:	46c0      	nop			@ (mov r8, r8)
 488:	46bd      	mov	sp, r7
 48a:	b004      	add	sp, #16
 48c:	bd80      	pop	{r7, pc}
 48e:	46c0      	nop			@ (mov r8, r8)
 490:	00400400 	.word	0x00400400

00000494 <IRQ_EnableGlobal>:
#include <stdint.h>

/*
 * Uses the Thumb-2 "CPSIE i" instruction.
 */
void IRQ_EnableGlobal(void) {
 494:	b580      	push	{r7, lr}
 496:	af00      	add	r7, sp, #0
    __asm volatile ("cpsie i" : : : "memory");
 498:	b662      	cpsie	i
}
 49a:	46c0      	nop			@ (mov r8, r8)
 49c:	46bd      	mov	sp, r7
 49e:	bd80      	pop	{r7, pc}

000004a0 <IRQ_DisableGlobal>:

/*
 * Uses the Thumb-2 "CPSID i" instruction.
 */
void IRQ_DisableGlobal(void) {
 4a0:	b580      	push	{r7, lr}
 4a2:	af00      	add	r7, sp, #0
    __asm volatile ("cpsid i" : : : "memory");
 4a4:	b672      	cpsid	i
}
 4a6:	46c0      	nop			@ (mov r8, r8)
 4a8:	46bd      	mov	sp, r7
 4aa:	bd80      	pop	{r7, pc}

000004ac <NVIC_SetPriority>:

void NVIC_SetPriority(uint32_t IRQn, uint32_t priority)
{
 4ac:	b580      	push	{r7, lr}
 4ae:	b084      	sub	sp, #16
 4b0:	af00      	add	r7, sp, #0
 4b2:	6078      	str	r0, [r7, #4]
 4b4:	6039      	str	r1, [r7, #0]
    if ((int32_t)(IRQn) >= 0){
 4b6:	687b      	ldr	r3, [r7, #4]
 4b8:	2b00      	cmp	r3, #0
 4ba:	db20      	blt.n	4fe <NVIC_SetPriority+0x52>
        uint32_t IRQ_LDX = IRQn >> 2u;
 4bc:	687b      	ldr	r3, [r7, #4]
 4be:	089b      	lsrs	r3, r3, #2
 4c0:	60fb      	str	r3, [r7, #12]
        NVIC->IPR[IRQ_LDX] = (NVIC->IPR[IRQ_LDX] & ~(0xFFUL << ((IRQn & 0x03) << 3))) | (((priority & 0x03) << 6) << ((IRQn & 0x03) << 3));
 4c2:	4a11      	ldr	r2, [pc, #68]	@ (508 <NVIC_SetPriority+0x5c>)
 4c4:	68fb      	ldr	r3, [r7, #12]
 4c6:	33c0      	adds	r3, #192	@ 0xc0
 4c8:	009b      	lsls	r3, r3, #2
 4ca:	589b      	ldr	r3, [r3, r2]
 4cc:	687a      	ldr	r2, [r7, #4]
 4ce:	00d2      	lsls	r2, r2, #3
 4d0:	2118      	movs	r1, #24
 4d2:	400a      	ands	r2, r1
 4d4:	21ff      	movs	r1, #255	@ 0xff
 4d6:	4091      	lsls	r1, r2
 4d8:	000a      	movs	r2, r1
 4da:	43d2      	mvns	r2, r2
 4dc:	401a      	ands	r2, r3
 4de:	683b      	ldr	r3, [r7, #0]
 4e0:	019b      	lsls	r3, r3, #6
 4e2:	21ff      	movs	r1, #255	@ 0xff
 4e4:	4019      	ands	r1, r3
 4e6:	687b      	ldr	r3, [r7, #4]
 4e8:	00db      	lsls	r3, r3, #3
 4ea:	2018      	movs	r0, #24
 4ec:	4003      	ands	r3, r0
 4ee:	4099      	lsls	r1, r3
 4f0:	000b      	movs	r3, r1
 4f2:	4905      	ldr	r1, [pc, #20]	@ (508 <NVIC_SetPriority+0x5c>)
 4f4:	431a      	orrs	r2, r3
 4f6:	68fb      	ldr	r3, [r7, #12]
 4f8:	33c0      	adds	r3, #192	@ 0xc0
 4fa:	009b      	lsls	r3, r3, #2
 4fc:	505a      	str	r2, [r3, r1]
    }
}
 4fe:	46c0      	nop			@ (mov r8, r8)
 500:	46bd      	mov	sp, r7
 502:	b004      	add	sp, #16
 504:	bd80      	pop	{r7, pc}
 506:	46c0      	nop			@ (mov r8, r8)
 508:	e000e100 	.word	0xe000e100

0000050c <NVIC_ClearPendingIRQ>:

void NVIC_ClearPendingIRQ(uint32_t IRQn)
{
 50c:	b580      	push	{r7, lr}
 50e:	b082      	sub	sp, #8
 510:	af00      	add	r7, sp, #0
 512:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 514:	687b      	ldr	r3, [r7, #4]
 516:	2b00      	cmp	r3, #0
 518:	db08      	blt.n	52c <NVIC_ClearPendingIRQ+0x20>
  {
    NVIC->ICPR = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 51a:	687b      	ldr	r3, [r7, #4]
 51c:	221f      	movs	r2, #31
 51e:	4013      	ands	r3, r2
 520:	4904      	ldr	r1, [pc, #16]	@ (534 <NVIC_ClearPendingIRQ+0x28>)
 522:	2201      	movs	r2, #1
 524:	409a      	lsls	r2, r3
 526:	23c0      	movs	r3, #192	@ 0xc0
 528:	005b      	lsls	r3, r3, #1
 52a:	50ca      	str	r2, [r1, r3]
  }
}
 52c:	46c0      	nop			@ (mov r8, r8)
 52e:	46bd      	mov	sp, r7
 530:	b002      	add	sp, #8
 532:	bd80      	pop	{r7, pc}
 534:	e000e100 	.word	0xe000e100

00000538 <NVIC_EnableIRQ>:

void NVIC_EnableIRQ(uint32_t IRQn)
{
 538:	b580      	push	{r7, lr}
 53a:	b082      	sub	sp, #8
 53c:	af00      	add	r7, sp, #0
 53e:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 540:	687b      	ldr	r3, [r7, #4]
 542:	2b00      	cmp	r3, #0
 544:	db07      	blt.n	556 <NVIC_EnableIRQ+0x1e>
  {
    __asm volatile("":::"memory");
    NVIC->ISER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 546:	687b      	ldr	r3, [r7, #4]
 548:	221f      	movs	r2, #31
 54a:	401a      	ands	r2, r3
 54c:	4b04      	ldr	r3, [pc, #16]	@ (560 <NVIC_EnableIRQ+0x28>)
 54e:	2101      	movs	r1, #1
 550:	4091      	lsls	r1, r2
 552:	000a      	movs	r2, r1
 554:	601a      	str	r2, [r3, #0]
    __asm volatile("":::"memory");
  }
}
 556:	46c0      	nop			@ (mov r8, r8)
 558:	46bd      	mov	sp, r7
 55a:	b002      	add	sp, #8
 55c:	bd80      	pop	{r7, pc}
 55e:	46c0      	nop			@ (mov r8, r8)
 560:	e000e100 	.word	0xe000e100

00000564 <NVIC_DisableIRQ>:

void NVIC_DisableIRQ(uint32_t IRQn)
{
 564:	b580      	push	{r7, lr}
 566:	b082      	sub	sp, #8
 568:	af00      	add	r7, sp, #0
 56a:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 56c:	687b      	ldr	r3, [r7, #4]
 56e:	2b00      	cmp	r3, #0
 570:	db0c      	blt.n	58c <NVIC_DisableIRQ+0x28>
  {
    NVIC->ICER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 572:	687b      	ldr	r3, [r7, #4]
 574:	221f      	movs	r2, #31
 576:	4013      	ands	r3, r2
 578:	4906      	ldr	r1, [pc, #24]	@ (594 <NVIC_DisableIRQ+0x30>)
 57a:	2201      	movs	r2, #1
 57c:	409a      	lsls	r2, r3
 57e:	0013      	movs	r3, r2
 580:	2280      	movs	r2, #128	@ 0x80
 582:	508b      	str	r3, [r1, r2]
    __asm volatile ("dsb 0xF":::"memory");
 584:	f3bf 8f4f 	dsb	sy
    __asm volatile ("isb 0xF":::"memory");
 588:	f3bf 8f6f 	isb	sy
  }
}
 58c:	46c0      	nop			@ (mov r8, r8)
 58e:	46bd      	mov	sp, r7
 590:	b002      	add	sp, #8
 592:	bd80      	pop	{r7, pc}
 594:	e000e100 	.word	0xe000e100

00000598 <_init>:
extern uint32_t __bss_start__;
extern uint32_t __bss_end__;

extern uint32_t __STACK_START;
extern uint32_t __STACK_END;
extern void _init(void) {;}
 598:	b580      	push	{r7, lr}
 59a:	af00      	add	r7, sp, #0
 59c:	46c0      	nop			@ (mov r8, r8)
 59e:	46bd      	mov	sp, r7
 5a0:	bd80      	pop	{r7, pc}

000005a2 <Reset_handler>:
    (uint32_t)can_interrupt_can_IRQHandler,             /*  26 CAN Interrupt */
    (uint32_t)crypto_interrupt_IRQHandler               /*  27 Crypto Interrupt */
};

void Reset_handler(void)
{
 5a2:	b580      	push	{r7, lr}
 5a4:	b086      	sub	sp, #24
 5a6:	af00      	add	r7, sp, #0
    //disable watchdog
    (*(uint32_t *) CYREG_WDT_DISABLE_KEY) = CY_SYS_WDT_KEY;
 5a8:	4b1c      	ldr	r3, [pc, #112]	@ (61c <Reset_handler+0x7a>)
 5aa:	4a1d      	ldr	r2, [pc, #116]	@ (620 <Reset_handler+0x7e>)
 5ac:	601a      	str	r2, [r3, #0]

    //copy .data section to SRAM
    uint32_t size = &__data_end - &__data_start;
 5ae:	4a1d      	ldr	r2, [pc, #116]	@ (624 <Reset_handler+0x82>)
 5b0:	4b1d      	ldr	r3, [pc, #116]	@ (628 <Reset_handler+0x86>)
 5b2:	1ad3      	subs	r3, r2, r3
 5b4:	109b      	asrs	r3, r3, #2
 5b6:	607b      	str	r3, [r7, #4]
    uint32_t *pDst = (uint32_t*)&__data_start;
 5b8:	4b1b      	ldr	r3, [pc, #108]	@ (628 <Reset_handler+0x86>)
 5ba:	617b      	str	r3, [r7, #20]
    uint32_t *pSrc = (uint32_t*)&_la_data;
 5bc:	4b1b      	ldr	r3, [pc, #108]	@ (62c <Reset_handler+0x8a>)
 5be:	613b      	str	r3, [r7, #16]

    for(uint32_t i = 0; i< size; i++)
 5c0:	2300      	movs	r3, #0
 5c2:	60fb      	str	r3, [r7, #12]
 5c4:	e00a      	b.n	5dc <Reset_handler+0x3a>
    {
        *pDst++ = *pSrc++;
 5c6:	693a      	ldr	r2, [r7, #16]
 5c8:	1d13      	adds	r3, r2, #4
 5ca:	613b      	str	r3, [r7, #16]
 5cc:	697b      	ldr	r3, [r7, #20]
 5ce:	1d19      	adds	r1, r3, #4
 5d0:	6179      	str	r1, [r7, #20]
 5d2:	6812      	ldr	r2, [r2, #0]
 5d4:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 5d6:	68fb      	ldr	r3, [r7, #12]
 5d8:	3301      	adds	r3, #1
 5da:	60fb      	str	r3, [r7, #12]
 5dc:	68fa      	ldr	r2, [r7, #12]
 5de:	687b      	ldr	r3, [r7, #4]
 5e0:	429a      	cmp	r2, r3
 5e2:	d3f0      	bcc.n	5c6 <Reset_handler+0x24>
    }
    //int the .bss section to zero in SRAM
    size = &__bss_end__ - &__bss_start__;
 5e4:	4a12      	ldr	r2, [pc, #72]	@ (630 <Reset_handler+0x8e>)
 5e6:	4b13      	ldr	r3, [pc, #76]	@ (634 <Reset_handler+0x92>)
 5e8:	1ad3      	subs	r3, r2, r3
 5ea:	109b      	asrs	r3, r3, #2
 5ec:	607b      	str	r3, [r7, #4]
    pDst = (uint32_t*)&__bss_start__;
 5ee:	4b11      	ldr	r3, [pc, #68]	@ (634 <Reset_handler+0x92>)
 5f0:	617b      	str	r3, [r7, #20]

    for(uint32_t i = 0; i< size; i++)
 5f2:	2300      	movs	r3, #0
 5f4:	60bb      	str	r3, [r7, #8]
 5f6:	e007      	b.n	608 <Reset_handler+0x66>
    {
        *pDst++ = 0;
 5f8:	697b      	ldr	r3, [r7, #20]
 5fa:	1d1a      	adds	r2, r3, #4
 5fc:	617a      	str	r2, [r7, #20]
 5fe:	2200      	movs	r2, #0
 600:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 602:	68bb      	ldr	r3, [r7, #8]
 604:	3301      	adds	r3, #1
 606:	60bb      	str	r3, [r7, #8]
 608:	68ba      	ldr	r2, [r7, #8]
 60a:	687b      	ldr	r3, [r7, #4]
 60c:	429a      	cmp	r2, r3
 60e:	d3f3      	bcc.n	5f8 <Reset_handler+0x56>
    }

    // Init C std libs
    __libc_init_array();
 610:	f000 f81a 	bl	648 <__libc_init_array>
    

    //call main()
    main();
 614:	f7ff fd54 	bl	c0 <main>

    while (1)
 618:	46c0      	nop			@ (mov r8, r8)
 61a:	e7fd      	b.n	618 <Reset_handler+0x76>
 61c:	40030038 	.word	0x40030038
 620:	aced8865 	.word	0xaced8865
 624:	20000000 	.word	0x20000000
 628:	20000000 	.word	0x20000000
 62c:	000006b4 	.word	0x000006b4
 630:	20000000 	.word	0x20000000
 634:	20000000 	.word	0x20000000

00000638 <Default_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Exceptions / Interrupts
 *----------------------------------------------------------------------------*/
void Default_Handler(void)
{
 638:	b580      	push	{r7, lr}
 63a:	af00      	add	r7, sp, #0
    while(1);
 63c:	46c0      	nop			@ (mov r8, r8)
 63e:	e7fd      	b.n	63c <Default_Handler+0x4>

00000640 <HRDFLT_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Hard Fault
 *----------------------------------------------------------------------------*/
void HRDFLT_Handler(void)
{
 640:	b580      	push	{r7, lr}
 642:	af00      	add	r7, sp, #0
    while(1);
 644:	46c0      	nop			@ (mov r8, r8)
 646:	e7fd      	b.n	644 <HRDFLT_Handler+0x4>

00000648 <__libc_init_array>:
 648:	b570      	push	{r4, r5, r6, lr}
 64a:	2600      	movs	r6, #0
 64c:	4c0c      	ldr	r4, [pc, #48]	@ (680 <__libc_init_array+0x38>)
 64e:	4d0d      	ldr	r5, [pc, #52]	@ (684 <__libc_init_array+0x3c>)
 650:	1b64      	subs	r4, r4, r5
 652:	10a4      	asrs	r4, r4, #2
 654:	42a6      	cmp	r6, r4
 656:	d109      	bne.n	66c <__libc_init_array+0x24>
 658:	2600      	movs	r6, #0
 65a:	f7ff ff9d 	bl	598 <_init>
 65e:	4c0a      	ldr	r4, [pc, #40]	@ (688 <__libc_init_array+0x40>)
 660:	4d0a      	ldr	r5, [pc, #40]	@ (68c <__libc_init_array+0x44>)
 662:	1b64      	subs	r4, r4, r5
 664:	10a4      	asrs	r4, r4, #2
 666:	42a6      	cmp	r6, r4
 668:	d105      	bne.n	676 <__libc_init_array+0x2e>
 66a:	bd70      	pop	{r4, r5, r6, pc}
 66c:	00b3      	lsls	r3, r6, #2
 66e:	58eb      	ldr	r3, [r5, r3]
 670:	4798      	blx	r3
 672:	3601      	adds	r6, #1
 674:	e7ee      	b.n	654 <__libc_init_array+0xc>
 676:	00b3      	lsls	r3, r6, #2
 678:	58eb      	ldr	r3, [r5, r3]
 67a:	4798      	blx	r3
 67c:	3601      	adds	r6, #1
 67e:	e7f2      	b.n	666 <__libc_init_array+0x1e>
	...

00000690 <LED_config>:
 690:	0001 0000 0006 0000 0000 0000               ............

0000069c <LED8_P1_6_config>:
 69c:	0001 0000 0006 0000 0000 0000               ............

000006a8 <SW2_P3_7_config>:
 6a8:	0001 0000 0002 0000 0002 0000               ............
