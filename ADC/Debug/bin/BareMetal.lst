
bin/BareMetal.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a80  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  20000000  20000000  00001a80  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  20000000  00000a80  00002000  2**1
                  ALLOC
  3 Heap          00002df8  20000008  00000a80  00002008  2**0
                  ALLOC
  4 Stack         00000200  20002e00  00000a80  00001e00  2**0
                  ALLOC
  5 .debug_info   00001420  00000000  00000000  00001a80  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_abbrev 000006a7  00000000  00000000  00002ea0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_aranges 000000c0  00000000  00000000  00003547  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00000c85  00000000  00000000  00003607  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    000008af  00000000  00000000  0000428c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000044  00000000  00000000  00004b3b  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002c  00000000  00000000  00004b7f  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000478  00000000  00000000  00004bac  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <vector>:
   0:	00 40 00 20 7b 09 00 00 11 0a 00 00 19 0a 00 00     .@. {...........
	...
  2c:	11 0a 00 00 00 00 00 00 00 00 00 00 11 0a 00 00     ................
  3c:	11 0a 00 00 11 0a 00 00 11 0a 00 00 11 0a 00 00     ................
  4c:	11 0a 00 00 11 0a 00 00 11 0a 00 00 11 0a 00 00     ................
  5c:	11 0a 00 00 11 0a 00 00 11 0a 00 00 11 0a 00 00     ................
  6c:	11 0a 00 00 11 0a 00 00 11 0a 00 00 11 0a 00 00     ................
  7c:	11 0a 00 00 11 0a 00 00 11 0a 00 00 11 0a 00 00     ................
  8c:	11 0a 00 00 11 0a 00 00 11 0a 00 00 11 0a 00 00     ................
  9c:	11 0a 00 00 11 0a 00 00 11 0a 00 00 11 0a 00 00     ................
  ac:	11 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
  bc:	00 00 00 00                                         ....

000000c0 <main>:
    .driveMode = 0x06UL,
    .intEdge = 0x00UL,
};

int main()
{  
  c0:	b580      	push	{r7, lr}
  c2:	b082      	sub	sp, #8
  c4:	af02      	add	r7, sp, #8
    /* HF CLOCK divider init*/
   // Cy_SysClk_ClkHfSetDivider(0u); //0 - No Divider, 1 - DIV by 2, 2 = DIV by 4, 3 = DIV by 8
    // clock_config();

    GPIO_Pin_Init(2, 1u, &LED8_P2_1_config, HSIOM_SEL_GPIO);
  c6:	4a4b      	ldr	r2, [pc, #300]	@ (1f4 <main+0x134>)
  c8:	2300      	movs	r3, #0
  ca:	2101      	movs	r1, #1
  cc:	2002      	movs	r0, #2
  ce:	f000 f9e3 	bl	498 <GPIO_Pin_Init>

	/* Configure P2.2 for LED*/
	// *((uint32_t *)0x40040200) = (1 << 2); // Set default output value of P2.2 to 1 GPIO_PRT2_DR
	// *((uint32_t *)0x40040208) |= (0x6 << 6u); // set drive mode of P2.2 to strong drive mode -> GPIO2.2.PC
	// *((uint32_t *)0x40020200) &= ~(0xF << 8u); // Clear HSIOM_PORT_SEL2 pin 2 -> SW GPIO
    GPIO_Pin_Init(5, 2u, &LED8_P1_6_config, HSIOM_SEL_GPIO);
  d2:	4a49      	ldr	r2, [pc, #292]	@ (1f8 <main+0x138>)
  d4:	2300      	movs	r3, #0
  d6:	2102      	movs	r1, #2
  d8:	2005      	movs	r0, #5
  da:	f000 f9dd 	bl	498 <GPIO_Pin_Init>
    GPIO_Pin_Init(5, 5u, &LED8_P1_6_config, HSIOM_SEL_GPIO);
  de:	4a46      	ldr	r2, [pc, #280]	@ (1f8 <main+0x138>)
  e0:	2300      	movs	r3, #0
  e2:	2105      	movs	r1, #5
  e4:	2005      	movs	r0, #5
  e6:	f000 f9d7 	bl	498 <GPIO_Pin_Init>
    GPIO_Pin_Init(5, 7u, &LED8_P1_6_config, HSIOM_SEL_GPIO);
  ea:	4a43      	ldr	r2, [pc, #268]	@ (1f8 <main+0x138>)
  ec:	2300      	movs	r3, #0
  ee:	2107      	movs	r1, #7
  f0:	2005      	movs	r0, #5
  f2:	f000 f9d1 	bl	498 <GPIO_Pin_Init>

    /* Peripheral clock initialization */
    init_peri_Clock_Config();
  f6:	f000 f8a4 	bl	242 <init_peri_Clock_Config>

	ADC_Init(0x6, 0x1, 0x7, 0x0);
  fa:	2300      	movs	r3, #0
  fc:	2207      	movs	r2, #7
  fe:	2101      	movs	r1, #1
 100:	2006      	movs	r0, #6
 102:	f000 fb2f 	bl	764 <ADC_Init>
	ADC_ChannelConfig(0x0, 0x0, 0x0, 0x00, 0x1);
 106:	2301      	movs	r3, #1
 108:	9300      	str	r3, [sp, #0]
 10a:	2300      	movs	r3, #0
 10c:	2200      	movs	r2, #0
 10e:	2100      	movs	r1, #0
 110:	2000      	movs	r0, #0
 112:	f000 fba5 	bl	860 <ADC_ChannelConfig>
    // ADC_SetSubResolution(0x0);
    ADC_ChannelConfig(0x1, 0x1, 0x0, 0x00, 0x1);
 116:	2301      	movs	r3, #1
 118:	9300      	str	r3, [sp, #0]
 11a:	2300      	movs	r3, #0
 11c:	2200      	movs	r2, #0
 11e:	2101      	movs	r1, #1
 120:	2001      	movs	r0, #1
 122:	f000 fb9d 	bl	860 <ADC_ChannelConfig>
    // ADC_SetSubResolution(0x1);
    ADC_ChannelConfig(0x2, 0x2, 0x0, 0x00, 0x1);
 126:	2301      	movs	r3, #1
 128:	9300      	str	r3, [sp, #0]
 12a:	2300      	movs	r3, #0
 12c:	2200      	movs	r2, #0
 12e:	2102      	movs	r1, #2
 130:	2002      	movs	r0, #2
 132:	f000 fb95 	bl	860 <ADC_ChannelConfig>

	ADC_ChannelEnable(0x0);
 136:	2000      	movs	r0, #0
 138:	f000 fbea 	bl	910 <ADC_ChannelEnable>
    ADC_ChannelEnable(0x1);
 13c:	2001      	movs	r0, #1
 13e:	f000 fbe7 	bl	910 <ADC_ChannelEnable>
    ADC_ChannelEnable(0x2);
 142:	2002      	movs	r0, #2
 144:	f000 fbe4 	bl	910 <ADC_ChannelEnable>

								
	//SAR_CHAN_EN -> Channel 0 enable
	// *((uint32_t*)0x403A0020) = (0x1<<0);

    IRQ_EnableGlobal();
 148:	f000 fa8a 	bl	660 <IRQ_EnableGlobal>

    for(;;)
    {
		ADC_StartConversion();
 14c:	f000 fb7e 	bl	84c <ADC_StartConversion>
        // { }

		// // SAR_CHAN_RESULT0 -> Read result
		// chanresult = (uint16_t)((*(uint32_t*)0x403A0180) & 0xFFFF); 

		chanresult = ADC_Read(0x0)& 0xFFF;
 150:	2000      	movs	r0, #0
 152:	f000 fb55 	bl	800 <ADC_Read>
 156:	0003      	movs	r3, r0
 158:	051b      	lsls	r3, r3, #20
 15a:	0d1b      	lsrs	r3, r3, #20
 15c:	b29a      	uxth	r2, r3
 15e:	4b27      	ldr	r3, [pc, #156]	@ (1fc <main+0x13c>)
 160:	801a      	strh	r2, [r3, #0]
		Delay(500);
 162:	23fa      	movs	r3, #250	@ 0xfa
 164:	005b      	lsls	r3, r3, #1
 166:	0018      	movs	r0, r3
 168:	f000 f84e 	bl	208 <Delay>
        
		chanresult2 = ADC_Read(0x2)& 0x3FF;
 16c:	2002      	movs	r0, #2
 16e:	f000 fb47 	bl	800 <ADC_Read>
 172:	0003      	movs	r3, r0
 174:	059b      	lsls	r3, r3, #22
 176:	0d9b      	lsrs	r3, r3, #22
 178:	b29a      	uxth	r2, r3
 17a:	4b21      	ldr	r3, [pc, #132]	@ (200 <__HEAP_SIZE>)
 17c:	801a      	strh	r2, [r3, #0]

		 Delay(500);
 17e:	23fa      	movs	r3, #250	@ 0xfa
 180:	005b      	lsls	r3, r3, #1
 182:	0018      	movs	r0, r3
 184:	f000 f840 	bl	208 <Delay>
		chanresult1 = ADC_Read(0x1)& 0xFF;
 188:	2001      	movs	r0, #1
 18a:	f000 fb39 	bl	800 <ADC_Read>
 18e:	0003      	movs	r3, r0
 190:	b2da      	uxtb	r2, r3
 192:	4b1c      	ldr	r3, [pc, #112]	@ (204 <__HEAP_SIZE+0x4>)
 194:	701a      	strb	r2, [r3, #0]

		//Turn ON LED if light is low on LDR
		if(chanresult>2000)
 196:	4b19      	ldr	r3, [pc, #100]	@ (1fc <main+0x13c>)
 198:	881b      	ldrh	r3, [r3, #0]
 19a:	b29a      	uxth	r2, r3
 19c:	23fa      	movs	r3, #250	@ 0xfa
 19e:	00db      	lsls	r3, r3, #3
 1a0:	429a      	cmp	r2, r3
 1a2:	d904      	bls.n	1ae <main+0xee>
		{
			// clear P2.2 -> TURNS ON LED10
            GPIO_Clr(5,2);
 1a4:	2102      	movs	r1, #2
 1a6:	2005      	movs	r0, #5
 1a8:	f000 f87c 	bl	2a4 <GPIO_Clr>
 1ac:	e003      	b.n	1b6 <main+0xf6>
			// *((uint32_t *)0x40040200) &= ~(1 << 2); 
		}
		else
		{
            GPIO_Set(5,2);
 1ae:	2102      	movs	r1, #2
 1b0:	2005      	movs	r0, #5
 1b2:	f000 f85d 	bl	270 <GPIO_Set>
			// Set P2.2 -> TURNS OFF LED10
			// *((uint32_t *)0x40040200) |= (1 << 2); 
		}
        //Turn ON LED if light is low on LDR
		if(chanresult1>200)
 1b6:	4b13      	ldr	r3, [pc, #76]	@ (204 <__HEAP_SIZE+0x4>)
 1b8:	781b      	ldrb	r3, [r3, #0]
 1ba:	b2db      	uxtb	r3, r3
 1bc:	2bc8      	cmp	r3, #200	@ 0xc8
 1be:	d904      	bls.n	1ca <main+0x10a>
		{
			// clear P2.2 -> TURNS ON LED10
            GPIO_Clr(5,5);
 1c0:	2105      	movs	r1, #5
 1c2:	2005      	movs	r0, #5
 1c4:	f000 f86e 	bl	2a4 <GPIO_Clr>
 1c8:	e003      	b.n	1d2 <main+0x112>
			// *((uint32_t *)0x40040200) &= ~(1 << 2); 
		}
		else
		{
            GPIO_Set(5,5);
 1ca:	2105      	movs	r1, #5
 1cc:	2005      	movs	r0, #5
 1ce:	f000 f84f 	bl	270 <GPIO_Set>
			// Set P2.2 -> TURNS OFF LED10
			// *((uint32_t *)0x40040200) |= (1 << 2); 
		}
        //Turn ON LED if light is low on LDR
		if(chanresult2>700)
 1d2:	4b0b      	ldr	r3, [pc, #44]	@ (200 <__HEAP_SIZE>)
 1d4:	881b      	ldrh	r3, [r3, #0]
 1d6:	b29a      	uxth	r2, r3
 1d8:	23af      	movs	r3, #175	@ 0xaf
 1da:	009b      	lsls	r3, r3, #2
 1dc:	429a      	cmp	r2, r3
 1de:	d904      	bls.n	1ea <main+0x12a>
		{
			// clear P2.2 -> TURNS ON LED10
            GPIO_Clr(5,7);
 1e0:	2107      	movs	r1, #7
 1e2:	2005      	movs	r0, #5
 1e4:	f000 f85e 	bl	2a4 <GPIO_Clr>
 1e8:	e7b0      	b.n	14c <main+0x8c>
			// *((uint32_t *)0x40040200) &= ~(1 << 2); 
		}
		else
		{
            GPIO_Set(5,7);
 1ea:	2107      	movs	r1, #7
 1ec:	2005      	movs	r0, #5
 1ee:	f000 f83f 	bl	270 <GPIO_Set>
		ADC_StartConversion();
 1f2:	e7ab      	b.n	14c <main+0x8c>
 1f4:	00000a68 	.word	0x00000a68
 1f8:	00000a74 	.word	0x00000a74
 1fc:	20000000 	.word	0x20000000
 200:	20000004 	.word	0x20000004
 204:	20000002 	.word	0x20000002

00000208 <Delay>:
    return 0;
}

/*Delay with simple for loops*/
void Delay(int32_t delayNumber)
{
 208:	b580      	push	{r7, lr}
 20a:	b084      	sub	sp, #16
 20c:	af00      	add	r7, sp, #0
 20e:	6078      	str	r0, [r7, #4]
    for(int32_t i=0; i<delayNumber; i++);
 210:	2300      	movs	r3, #0
 212:	60fb      	str	r3, [r7, #12]
 214:	e002      	b.n	21c <Delay+0x14>
 216:	68fb      	ldr	r3, [r7, #12]
 218:	3301      	adds	r3, #1
 21a:	60fb      	str	r3, [r7, #12]
 21c:	68fa      	ldr	r2, [r7, #12]
 21e:	687b      	ldr	r3, [r7, #4]
 220:	429a      	cmp	r2, r3
 222:	dbf8      	blt.n	216 <Delay+0xe>
    for(int32_t i=0; i<delayNumber; i++);
 224:	2300      	movs	r3, #0
 226:	60bb      	str	r3, [r7, #8]
 228:	e002      	b.n	230 <Delay+0x28>
 22a:	68bb      	ldr	r3, [r7, #8]
 22c:	3301      	adds	r3, #1
 22e:	60bb      	str	r3, [r7, #8]
 230:	68ba      	ldr	r2, [r7, #8]
 232:	687b      	ldr	r3, [r7, #4]
 234:	429a      	cmp	r2, r3
 236:	dbf8      	blt.n	22a <Delay+0x22>
}
 238:	46c0      	nop			@ (mov r8, r8)
 23a:	46c0      	nop			@ (mov r8, r8)
 23c:	46bd      	mov	sp, r7
 23e:	b004      	add	sp, #16
 240:	bd80      	pop	{r7, pc}

00000242 <init_peri_Clock_Config>:

/*Peripheral clock initilizations*/
void init_peri_Clock_Config()
{
 242:	b580      	push	{r7, lr}
 244:	af00      	add	r7, sp, #0
    PeriClock_DisableDivider(1,3); // Disable Divider type 1 (16-bit) Divider number 3
 246:	2103      	movs	r1, #3
 248:	2001      	movs	r0, #1
 24a:	f000 f983 	bl	554 <PeriClock_DisableDivider>
    PeriClock_Set_16_Divider(3, 2); // Set the divider value for divider 3
 24e:	2102      	movs	r1, #2
 250:	2003      	movs	r0, #3
 252:	f000 f9c7 	bl	5e4 <PeriClock_Set_16_Divider>
    PeriClock_EnableDivider(1,3); // Enable Divider type 1 (16-bit) Divider number 3 
 256:	2103      	movs	r1, #3
 258:	2001      	movs	r0, #1
 25a:	f000 f99f 	bl	59c <PeriClock_EnableDivider>
    PeriClock_AssignDivider(18,1,3); // Assign Divider type 1 (16-bit) Divider number 3 to PERIPHERAL 8
 25e:	2203      	movs	r2, #3
 260:	2101      	movs	r1, #1
 262:	2012      	movs	r0, #18
 264:	f000 f9d2 	bl	60c <PeriClock_AssignDivider>
	/* ADC CLOCK CONFIGURATION*/
	// *((uint32_t *)0x40010000) = (1<<30)|(1<<6)|(1<<0); // Disable the Divider 1 using PERI_DIV_CMD 
	// *((uint32_t *)0x40010304) = (2 - 1) << 8 ; //Set the divider value in PERI_DIV_16_CTL1, We are configuring Divider 1 to 12MHz
	// *((uint32_t *)0x40010000) |= (1<<31) |(3<<14) |(63<<8) |(1<<6)|(1<<0); //PERI_DIV_CMD 
	// *((uint32_t *)0x40010148) = (1<<6)|(1<<0); // Specify Divider type 7:6 and Selected Divider 3:0 (Divider 1) in register PERI_PCLK_CTL18 ADC is PERIPHERAL 18
 268:	46c0      	nop			@ (mov r8, r8)
 26a:	46bd      	mov	sp, r7
 26c:	bd80      	pop	{r7, pc}
 26e:	46c0      	nop			@ (mov r8, r8)

00000270 <GPIO_Set>:
#include <stdint.h>
#include "gpio.h"

void GPIO_Set(uint8_t portNum, uint32_t pinNum)
{
 270:	b580      	push	{r7, lr}
 272:	b084      	sub	sp, #16
 274:	af00      	add	r7, sp, #0
 276:	0002      	movs	r2, r0
 278:	6039      	str	r1, [r7, #0]
 27a:	1dfb      	adds	r3, r7, #7
 27c:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 27e:	1dfb      	adds	r3, r7, #7
 280:	781b      	ldrb	r3, [r3, #0]
 282:	4a07      	ldr	r2, [pc, #28]	@ (2a0 <GPIO_Set+0x30>)
 284:	4694      	mov	ip, r2
 286:	4463      	add	r3, ip
 288:	021b      	lsls	r3, r3, #8
 28a:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_SET(base) = GPIO_DR_MASK << pinNum;
 28c:	2201      	movs	r2, #1
 28e:	683b      	ldr	r3, [r7, #0]
 290:	409a      	lsls	r2, r3
 292:	68fb      	ldr	r3, [r7, #12]
 294:	641a      	str	r2, [r3, #64]	@ 0x40
}
 296:	46c0      	nop			@ (mov r8, r8)
 298:	46bd      	mov	sp, r7
 29a:	b004      	add	sp, #16
 29c:	bd80      	pop	{r7, pc}
 29e:	46c0      	nop			@ (mov r8, r8)
 2a0:	00400400 	.word	0x00400400

000002a4 <GPIO_Clr>:

void GPIO_Clr(uint8_t portNum, uint32_t pinNum)
{
 2a4:	b580      	push	{r7, lr}
 2a6:	b084      	sub	sp, #16
 2a8:	af00      	add	r7, sp, #0
 2aa:	0002      	movs	r2, r0
 2ac:	6039      	str	r1, [r7, #0]
 2ae:	1dfb      	adds	r3, r7, #7
 2b0:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 2b2:	1dfb      	adds	r3, r7, #7
 2b4:	781b      	ldrb	r3, [r3, #0]
 2b6:	4a07      	ldr	r2, [pc, #28]	@ (2d4 <GPIO_Clr+0x30>)
 2b8:	4694      	mov	ip, r2
 2ba:	4463      	add	r3, ip
 2bc:	021b      	lsls	r3, r3, #8
 2be:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_CLR(base) = GPIO_DR_MASK << pinNum;
 2c0:	2201      	movs	r2, #1
 2c2:	683b      	ldr	r3, [r7, #0]
 2c4:	409a      	lsls	r2, r3
 2c6:	68fb      	ldr	r3, [r7, #12]
 2c8:	645a      	str	r2, [r3, #68]	@ 0x44
}
 2ca:	46c0      	nop			@ (mov r8, r8)
 2cc:	46bd      	mov	sp, r7
 2ce:	b004      	add	sp, #16
 2d0:	bd80      	pop	{r7, pc}
 2d2:	46c0      	nop			@ (mov r8, r8)
 2d4:	00400400 	.word	0x00400400

000002d8 <GPIO_Inv>:

void GPIO_Inv(uint8_t portNum, uint32_t pinNum)
{
 2d8:	b580      	push	{r7, lr}
 2da:	b084      	sub	sp, #16
 2dc:	af00      	add	r7, sp, #0
 2de:	0002      	movs	r2, r0
 2e0:	6039      	str	r1, [r7, #0]
 2e2:	1dfb      	adds	r3, r7, #7
 2e4:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 2e6:	1dfb      	adds	r3, r7, #7
 2e8:	781b      	ldrb	r3, [r3, #0]
 2ea:	4a07      	ldr	r2, [pc, #28]	@ (308 <GPIO_Inv+0x30>)
 2ec:	4694      	mov	ip, r2
 2ee:	4463      	add	r3, ip
 2f0:	021b      	lsls	r3, r3, #8
 2f2:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_INV(base) = GPIO_DR_MASK << pinNum;
 2f4:	2201      	movs	r2, #1
 2f6:	683b      	ldr	r3, [r7, #0]
 2f8:	409a      	lsls	r2, r3
 2fa:	68fb      	ldr	r3, [r7, #12]
 2fc:	649a      	str	r2, [r3, #72]	@ 0x48
}
 2fe:	46c0      	nop			@ (mov r8, r8)
 300:	46bd      	mov	sp, r7
 302:	b004      	add	sp, #16
 304:	bd80      	pop	{r7, pc}
 306:	46c0      	nop			@ (mov r8, r8)
 308:	00400400 	.word	0x00400400

0000030c <GPIO_Read>:

uint32_t GPIO_Read(uint8_t portNum, uint32_t pinNum)
{
 30c:	b580      	push	{r7, lr}
 30e:	b084      	sub	sp, #16
 310:	af00      	add	r7, sp, #0
 312:	0002      	movs	r2, r0
 314:	6039      	str	r1, [r7, #0]
 316:	1dfb      	adds	r3, r7, #7
 318:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 31a:	1dfb      	adds	r3, r7, #7
 31c:	781b      	ldrb	r3, [r3, #0]
 31e:	4a08      	ldr	r2, [pc, #32]	@ (340 <GPIO_Read+0x34>)
 320:	4694      	mov	ip, r2
 322:	4463      	add	r3, ip
 324:	021b      	lsls	r3, r3, #8
 326:	60fb      	str	r3, [r7, #12]
    return (GPIO_PRT_IN(base) >> (pinNum)) & GPIO_PS_MASK;
 328:	68fb      	ldr	r3, [r7, #12]
 32a:	685a      	ldr	r2, [r3, #4]
 32c:	683b      	ldr	r3, [r7, #0]
 32e:	40da      	lsrs	r2, r3
 330:	0013      	movs	r3, r2
 332:	2201      	movs	r2, #1
 334:	4013      	ands	r3, r2
}
 336:	0018      	movs	r0, r3
 338:	46bd      	mov	sp, r7
 33a:	b004      	add	sp, #16
 33c:	bd80      	pop	{r7, pc}
 33e:	46c0      	nop			@ (mov r8, r8)
 340:	00400400 	.word	0x00400400

00000344 <GPIO_SetDrivemode>:

void GPIO_SetDrivemode(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 344:	b580      	push	{r7, lr}
 346:	b088      	sub	sp, #32
 348:	af00      	add	r7, sp, #0
 34a:	60b9      	str	r1, [r7, #8]
 34c:	607a      	str	r2, [r7, #4]
 34e:	210f      	movs	r1, #15
 350:	187b      	adds	r3, r7, r1
 352:	1c02      	adds	r2, r0, #0
 354:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 356:	187b      	adds	r3, r7, r1
 358:	781b      	ldrb	r3, [r3, #0]
 35a:	4a19      	ldr	r2, [pc, #100]	@ (3c0 <GPIO_SetDrivemode+0x7c>)
 35c:	4694      	mov	ip, r2
 35e:	4463      	add	r3, ip
 360:	021b      	lsls	r3, r3, #8
 362:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum * GPIO_DRIVE_MODE_OFFSET;
 364:	68ba      	ldr	r2, [r7, #8]
 366:	0013      	movs	r3, r2
 368:	005b      	lsls	r3, r3, #1
 36a:	189b      	adds	r3, r3, r2
 36c:	61bb      	str	r3, [r7, #24]
    tempReg = ((((GPIO_PRT_Type*)(base))->PC) & ~(GPIO_PC_DM_MASK << pinLoc));
 36e:	69fb      	ldr	r3, [r7, #28]
 370:	689b      	ldr	r3, [r3, #8]
 372:	2107      	movs	r1, #7
 374:	69ba      	ldr	r2, [r7, #24]
 376:	4091      	lsls	r1, r2
 378:	000a      	movs	r2, r1
 37a:	43d2      	mvns	r2, r2
 37c:	4013      	ands	r3, r2
 37e:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC) = tempReg | ((value & GPIO_PC_DM_MASK) << pinLoc);
 380:	687b      	ldr	r3, [r7, #4]
 382:	2207      	movs	r2, #7
 384:	401a      	ands	r2, r3
 386:	69bb      	ldr	r3, [r7, #24]
 388:	409a      	lsls	r2, r3
 38a:	697b      	ldr	r3, [r7, #20]
 38c:	431a      	orrs	r2, r3
 38e:	69fb      	ldr	r3, [r7, #28]
 390:	609a      	str	r2, [r3, #8]

    tempReg = ((((GPIO_PRT_Type*)(base))->PC2) & ~(GPIO_PC_DM_IBUF_MASK << pinNum));
 392:	69fb      	ldr	r3, [r7, #28]
 394:	699b      	ldr	r3, [r3, #24]
 396:	2101      	movs	r1, #1
 398:	68ba      	ldr	r2, [r7, #8]
 39a:	4091      	lsls	r1, r2
 39c:	000a      	movs	r2, r1
 39e:	43d2      	mvns	r2, r2
 3a0:	4013      	ands	r3, r2
 3a2:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC2) = tempReg | (((value & GPIO_DM_VAL_IBUF_DISABLE_MASK) >> GPIO_DRIVE_MODE_OFFSET) << pinNum);
 3a4:	687b      	ldr	r3, [r7, #4]
 3a6:	08db      	lsrs	r3, r3, #3
 3a8:	2201      	movs	r2, #1
 3aa:	401a      	ands	r2, r3
 3ac:	68bb      	ldr	r3, [r7, #8]
 3ae:	409a      	lsls	r2, r3
 3b0:	697b      	ldr	r3, [r7, #20]
 3b2:	431a      	orrs	r2, r3
 3b4:	69fb      	ldr	r3, [r7, #28]
 3b6:	619a      	str	r2, [r3, #24]
}
 3b8:	46c0      	nop			@ (mov r8, r8)
 3ba:	46bd      	mov	sp, r7
 3bc:	b008      	add	sp, #32
 3be:	bd80      	pop	{r7, pc}
 3c0:	00400400 	.word	0x00400400

000003c4 <GPIO_SetHSIOM>:


void GPIO_SetHSIOM(uint8_t portNum, uint32_t pinNum, uint8_t value)
{
 3c4:	b580      	push	{r7, lr}
 3c6:	b086      	sub	sp, #24
 3c8:	af00      	add	r7, sp, #0
 3ca:	6039      	str	r1, [r7, #0]
 3cc:	0011      	movs	r1, r2
 3ce:	1dfb      	adds	r3, r7, #7
 3d0:	1c02      	adds	r2, r0, #0
 3d2:	701a      	strb	r2, [r3, #0]
 3d4:	1dbb      	adds	r3, r7, #6
 3d6:	1c0a      	adds	r2, r1, #0
 3d8:	701a      	strb	r2, [r3, #0]
    uint32_t HSIOM_portNum;
    uint32_t tempReg;
    HSIOM_PRT_Type* portAddrHSIOM;
    
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 3da:	1dfb      	adds	r3, r7, #7
 3dc:	781b      	ldrb	r3, [r3, #0]
 3de:	4a15      	ldr	r2, [pc, #84]	@ (434 <GPIO_SetHSIOM+0x70>)
 3e0:	4694      	mov	ip, r2
 3e2:	4463      	add	r3, ip
 3e4:	021b      	lsls	r3, r3, #8
 3e6:	617b      	str	r3, [r7, #20]

    HSIOM_portNum = ((uint32_t)(base) - 0x40040000UL) / 0x00000100UL;
 3e8:	697b      	ldr	r3, [r7, #20]
 3ea:	4a13      	ldr	r2, [pc, #76]	@ (438 <GPIO_SetHSIOM+0x74>)
 3ec:	4694      	mov	ip, r2
 3ee:	4463      	add	r3, ip
 3f0:	0a1b      	lsrs	r3, r3, #8
 3f2:	613b      	str	r3, [r7, #16]
    portAddrHSIOM = (HSIOM_PRT_Type*)(0x40020000UL + (0x00000100UL * HSIOM_portNum));
 3f4:	693b      	ldr	r3, [r7, #16]
 3f6:	4a11      	ldr	r2, [pc, #68]	@ (43c <GPIO_SetHSIOM+0x78>)
 3f8:	4694      	mov	ip, r2
 3fa:	4463      	add	r3, ip
 3fc:	021b      	lsls	r3, r3, #8
 3fe:	60fb      	str	r3, [r7, #12]

    tempReg = (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) & ~(GPIO_HSIOM_MASK << (pinNum << GPIO_HSIOM_OFFSET));
 400:	68fb      	ldr	r3, [r7, #12]
 402:	681b      	ldr	r3, [r3, #0]
 404:	683a      	ldr	r2, [r7, #0]
 406:	0092      	lsls	r2, r2, #2
 408:	210f      	movs	r1, #15
 40a:	4091      	lsls	r1, r2
 40c:	000a      	movs	r2, r1
 40e:	43d2      	mvns	r2, r2
 410:	4013      	ands	r3, r2
 412:	60bb      	str	r3, [r7, #8]
    (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) = tempReg | (( (uint32_t) value & GPIO_HSIOM_MASK) << (pinNum << GPIO_HSIOM_OFFSET));
 414:	1dbb      	adds	r3, r7, #6
 416:	781b      	ldrb	r3, [r3, #0]
 418:	220f      	movs	r2, #15
 41a:	401a      	ands	r2, r3
 41c:	683b      	ldr	r3, [r7, #0]
 41e:	009b      	lsls	r3, r3, #2
 420:	409a      	lsls	r2, r3
 422:	68bb      	ldr	r3, [r7, #8]
 424:	431a      	orrs	r2, r3
 426:	68fb      	ldr	r3, [r7, #12]
 428:	601a      	str	r2, [r3, #0]
}
 42a:	46c0      	nop			@ (mov r8, r8)
 42c:	46bd      	mov	sp, r7
 42e:	b006      	add	sp, #24
 430:	bd80      	pop	{r7, pc}
 432:	46c0      	nop			@ (mov r8, r8)
 434:	00400400 	.word	0x00400400
 438:	bffc0000 	.word	0xbffc0000
 43c:	00400200 	.word	0x00400200

00000440 <GPIO_SetInterruptEdge>:

void GPIO_SetInterruptEdge(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 440:	b580      	push	{r7, lr}
 442:	b088      	sub	sp, #32
 444:	af00      	add	r7, sp, #0
 446:	60b9      	str	r1, [r7, #8]
 448:	607a      	str	r2, [r7, #4]
 44a:	210f      	movs	r1, #15
 44c:	187b      	adds	r3, r7, r1
 44e:	1c02      	adds	r2, r0, #0
 450:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 452:	187b      	adds	r3, r7, r1
 454:	781b      	ldrb	r3, [r3, #0]
 456:	4a0f      	ldr	r2, [pc, #60]	@ (494 <GPIO_SetInterruptEdge+0x54>)
 458:	4694      	mov	ip, r2
 45a:	4463      	add	r3, ip
 45c:	021b      	lsls	r3, r3, #8
 45e:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum << 0x1u;
 460:	68bb      	ldr	r3, [r7, #8]
 462:	005b      	lsls	r3, r3, #1
 464:	61bb      	str	r3, [r7, #24]
    tempReg = (((GPIO_PRT_Type*)(base))->INTR_CFG) & ~(0x3u << pinLoc);
 466:	69fb      	ldr	r3, [r7, #28]
 468:	68db      	ldr	r3, [r3, #12]
 46a:	2103      	movs	r1, #3
 46c:	69ba      	ldr	r2, [r7, #24]
 46e:	4091      	lsls	r1, r2
 470:	000a      	movs	r2, r1
 472:	43d2      	mvns	r2, r2
 474:	4013      	ands	r3, r2
 476:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->INTR_CFG) = tempReg | ((value & 0x3u) << pinLoc);
 478:	687b      	ldr	r3, [r7, #4]
 47a:	2203      	movs	r2, #3
 47c:	401a      	ands	r2, r3
 47e:	69bb      	ldr	r3, [r7, #24]
 480:	409a      	lsls	r2, r3
 482:	697b      	ldr	r3, [r7, #20]
 484:	431a      	orrs	r2, r3
 486:	69fb      	ldr	r3, [r7, #28]
 488:	60da      	str	r2, [r3, #12]
}
 48a:	46c0      	nop			@ (mov r8, r8)
 48c:	46bd      	mov	sp, r7
 48e:	b008      	add	sp, #32
 490:	bd80      	pop	{r7, pc}
 492:	46c0      	nop			@ (mov r8, r8)
 494:	00400400 	.word	0x00400400

00000498 <GPIO_Pin_Init>:

void GPIO_Pin_Init(uint8_t portNum, uint32_t pinNum, const gpio_pin_config_t *config, uint8_t hsiom)
{
 498:	b590      	push	{r4, r7, lr}
 49a:	b085      	sub	sp, #20
 49c:	af00      	add	r7, sp, #0
 49e:	60b9      	str	r1, [r7, #8]
 4a0:	607a      	str	r2, [r7, #4]
 4a2:	0019      	movs	r1, r3
 4a4:	240f      	movs	r4, #15
 4a6:	193b      	adds	r3, r7, r4
 4a8:	1c02      	adds	r2, r0, #0
 4aa:	701a      	strb	r2, [r3, #0]
 4ac:	230e      	movs	r3, #14
 4ae:	18fb      	adds	r3, r7, r3
 4b0:	1c0a      	adds	r2, r1, #0
 4b2:	701a      	strb	r2, [r3, #0]
    ((config -> outVal) == 0) ? GPIO_Clr(portNum, pinNum) : GPIO_Set(portNum,pinNum);
 4b4:	687b      	ldr	r3, [r7, #4]
 4b6:	681b      	ldr	r3, [r3, #0]
 4b8:	2b00      	cmp	r3, #0
 4ba:	d107      	bne.n	4cc <GPIO_Pin_Init+0x34>
 4bc:	68ba      	ldr	r2, [r7, #8]
 4be:	193b      	adds	r3, r7, r4
 4c0:	781b      	ldrb	r3, [r3, #0]
 4c2:	0011      	movs	r1, r2
 4c4:	0018      	movs	r0, r3
 4c6:	f7ff feed 	bl	2a4 <GPIO_Clr>
 4ca:	e007      	b.n	4dc <GPIO_Pin_Init+0x44>
 4cc:	68ba      	ldr	r2, [r7, #8]
 4ce:	230f      	movs	r3, #15
 4d0:	18fb      	adds	r3, r7, r3
 4d2:	781b      	ldrb	r3, [r3, #0]
 4d4:	0011      	movs	r1, r2
 4d6:	0018      	movs	r0, r3
 4d8:	f7ff feca 	bl	270 <GPIO_Set>
    GPIO_SetDrivemode(portNum, pinNum, config->driveMode);
 4dc:	687b      	ldr	r3, [r7, #4]
 4de:	685a      	ldr	r2, [r3, #4]
 4e0:	68b9      	ldr	r1, [r7, #8]
 4e2:	240f      	movs	r4, #15
 4e4:	193b      	adds	r3, r7, r4
 4e6:	781b      	ldrb	r3, [r3, #0]
 4e8:	0018      	movs	r0, r3
 4ea:	f7ff ff2b 	bl	344 <GPIO_SetDrivemode>
    GPIO_SetHSIOM(portNum, pinNum, hsiom);
 4ee:	230e      	movs	r3, #14
 4f0:	18fb      	adds	r3, r7, r3
 4f2:	781a      	ldrb	r2, [r3, #0]
 4f4:	68b9      	ldr	r1, [r7, #8]
 4f6:	193b      	adds	r3, r7, r4
 4f8:	781b      	ldrb	r3, [r3, #0]
 4fa:	0018      	movs	r0, r3
 4fc:	f7ff ff62 	bl	3c4 <GPIO_SetHSIOM>
    GPIO_SetInterruptEdge(portNum, pinNum, config->intEdge);
 500:	687b      	ldr	r3, [r7, #4]
 502:	689a      	ldr	r2, [r3, #8]
 504:	68b9      	ldr	r1, [r7, #8]
 506:	193b      	adds	r3, r7, r4
 508:	781b      	ldrb	r3, [r3, #0]
 50a:	0018      	movs	r0, r3
 50c:	f7ff ff98 	bl	440 <GPIO_SetInterruptEdge>
}
 510:	46c0      	nop			@ (mov r8, r8)
 512:	46bd      	mov	sp, r7
 514:	b005      	add	sp, #20
 516:	bd90      	pop	{r4, r7, pc}

00000518 <GPIO_ClearInterrupt>:

void GPIO_ClearInterrupt(uint8_t portNum, uint32_t pinNum)
{
 518:	b580      	push	{r7, lr}
 51a:	b084      	sub	sp, #16
 51c:	af00      	add	r7, sp, #0
 51e:	0002      	movs	r2, r0
 520:	6039      	str	r1, [r7, #0]
 522:	1dfb      	adds	r3, r7, #7
 524:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 526:	1dfb      	adds	r3, r7, #7
 528:	781b      	ldrb	r3, [r3, #0]
 52a:	4a09      	ldr	r2, [pc, #36]	@ (550 <GPIO_ClearInterrupt+0x38>)
 52c:	4694      	mov	ip, r2
 52e:	4463      	add	r3, ip
 530:	021b      	lsls	r3, r3, #8
 532:	60fb      	str	r3, [r7, #12]
    /* Any INTR MMIO registers AHB clearing must be preceded with an AHB read access */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 534:	68fb      	ldr	r3, [r7, #12]
 536:	691b      	ldr	r3, [r3, #16]

    (((GPIO_PRT_Type*)(base))->INTR) = (0x01UL) << pinNum;
 538:	2201      	movs	r2, #1
 53a:	683b      	ldr	r3, [r7, #0]
 53c:	409a      	lsls	r2, r3
 53e:	68fb      	ldr	r3, [r7, #12]
 540:	611a      	str	r2, [r3, #16]

    /* This read ensures that the initial write has been flushed out to the hardware */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 542:	68fb      	ldr	r3, [r7, #12]
 544:	691b      	ldr	r3, [r3, #16]
 546:	46c0      	nop			@ (mov r8, r8)
 548:	46bd      	mov	sp, r7
 54a:	b004      	add	sp, #16
 54c:	bd80      	pop	{r7, pc}
 54e:	46c0      	nop			@ (mov r8, r8)
 550:	00400400 	.word	0x00400400

00000554 <PeriClock_DisableDivider>:
#include <stdint.h>
#include "peri_clock.h"

void PeriClock_DisableDivider(uint8_t dividerType, uint32_t dividerNum)
{
 554:	b580      	push	{r7, lr}
 556:	b084      	sub	sp, #16
 558:	af00      	add	r7, sp, #0
 55a:	0002      	movs	r2, r0
 55c:	6039      	str	r1, [r7, #0]
 55e:	1dfb      	adds	r3, r7, #7
 560:	701a      	strb	r2, [r3, #0]
    uint32_t tempreg;
    tempreg = PERI->DIV_CMD;
 562:	4b0c      	ldr	r3, [pc, #48]	@ (594 <PeriClock_DisableDivider+0x40>)
 564:	681b      	ldr	r3, [r3, #0]
 566:	60fb      	str	r3, [r7, #12]
    tempreg &= ~(PERI_DISABLE_MSK);
 568:	68fb      	ldr	r3, [r7, #12]
 56a:	4a0b      	ldr	r2, [pc, #44]	@ (598 <PeriClock_DisableDivider+0x44>)
 56c:	4013      	ands	r3, r2
 56e:	60fb      	str	r3, [r7, #12]
    tempreg |= (1<<30) |(dividerType<<6) | (dividerNum << 0);
 570:	1dfb      	adds	r3, r7, #7
 572:	781b      	ldrb	r3, [r3, #0]
 574:	019a      	lsls	r2, r3, #6
 576:	683b      	ldr	r3, [r7, #0]
 578:	431a      	orrs	r2, r3
 57a:	68fb      	ldr	r3, [r7, #12]
 57c:	4313      	orrs	r3, r2
 57e:	2280      	movs	r2, #128	@ 0x80
 580:	05d2      	lsls	r2, r2, #23
 582:	4313      	orrs	r3, r2
 584:	60fb      	str	r3, [r7, #12]
    PERI->DIV_CMD = tempreg;
 586:	4b03      	ldr	r3, [pc, #12]	@ (594 <PeriClock_DisableDivider+0x40>)
 588:	68fa      	ldr	r2, [r7, #12]
 58a:	601a      	str	r2, [r3, #0]
}
 58c:	46c0      	nop			@ (mov r8, r8)
 58e:	46bd      	mov	sp, r7
 590:	b004      	add	sp, #16
 592:	bd80      	pop	{r7, pc}
 594:	40010000 	.word	0x40010000
 598:	bfffff00 	.word	0xbfffff00

0000059c <PeriClock_EnableDivider>:

void PeriClock_EnableDivider(uint8_t dividerType, uint32_t dividerNum)
{
 59c:	b580      	push	{r7, lr}
 59e:	b084      	sub	sp, #16
 5a0:	af00      	add	r7, sp, #0
 5a2:	0002      	movs	r2, r0
 5a4:	6039      	str	r1, [r7, #0]
 5a6:	1dfb      	adds	r3, r7, #7
 5a8:	701a      	strb	r2, [r3, #0]
    uint32_t tempreg;
    tempreg = PERI->DIV_CMD;
 5aa:	4b0c      	ldr	r3, [pc, #48]	@ (5dc <PeriClock_EnableDivider+0x40>)
 5ac:	681b      	ldr	r3, [r3, #0]
 5ae:	60fb      	str	r3, [r7, #12]
    tempreg &= ~(PERI_ENABLE_MSK);
 5b0:	68fb      	ldr	r3, [r7, #12]
 5b2:	4a0b      	ldr	r2, [pc, #44]	@ (5e0 <PeriClock_EnableDivider+0x44>)
 5b4:	4013      	ands	r3, r2
 5b6:	60fb      	str	r3, [r7, #12]
    tempreg |= (1<<31) |(dividerType<<6) | (dividerNum << 0);
 5b8:	1dfb      	adds	r3, r7, #7
 5ba:	781b      	ldrb	r3, [r3, #0]
 5bc:	019a      	lsls	r2, r3, #6
 5be:	683b      	ldr	r3, [r7, #0]
 5c0:	431a      	orrs	r2, r3
 5c2:	68fb      	ldr	r3, [r7, #12]
 5c4:	4313      	orrs	r3, r2
 5c6:	2280      	movs	r2, #128	@ 0x80
 5c8:	0612      	lsls	r2, r2, #24
 5ca:	4313      	orrs	r3, r2
 5cc:	60fb      	str	r3, [r7, #12]
    PERI->DIV_CMD = tempreg;
 5ce:	4b03      	ldr	r3, [pc, #12]	@ (5dc <PeriClock_EnableDivider+0x40>)
 5d0:	68fa      	ldr	r2, [r7, #12]
 5d2:	601a      	str	r2, [r3, #0]
}
 5d4:	46c0      	nop			@ (mov r8, r8)
 5d6:	46bd      	mov	sp, r7
 5d8:	b004      	add	sp, #16
 5da:	bd80      	pop	{r7, pc}
 5dc:	40010000 	.word	0x40010000
 5e0:	7fffff00 	.word	0x7fffff00

000005e4 <PeriClock_Set_16_Divider>:

void PeriClock_Set_16_Divider(uint32_t dividerNum, uint32_t dividerValue)
{
 5e4:	b580      	push	{r7, lr}
 5e6:	b082      	sub	sp, #8
 5e8:	af00      	add	r7, sp, #0
 5ea:	6078      	str	r0, [r7, #4]
 5ec:	6039      	str	r1, [r7, #0]
    PERI->DIV_16_CTL[dividerNum] = (dividerValue - 1) << 8;
 5ee:	683b      	ldr	r3, [r7, #0]
 5f0:	3b01      	subs	r3, #1
 5f2:	4905      	ldr	r1, [pc, #20]	@ (608 <PeriClock_Set_16_Divider+0x24>)
 5f4:	021a      	lsls	r2, r3, #8
 5f6:	687b      	ldr	r3, [r7, #4]
 5f8:	33c0      	adds	r3, #192	@ 0xc0
 5fa:	009b      	lsls	r3, r3, #2
 5fc:	505a      	str	r2, [r3, r1]
}
 5fe:	46c0      	nop			@ (mov r8, r8)
 600:	46bd      	mov	sp, r7
 602:	b002      	add	sp, #8
 604:	bd80      	pop	{r7, pc}
 606:	46c0      	nop			@ (mov r8, r8)
 608:	40010000 	.word	0x40010000

0000060c <PeriClock_AssignDivider>:

void PeriClock_AssignDivider(uint8_t periphNum, uint8_t dividerType, uint32_t dividerNum)
{
 60c:	b580      	push	{r7, lr}
 60e:	b084      	sub	sp, #16
 610:	af00      	add	r7, sp, #0
 612:	603a      	str	r2, [r7, #0]
 614:	1dfb      	adds	r3, r7, #7
 616:	1c02      	adds	r2, r0, #0
 618:	701a      	strb	r2, [r3, #0]
 61a:	1dbb      	adds	r3, r7, #6
 61c:	1c0a      	adds	r2, r1, #0
 61e:	701a      	strb	r2, [r3, #0]
    uint32_t tempreg;
    tempreg = PERI->PCLK_CTL[periphNum];
 620:	4a0e      	ldr	r2, [pc, #56]	@ (65c <PeriClock_AssignDivider+0x50>)
 622:	1dfb      	adds	r3, r7, #7
 624:	781b      	ldrb	r3, [r3, #0]
 626:	3340      	adds	r3, #64	@ 0x40
 628:	009b      	lsls	r3, r3, #2
 62a:	589b      	ldr	r3, [r3, r2]
 62c:	60fb      	str	r3, [r7, #12]
    tempreg &= ~(0xFFUL);
 62e:	68fb      	ldr	r3, [r7, #12]
 630:	22ff      	movs	r2, #255	@ 0xff
 632:	4393      	bics	r3, r2
 634:	60fb      	str	r3, [r7, #12]
    tempreg |= (dividerType << 6) | dividerNum;
 636:	1dbb      	adds	r3, r7, #6
 638:	781b      	ldrb	r3, [r3, #0]
 63a:	019a      	lsls	r2, r3, #6
 63c:	683b      	ldr	r3, [r7, #0]
 63e:	4313      	orrs	r3, r2
 640:	68fa      	ldr	r2, [r7, #12]
 642:	4313      	orrs	r3, r2
 644:	60fb      	str	r3, [r7, #12]
    PERI->PCLK_CTL[periphNum] = tempreg;    
 646:	4905      	ldr	r1, [pc, #20]	@ (65c <PeriClock_AssignDivider+0x50>)
 648:	1dfb      	adds	r3, r7, #7
 64a:	781b      	ldrb	r3, [r3, #0]
 64c:	3340      	adds	r3, #64	@ 0x40
 64e:	009b      	lsls	r3, r3, #2
 650:	68fa      	ldr	r2, [r7, #12]
 652:	505a      	str	r2, [r3, r1]
}
 654:	46c0      	nop			@ (mov r8, r8)
 656:	46bd      	mov	sp, r7
 658:	b004      	add	sp, #16
 65a:	bd80      	pop	{r7, pc}
 65c:	40010000 	.word	0x40010000

00000660 <IRQ_EnableGlobal>:
#include <stdint.h>

/*
 * Uses the Thumb-2 "CPSIE i" instruction.
 */
void IRQ_EnableGlobal(void) {
 660:	b580      	push	{r7, lr}
 662:	af00      	add	r7, sp, #0
    __asm volatile ("cpsie i" : : : "memory");
 664:	b662      	cpsie	i
}
 666:	46c0      	nop			@ (mov r8, r8)
 668:	46bd      	mov	sp, r7
 66a:	bd80      	pop	{r7, pc}

0000066c <IRQ_DisableGlobal>:

/*
 * Uses the Thumb-2 "CPSID i" instruction.
 */
void IRQ_DisableGlobal(void) {
 66c:	b580      	push	{r7, lr}
 66e:	af00      	add	r7, sp, #0
    __asm volatile ("cpsid i" : : : "memory");
 670:	b672      	cpsid	i
}
 672:	46c0      	nop			@ (mov r8, r8)
 674:	46bd      	mov	sp, r7
 676:	bd80      	pop	{r7, pc}

00000678 <NVIC_SetPriority>:

void NVIC_SetPriority(uint32_t IRQn, uint32_t priority)
{
 678:	b580      	push	{r7, lr}
 67a:	b084      	sub	sp, #16
 67c:	af00      	add	r7, sp, #0
 67e:	6078      	str	r0, [r7, #4]
 680:	6039      	str	r1, [r7, #0]
    if ((int32_t)(IRQn) >= 0){
 682:	687b      	ldr	r3, [r7, #4]
 684:	2b00      	cmp	r3, #0
 686:	db20      	blt.n	6ca <NVIC_SetPriority+0x52>
        uint32_t IRQ_LDX = IRQn >> 2u;
 688:	687b      	ldr	r3, [r7, #4]
 68a:	089b      	lsrs	r3, r3, #2
 68c:	60fb      	str	r3, [r7, #12]
        NVIC->IPR[IRQ_LDX] = (NVIC->IPR[IRQ_LDX] & ~(0xFFUL << ((IRQn & 0x03) << 3))) | (((priority & 0x03) << 6) << ((IRQn & 0x03) << 3));
 68e:	4a11      	ldr	r2, [pc, #68]	@ (6d4 <NVIC_SetPriority+0x5c>)
 690:	68fb      	ldr	r3, [r7, #12]
 692:	33c0      	adds	r3, #192	@ 0xc0
 694:	009b      	lsls	r3, r3, #2
 696:	589b      	ldr	r3, [r3, r2]
 698:	687a      	ldr	r2, [r7, #4]
 69a:	00d2      	lsls	r2, r2, #3
 69c:	2118      	movs	r1, #24
 69e:	400a      	ands	r2, r1
 6a0:	21ff      	movs	r1, #255	@ 0xff
 6a2:	4091      	lsls	r1, r2
 6a4:	000a      	movs	r2, r1
 6a6:	43d2      	mvns	r2, r2
 6a8:	401a      	ands	r2, r3
 6aa:	683b      	ldr	r3, [r7, #0]
 6ac:	019b      	lsls	r3, r3, #6
 6ae:	21ff      	movs	r1, #255	@ 0xff
 6b0:	4019      	ands	r1, r3
 6b2:	687b      	ldr	r3, [r7, #4]
 6b4:	00db      	lsls	r3, r3, #3
 6b6:	2018      	movs	r0, #24
 6b8:	4003      	ands	r3, r0
 6ba:	4099      	lsls	r1, r3
 6bc:	000b      	movs	r3, r1
 6be:	4905      	ldr	r1, [pc, #20]	@ (6d4 <NVIC_SetPriority+0x5c>)
 6c0:	431a      	orrs	r2, r3
 6c2:	68fb      	ldr	r3, [r7, #12]
 6c4:	33c0      	adds	r3, #192	@ 0xc0
 6c6:	009b      	lsls	r3, r3, #2
 6c8:	505a      	str	r2, [r3, r1]
    }
}
 6ca:	46c0      	nop			@ (mov r8, r8)
 6cc:	46bd      	mov	sp, r7
 6ce:	b004      	add	sp, #16
 6d0:	bd80      	pop	{r7, pc}
 6d2:	46c0      	nop			@ (mov r8, r8)
 6d4:	e000e100 	.word	0xe000e100

000006d8 <NVIC_ClearPendingIRQ>:

void NVIC_ClearPendingIRQ(uint32_t IRQn)
{
 6d8:	b580      	push	{r7, lr}
 6da:	b082      	sub	sp, #8
 6dc:	af00      	add	r7, sp, #0
 6de:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 6e0:	687b      	ldr	r3, [r7, #4]
 6e2:	2b00      	cmp	r3, #0
 6e4:	db08      	blt.n	6f8 <NVIC_ClearPendingIRQ+0x20>
  {
    NVIC->ICPR = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 6e6:	687b      	ldr	r3, [r7, #4]
 6e8:	221f      	movs	r2, #31
 6ea:	4013      	ands	r3, r2
 6ec:	4904      	ldr	r1, [pc, #16]	@ (700 <NVIC_ClearPendingIRQ+0x28>)
 6ee:	2201      	movs	r2, #1
 6f0:	409a      	lsls	r2, r3
 6f2:	23c0      	movs	r3, #192	@ 0xc0
 6f4:	005b      	lsls	r3, r3, #1
 6f6:	50ca      	str	r2, [r1, r3]
  }
}
 6f8:	46c0      	nop			@ (mov r8, r8)
 6fa:	46bd      	mov	sp, r7
 6fc:	b002      	add	sp, #8
 6fe:	bd80      	pop	{r7, pc}
 700:	e000e100 	.word	0xe000e100

00000704 <NVIC_EnableIRQ>:

void NVIC_EnableIRQ(uint32_t IRQn)
{
 704:	b580      	push	{r7, lr}
 706:	b082      	sub	sp, #8
 708:	af00      	add	r7, sp, #0
 70a:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 70c:	687b      	ldr	r3, [r7, #4]
 70e:	2b00      	cmp	r3, #0
 710:	db07      	blt.n	722 <NVIC_EnableIRQ+0x1e>
  {
    __asm volatile("":::"memory");
    NVIC->ISER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 712:	687b      	ldr	r3, [r7, #4]
 714:	221f      	movs	r2, #31
 716:	401a      	ands	r2, r3
 718:	4b04      	ldr	r3, [pc, #16]	@ (72c <NVIC_EnableIRQ+0x28>)
 71a:	2101      	movs	r1, #1
 71c:	4091      	lsls	r1, r2
 71e:	000a      	movs	r2, r1
 720:	601a      	str	r2, [r3, #0]
    __asm volatile("":::"memory");
  }
}
 722:	46c0      	nop			@ (mov r8, r8)
 724:	46bd      	mov	sp, r7
 726:	b002      	add	sp, #8
 728:	bd80      	pop	{r7, pc}
 72a:	46c0      	nop			@ (mov r8, r8)
 72c:	e000e100 	.word	0xe000e100

00000730 <NVIC_DisableIRQ>:

void NVIC_DisableIRQ(uint32_t IRQn)
{
 730:	b580      	push	{r7, lr}
 732:	b082      	sub	sp, #8
 734:	af00      	add	r7, sp, #0
 736:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 738:	687b      	ldr	r3, [r7, #4]
 73a:	2b00      	cmp	r3, #0
 73c:	db0c      	blt.n	758 <NVIC_DisableIRQ+0x28>
  {
    NVIC->ICER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 73e:	687b      	ldr	r3, [r7, #4]
 740:	221f      	movs	r2, #31
 742:	4013      	ands	r3, r2
 744:	4906      	ldr	r1, [pc, #24]	@ (760 <NVIC_DisableIRQ+0x30>)
 746:	2201      	movs	r2, #1
 748:	409a      	lsls	r2, r3
 74a:	0013      	movs	r3, r2
 74c:	2280      	movs	r2, #128	@ 0x80
 74e:	508b      	str	r3, [r1, r2]
    __asm volatile ("dsb 0xF":::"memory");
 750:	f3bf 8f4f 	dsb	sy
    __asm volatile ("isb 0xF":::"memory");
 754:	f3bf 8f6f 	isb	sy
  }
}
 758:	46c0      	nop			@ (mov r8, r8)
 75a:	46bd      	mov	sp, r7
 75c:	b002      	add	sp, #8
 75e:	bd80      	pop	{r7, pc}
 760:	e000e100 	.word	0xe000e100

00000764 <ADC_Init>:
#include "adc.h"
#include <stdint.h>

void ADC_Init(uint8_t VrefSelect, uint8_t PositiveInput, uint8_t NegativeInput, uint8_t ContinuousMode)
{
 764:	b5b0      	push	{r4, r5, r7, lr}
 766:	b084      	sub	sp, #16
 768:	af00      	add	r7, sp, #0
 76a:	0005      	movs	r5, r0
 76c:	000c      	movs	r4, r1
 76e:	0010      	movs	r0, r2
 770:	0019      	movs	r1, r3
 772:	1dfb      	adds	r3, r7, #7
 774:	1c2a      	adds	r2, r5, #0
 776:	701a      	strb	r2, [r3, #0]
 778:	1dbb      	adds	r3, r7, #6
 77a:	1c22      	adds	r2, r4, #0
 77c:	701a      	strb	r2, [r3, #0]
 77e:	1d7b      	adds	r3, r7, #5
 780:	1c02      	adds	r2, r0, #0
 782:	701a      	strb	r2, [r3, #0]
 784:	1d3b      	adds	r3, r7, #4
 786:	1c0a      	adds	r2, r1, #0
 788:	701a      	strb	r2, [r3, #0]
    uint32_t tempreg;
    tempreg = ADC->CTRL;
 78a:	4b1a      	ldr	r3, [pc, #104]	@ (7f4 <ADC_Init+0x90>)
 78c:	681b      	ldr	r3, [r3, #0]
 78e:	60fb      	str	r3, [r7, #12]
    tempreg &= ~ADC_CTRL_MASK;
 790:	68fb      	ldr	r3, [r7, #12]
 792:	4a19      	ldr	r2, [pc, #100]	@ (7f8 <ADC_Init+0x94>)
 794:	4013      	ands	r3, r2
 796:	60fb      	str	r3, [r7, #12]
    tempreg |= (((VrefSelect & 0x07) << 4) | 
 798:	1dfb      	adds	r3, r7, #7
 79a:	781b      	ldrb	r3, [r3, #0]
 79c:	011b      	lsls	r3, r3, #4
 79e:	2270      	movs	r2, #112	@ 0x70
 7a0:	401a      	ands	r2, r3
                 (1u << 7) | 
                 ((NegativeInput & 0x07) << 9) | 
 7a2:	1d7b      	adds	r3, r7, #5
 7a4:	781b      	ldrb	r3, [r3, #0]
 7a6:	0259      	lsls	r1, r3, #9
 7a8:	23e0      	movs	r3, #224	@ 0xe0
 7aa:	011b      	lsls	r3, r3, #4
 7ac:	400b      	ands	r3, r1
                 (1u << 7) | 
 7ae:	431a      	orrs	r2, r3
    tempreg |= (((VrefSelect & 0x07) << 4) | 
 7b0:	68fb      	ldr	r3, [r7, #12]
 7b2:	4313      	orrs	r3, r2
 7b4:	4a11      	ldr	r2, [pc, #68]	@ (7fc <ADC_Init+0x98>)
 7b6:	4313      	orrs	r3, r2
 7b8:	60fb      	str	r3, [r7, #12]
                 (1u << 30) | 
                 (1u << 31));
    ADC->CTRL = tempreg;
 7ba:	4b0e      	ldr	r3, [pc, #56]	@ (7f4 <ADC_Init+0x90>)
 7bc:	68fa      	ldr	r2, [r7, #12]
 7be:	601a      	str	r2, [r3, #0]
    ADC->MUX_SWITCH0 = ( 1u << PositiveInput);
 7c0:	1dbb      	adds	r3, r7, #6
 7c2:	781b      	ldrb	r3, [r3, #0]
 7c4:	490b      	ldr	r1, [pc, #44]	@ (7f4 <ADC_Init+0x90>)
 7c6:	2201      	movs	r2, #1
 7c8:	409a      	lsls	r2, r3
 7ca:	23c0      	movs	r3, #192	@ 0xc0
 7cc:	009b      	lsls	r3, r3, #2
 7ce:	50ca      	str	r2, [r1, r3]
    ADC->SAMPLE_CTRL |= (ContinuousMode << 16);
 7d0:	4b08      	ldr	r3, [pc, #32]	@ (7f4 <ADC_Init+0x90>)
 7d2:	6859      	ldr	r1, [r3, #4]
 7d4:	1d3b      	adds	r3, r7, #4
 7d6:	781b      	ldrb	r3, [r3, #0]
 7d8:	041a      	lsls	r2, r3, #16
 7da:	4b06      	ldr	r3, [pc, #24]	@ (7f4 <ADC_Init+0x90>)
 7dc:	430a      	orrs	r2, r1
 7de:	605a      	str	r2, [r3, #4]
    ADC->SAMPLE_TIME01 |= (0xA);
 7e0:	4b04      	ldr	r3, [pc, #16]	@ (7f4 <ADC_Init+0x90>)
 7e2:	691a      	ldr	r2, [r3, #16]
 7e4:	4b03      	ldr	r3, [pc, #12]	@ (7f4 <ADC_Init+0x90>)
 7e6:	210a      	movs	r1, #10
 7e8:	430a      	orrs	r2, r1
 7ea:	611a      	str	r2, [r3, #16]
}
 7ec:	46c0      	nop			@ (mov r8, r8)
 7ee:	46bd      	mov	sp, r7
 7f0:	b004      	add	sp, #16
 7f2:	bdb0      	pop	{r4, r5, r7, pc}
 7f4:	403a0000 	.word	0x403a0000
 7f8:	3ffff10f 	.word	0x3ffff10f
 7fc:	c0000080 	.word	0xc0000080

00000800 <ADC_Read>:


uint16_t ADC_Read(uint8_t channel)
{
 800:	b580      	push	{r7, lr}
 802:	b084      	sub	sp, #16
 804:	af00      	add	r7, sp, #0
 806:	0002      	movs	r2, r0
 808:	1dfb      	adds	r3, r7, #7
 80a:	701a      	strb	r2, [r3, #0]
    uint16_t result;
    // Start conversion on the specified channel
    ADC->START_CTRL = (1 << channel);
 80c:	1dfb      	adds	r3, r7, #7
 80e:	781b      	ldrb	r3, [r3, #0]
 810:	2201      	movs	r2, #1
 812:	409a      	lsls	r2, r3
 814:	4b0c      	ldr	r3, [pc, #48]	@ (848 <ADC_Read+0x48>)
 816:	625a      	str	r2, [r3, #36]	@ 0x24
    
    // Wait for conversion to complete
    while ((ADC->INTR & 0x1) != 0x1){}
 818:	46c0      	nop			@ (mov r8, r8)
 81a:	4a0b      	ldr	r2, [pc, #44]	@ (848 <ADC_Read+0x48>)
 81c:	2384      	movs	r3, #132	@ 0x84
 81e:	009b      	lsls	r3, r3, #2
 820:	58d3      	ldr	r3, [r2, r3]
 822:	2201      	movs	r2, #1
 824:	4013      	ands	r3, r2
 826:	2b01      	cmp	r3, #1
 828:	d1f7      	bne.n	81a <ADC_Read+0x1a>
    
    result = (uint16_t)(ADC->CHAN_RESULT[channel] & 0xFFFF);
 82a:	4a07      	ldr	r2, [pc, #28]	@ (848 <ADC_Read+0x48>)
 82c:	1dfb      	adds	r3, r7, #7
 82e:	781b      	ldrb	r3, [r3, #0]
 830:	3360      	adds	r3, #96	@ 0x60
 832:	009b      	lsls	r3, r3, #2
 834:	589a      	ldr	r2, [r3, r2]
 836:	210e      	movs	r1, #14
 838:	187b      	adds	r3, r7, r1
 83a:	801a      	strh	r2, [r3, #0]
    // Return the result
    return result;
 83c:	187b      	adds	r3, r7, r1
 83e:	881b      	ldrh	r3, [r3, #0]
}
 840:	0018      	movs	r0, r3
 842:	46bd      	mov	sp, r7
 844:	b004      	add	sp, #16
 846:	bd80      	pop	{r7, pc}
 848:	403a0000 	.word	0x403a0000

0000084c <ADC_StartConversion>:

void ADC_StartConversion(void)
{
 84c:	b580      	push	{r7, lr}
 84e:	af00      	add	r7, sp, #0
    // Start ADC conversion
    ADC->START_CTRL = 0x01; // Start conversion on all enabled channels
 850:	4b02      	ldr	r3, [pc, #8]	@ (85c <ADC_StartConversion+0x10>)
 852:	2201      	movs	r2, #1
 854:	625a      	str	r2, [r3, #36]	@ 0x24
}
 856:	46c0      	nop			@ (mov r8, r8)
 858:	46bd      	mov	sp, r7
 85a:	bd80      	pop	{r7, pc}
 85c:	403a0000 	.word	0x403a0000

00000860 <ADC_ChannelConfig>:

//0  subresolution- 12 bit (0), 8 bit(1), 10 bit(2)
void ADC_ChannelConfig(uint8_t channel, uint8_t subresolution, uint8_t sampleTime, uint8_t PortSelect, uint8_t PinNumber)
{
 860:	b5b0      	push	{r4, r5, r7, lr}
 862:	b084      	sub	sp, #16
 864:	af00      	add	r7, sp, #0
 866:	0005      	movs	r5, r0
 868:	000c      	movs	r4, r1
 86a:	0010      	movs	r0, r2
 86c:	0019      	movs	r1, r3
 86e:	1dfb      	adds	r3, r7, #7
 870:	1c2a      	adds	r2, r5, #0
 872:	701a      	strb	r2, [r3, #0]
 874:	1dbb      	adds	r3, r7, #6
 876:	1c22      	adds	r2, r4, #0
 878:	701a      	strb	r2, [r3, #0]
 87a:	1d7b      	adds	r3, r7, #5
 87c:	1c02      	adds	r2, r0, #0
 87e:	701a      	strb	r2, [r3, #0]
 880:	1d3b      	adds	r3, r7, #4
 882:	1c0a      	adds	r2, r1, #0
 884:	701a      	strb	r2, [r3, #0]
    uint32_t tempreg;

    if(subresolution == 2){
 886:	1dbb      	adds	r3, r7, #6
 888:	781b      	ldrb	r3, [r3, #0]
 88a:	2b02      	cmp	r3, #2
 88c:	d108      	bne.n	8a0 <ADC_ChannelConfig+0x40>
        ADC->SAMPLE_CTRL |= (0x1 << 0);
 88e:	4b1e      	ldr	r3, [pc, #120]	@ (908 <ADC_ChannelConfig+0xa8>)
 890:	685a      	ldr	r2, [r3, #4]
 892:	4b1d      	ldr	r3, [pc, #116]	@ (908 <ADC_ChannelConfig+0xa8>)
 894:	2101      	movs	r1, #1
 896:	430a      	orrs	r2, r1
 898:	605a      	str	r2, [r3, #4]
        subresolution = 1;
 89a:	1dbb      	adds	r3, r7, #6
 89c:	2201      	movs	r2, #1
 89e:	701a      	strb	r2, [r3, #0]
    } 
    tempreg = ADC->CHAN_CONFIG[channel];
 8a0:	4a19      	ldr	r2, [pc, #100]	@ (908 <ADC_ChannelConfig+0xa8>)
 8a2:	1dfb      	adds	r3, r7, #7
 8a4:	781b      	ldrb	r3, [r3, #0]
 8a6:	3320      	adds	r3, #32
 8a8:	009b      	lsls	r3, r3, #2
 8aa:	589b      	ldr	r3, [r3, r2]
 8ac:	60fb      	str	r3, [r7, #12]
    tempreg &= ~ADC_CHANAL_CONFIG_MASK;
 8ae:	68fb      	ldr	r3, [r7, #12]
 8b0:	4a16      	ldr	r2, [pc, #88]	@ (90c <ADC_ChannelConfig+0xac>)
 8b2:	4013      	ands	r3, r2
 8b4:	60fb      	str	r3, [r7, #12]
    tempreg |= (PinNumber & 0x0F) | 
 8b6:	2320      	movs	r3, #32
 8b8:	18fb      	adds	r3, r7, r3
 8ba:	781b      	ldrb	r3, [r3, #0]
 8bc:	220f      	movs	r2, #15
 8be:	401a      	ands	r2, r3
               ((PortSelect & 0x0F) << 4) | 
 8c0:	1d3b      	adds	r3, r7, #4
 8c2:	781b      	ldrb	r3, [r3, #0]
 8c4:	011b      	lsls	r3, r3, #4
 8c6:	21ff      	movs	r1, #255	@ 0xff
 8c8:	400b      	ands	r3, r1
    tempreg |= (PinNumber & 0x0F) | 
 8ca:	431a      	orrs	r2, r3
               ((subresolution & 0x01) << 9) | 
 8cc:	1dbb      	adds	r3, r7, #6
 8ce:	781b      	ldrb	r3, [r3, #0]
 8d0:	0259      	lsls	r1, r3, #9
 8d2:	2380      	movs	r3, #128	@ 0x80
 8d4:	009b      	lsls	r3, r3, #2
 8d6:	400b      	ands	r3, r1
               ((PortSelect & 0x0F) << 4) | 
 8d8:	431a      	orrs	r2, r3
               ((sampleTime & 0x03) << 12);
 8da:	1d7b      	adds	r3, r7, #5
 8dc:	781b      	ldrb	r3, [r3, #0]
 8de:	0319      	lsls	r1, r3, #12
 8e0:	23c0      	movs	r3, #192	@ 0xc0
 8e2:	019b      	lsls	r3, r3, #6
 8e4:	400b      	ands	r3, r1
               ((subresolution & 0x01) << 9) | 
 8e6:	4313      	orrs	r3, r2
 8e8:	001a      	movs	r2, r3
    tempreg |= (PinNumber & 0x0F) | 
 8ea:	68fb      	ldr	r3, [r7, #12]
 8ec:	4313      	orrs	r3, r2
 8ee:	60fb      	str	r3, [r7, #12]
    // Configure the specified channel
    ADC->CHAN_CONFIG[channel] = tempreg;
 8f0:	4905      	ldr	r1, [pc, #20]	@ (908 <ADC_ChannelConfig+0xa8>)
 8f2:	1dfb      	adds	r3, r7, #7
 8f4:	781b      	ldrb	r3, [r3, #0]
 8f6:	3320      	adds	r3, #32
 8f8:	009b      	lsls	r3, r3, #2
 8fa:	68fa      	ldr	r2, [r7, #12]
 8fc:	505a      	str	r2, [r3, r1]

}
 8fe:	46c0      	nop			@ (mov r8, r8)
 900:	46bd      	mov	sp, r7
 902:	b004      	add	sp, #16
 904:	bdb0      	pop	{r4, r5, r7, pc}
 906:	46c0      	nop			@ (mov r8, r8)
 908:	403a0000 	.word	0x403a0000
 90c:	ffffcd88 	.word	0xffffcd88

00000910 <ADC_ChannelEnable>:
//     // Set the ADC resolution
//     ADC->SAMPLE_CTRL = (ADC->SAMPLE_CTRL & ~0x01) | (resolution & 0x01);
// }

void ADC_ChannelEnable(uint8_t channel)
{
 910:	b580      	push	{r7, lr}
 912:	b082      	sub	sp, #8
 914:	af00      	add	r7, sp, #0
 916:	0002      	movs	r2, r0
 918:	1dfb      	adds	r3, r7, #7
 91a:	701a      	strb	r2, [r3, #0]
    // Enable the specified ADC channel
    ADC->CHAN_EN |= (1 << channel);
 91c:	4b07      	ldr	r3, [pc, #28]	@ (93c <ADC_ChannelEnable+0x2c>)
 91e:	6a1a      	ldr	r2, [r3, #32]
 920:	1dfb      	adds	r3, r7, #7
 922:	781b      	ldrb	r3, [r3, #0]
 924:	2101      	movs	r1, #1
 926:	4099      	lsls	r1, r3
 928:	000b      	movs	r3, r1
 92a:	0019      	movs	r1, r3
 92c:	4b03      	ldr	r3, [pc, #12]	@ (93c <ADC_ChannelEnable+0x2c>)
 92e:	430a      	orrs	r2, r1
 930:	621a      	str	r2, [r3, #32]
}
 932:	46c0      	nop			@ (mov r8, r8)
 934:	46bd      	mov	sp, r7
 936:	b002      	add	sp, #8
 938:	bd80      	pop	{r7, pc}
 93a:	46c0      	nop			@ (mov r8, r8)
 93c:	403a0000 	.word	0x403a0000

00000940 <ADC_ChannelDisable>:

void ADC_ChannelDisable(uint8_t channel)
{
 940:	b580      	push	{r7, lr}
 942:	b082      	sub	sp, #8
 944:	af00      	add	r7, sp, #0
 946:	0002      	movs	r2, r0
 948:	1dfb      	adds	r3, r7, #7
 94a:	701a      	strb	r2, [r3, #0]
    // Disable the specified ADC channel
    ADC->CHAN_EN &= ~(1 << channel);
 94c:	4b07      	ldr	r3, [pc, #28]	@ (96c <ADC_ChannelDisable+0x2c>)
 94e:	6a1a      	ldr	r2, [r3, #32]
 950:	1dfb      	adds	r3, r7, #7
 952:	781b      	ldrb	r3, [r3, #0]
 954:	2101      	movs	r1, #1
 956:	4099      	lsls	r1, r3
 958:	000b      	movs	r3, r1
 95a:	43db      	mvns	r3, r3
 95c:	0019      	movs	r1, r3
 95e:	4b03      	ldr	r3, [pc, #12]	@ (96c <ADC_ChannelDisable+0x2c>)
 960:	400a      	ands	r2, r1
 962:	621a      	str	r2, [r3, #32]
 964:	46c0      	nop			@ (mov r8, r8)
 966:	46bd      	mov	sp, r7
 968:	b002      	add	sp, #8
 96a:	bd80      	pop	{r7, pc}
 96c:	403a0000 	.word	0x403a0000

00000970 <_init>:
extern uint32_t __bss_start__;
extern uint32_t __bss_end__;

extern uint32_t __STACK_START;
extern uint32_t __STACK_END;
extern void _init(void) {;}
 970:	b580      	push	{r7, lr}
 972:	af00      	add	r7, sp, #0
 974:	46c0      	nop			@ (mov r8, r8)
 976:	46bd      	mov	sp, r7
 978:	bd80      	pop	{r7, pc}

0000097a <Reset_handler>:
    (uint32_t)can_interrupt_can_IRQHandler,             /*  26 CAN Interrupt */
    (uint32_t)crypto_interrupt_IRQHandler               /*  27 Crypto Interrupt */
};

void Reset_handler(void)
{
 97a:	b580      	push	{r7, lr}
 97c:	b086      	sub	sp, #24
 97e:	af00      	add	r7, sp, #0
    //disable watchdog
    (*(uint32_t *) CYREG_WDT_DISABLE_KEY) = CY_SYS_WDT_KEY;
 980:	4b1c      	ldr	r3, [pc, #112]	@ (9f4 <Reset_handler+0x7a>)
 982:	4a1d      	ldr	r2, [pc, #116]	@ (9f8 <Reset_handler+0x7e>)
 984:	601a      	str	r2, [r3, #0]

    //copy .data section to SRAM
    uint32_t size = &__data_end - &__data_start;
 986:	4a1d      	ldr	r2, [pc, #116]	@ (9fc <Reset_handler+0x82>)
 988:	4b1d      	ldr	r3, [pc, #116]	@ (a00 <Reset_handler+0x86>)
 98a:	1ad3      	subs	r3, r2, r3
 98c:	109b      	asrs	r3, r3, #2
 98e:	607b      	str	r3, [r7, #4]
    uint32_t *pDst = (uint32_t*)&__data_start;
 990:	4b1b      	ldr	r3, [pc, #108]	@ (a00 <Reset_handler+0x86>)
 992:	617b      	str	r3, [r7, #20]
    uint32_t *pSrc = (uint32_t*)&_la_data;
 994:	4b1b      	ldr	r3, [pc, #108]	@ (a04 <Reset_handler+0x8a>)
 996:	613b      	str	r3, [r7, #16]

    for(uint32_t i = 0; i< size; i++)
 998:	2300      	movs	r3, #0
 99a:	60fb      	str	r3, [r7, #12]
 99c:	e00a      	b.n	9b4 <Reset_handler+0x3a>
    {
        *pDst++ = *pSrc++;
 99e:	693a      	ldr	r2, [r7, #16]
 9a0:	1d13      	adds	r3, r2, #4
 9a2:	613b      	str	r3, [r7, #16]
 9a4:	697b      	ldr	r3, [r7, #20]
 9a6:	1d19      	adds	r1, r3, #4
 9a8:	6179      	str	r1, [r7, #20]
 9aa:	6812      	ldr	r2, [r2, #0]
 9ac:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 9ae:	68fb      	ldr	r3, [r7, #12]
 9b0:	3301      	adds	r3, #1
 9b2:	60fb      	str	r3, [r7, #12]
 9b4:	68fa      	ldr	r2, [r7, #12]
 9b6:	687b      	ldr	r3, [r7, #4]
 9b8:	429a      	cmp	r2, r3
 9ba:	d3f0      	bcc.n	99e <Reset_handler+0x24>
    }
    //int the .bss section to zero in SRAM
    size = &__bss_end__ - &__bss_start__;
 9bc:	4a12      	ldr	r2, [pc, #72]	@ (a08 <Reset_handler+0x8e>)
 9be:	4b13      	ldr	r3, [pc, #76]	@ (a0c <Reset_handler+0x92>)
 9c0:	1ad3      	subs	r3, r2, r3
 9c2:	109b      	asrs	r3, r3, #2
 9c4:	607b      	str	r3, [r7, #4]
    pDst = (uint32_t*)&__bss_start__;
 9c6:	4b11      	ldr	r3, [pc, #68]	@ (a0c <Reset_handler+0x92>)
 9c8:	617b      	str	r3, [r7, #20]

    for(uint32_t i = 0; i< size; i++)
 9ca:	2300      	movs	r3, #0
 9cc:	60bb      	str	r3, [r7, #8]
 9ce:	e007      	b.n	9e0 <Reset_handler+0x66>
    {
        *pDst++ = 0;
 9d0:	697b      	ldr	r3, [r7, #20]
 9d2:	1d1a      	adds	r2, r3, #4
 9d4:	617a      	str	r2, [r7, #20]
 9d6:	2200      	movs	r2, #0
 9d8:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 9da:	68bb      	ldr	r3, [r7, #8]
 9dc:	3301      	adds	r3, #1
 9de:	60bb      	str	r3, [r7, #8]
 9e0:	68ba      	ldr	r2, [r7, #8]
 9e2:	687b      	ldr	r3, [r7, #4]
 9e4:	429a      	cmp	r2, r3
 9e6:	d3f3      	bcc.n	9d0 <Reset_handler+0x56>
    }

    // Init C std libs
    __libc_init_array();
 9e8:	f000 f81a 	bl	a20 <__libc_init_array>
    

    //call main()
    main();
 9ec:	f7ff fb68 	bl	c0 <main>

    while (1)
 9f0:	46c0      	nop			@ (mov r8, r8)
 9f2:	e7fd      	b.n	9f0 <Reset_handler+0x76>
 9f4:	40030038 	.word	0x40030038
 9f8:	aced8865 	.word	0xaced8865
 9fc:	20000000 	.word	0x20000000
 a00:	20000000 	.word	0x20000000
 a04:	00000a80 	.word	0x00000a80
 a08:	20000008 	.word	0x20000008
 a0c:	20000000 	.word	0x20000000

00000a10 <Default_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Exceptions / Interrupts
 *----------------------------------------------------------------------------*/
void Default_Handler(void)
{
 a10:	b580      	push	{r7, lr}
 a12:	af00      	add	r7, sp, #0
    while(1);
 a14:	46c0      	nop			@ (mov r8, r8)
 a16:	e7fd      	b.n	a14 <Default_Handler+0x4>

00000a18 <HRDFLT_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Hard Fault
 *----------------------------------------------------------------------------*/
void HRDFLT_Handler(void)
{
 a18:	b580      	push	{r7, lr}
 a1a:	af00      	add	r7, sp, #0
    while(1);
 a1c:	46c0      	nop			@ (mov r8, r8)
 a1e:	e7fd      	b.n	a1c <HRDFLT_Handler+0x4>

00000a20 <__libc_init_array>:
 a20:	b570      	push	{r4, r5, r6, lr}
 a22:	2600      	movs	r6, #0
 a24:	4c0c      	ldr	r4, [pc, #48]	@ (a58 <__libc_init_array+0x38>)
 a26:	4d0d      	ldr	r5, [pc, #52]	@ (a5c <__libc_init_array+0x3c>)
 a28:	1b64      	subs	r4, r4, r5
 a2a:	10a4      	asrs	r4, r4, #2
 a2c:	42a6      	cmp	r6, r4
 a2e:	d109      	bne.n	a44 <__libc_init_array+0x24>
 a30:	2600      	movs	r6, #0
 a32:	f7ff ff9d 	bl	970 <_init>
 a36:	4c0a      	ldr	r4, [pc, #40]	@ (a60 <__libc_init_array+0x40>)
 a38:	4d0a      	ldr	r5, [pc, #40]	@ (a64 <__libc_init_array+0x44>)
 a3a:	1b64      	subs	r4, r4, r5
 a3c:	10a4      	asrs	r4, r4, #2
 a3e:	42a6      	cmp	r6, r4
 a40:	d105      	bne.n	a4e <__libc_init_array+0x2e>
 a42:	bd70      	pop	{r4, r5, r6, pc}
 a44:	00b3      	lsls	r3, r6, #2
 a46:	58eb      	ldr	r3, [r5, r3]
 a48:	4798      	blx	r3
 a4a:	3601      	adds	r6, #1
 a4c:	e7ee      	b.n	a2c <__libc_init_array+0xc>
 a4e:	00b3      	lsls	r3, r6, #2
 a50:	58eb      	ldr	r3, [r5, r3]
 a52:	4798      	blx	r3
 a54:	3601      	adds	r6, #1
 a56:	e7f2      	b.n	a3e <__libc_init_array+0x1e>
	...

00000a68 <LED8_P2_1_config>:
	...

00000a74 <LED8_P1_6_config>:
 a74:	0000 0000 0006 0000 0000 0000               ............
