
bin/BareMetal.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000d24  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  20000000  20000000  00001d24  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  20000000  00000d24  00002000  2**2
                  ALLOC
  3 Heap          00002dfc  20000004  00000d24  00002004  2**0
                  ALLOC
  4 Stack         00000200  20002e00  00000d24  00001e00  2**0
                  ALLOC
  5 .debug_info   000017c4  00000000  00000000  00001d24  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_abbrev 00000775  00000000  00000000  000034e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_aranges 000000c0  00000000  00000000  00003c5d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00000d57  00000000  00000000  00003d1d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    00000cd5  00000000  00000000  00004a74  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000044  00000000  00000000  00005749  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002c  00000000  00000000  0000578d  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000568  00000000  00000000  000057bc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line_str 000000c9  00000000  00000000  00005d24  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <vector>:
   0:	00 40 00 20 03 0b 00 00 99 0b 00 00 a1 0b 00 00     .@. ............
	...
  2c:	99 0b 00 00 00 00 00 00 00 00 00 00 99 0b 00 00     ................
  3c:	99 0b 00 00 99 0b 00 00 99 0b 00 00 99 0b 00 00     ................
  4c:	99 0b 00 00 99 0b 00 00 99 0b 00 00 99 0b 00 00     ................
  5c:	99 0b 00 00 99 0b 00 00 99 0b 00 00 99 0b 00 00     ................
  6c:	99 0b 00 00 99 0b 00 00 99 0b 00 00 99 0b 00 00     ................
  7c:	99 0b 00 00 99 0b 00 00 99 0b 00 00 99 0b 00 00     ................
  8c:	99 0b 00 00 99 0b 00 00 99 0b 00 00 99 0b 00 00     ................
  9c:	99 0b 00 00 99 0b 00 00 99 0b 00 00 99 0b 00 00     ................
  ac:	99 0b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
  bc:	00 00 00 00                                         ....

000000c0 <main>:
};

uint32_t Time_CodeProfile = 0;

int main()
{  
  c0:	b580      	push	{r7, lr}
  c2:	af00      	add	r7, sp, #0
    /* HF CLOCK divider init*/
    Cy_SysClk_ClkHfSetDivider(0u); //0 - No Divider, 1 - DIV by 2, 2 = DIV by 4, 3 = DIV by 8
  c4:	2000      	movs	r0, #0
  c6:	f000 faa5 	bl	614 <Cy_SysClk_ClkHfSetDivider>

    /*GPIO pin init*/
    // *((uint32_t *)0x40040100) = (1 << 4); // Set default output value of P1.4 to 1 in GPIO_PRT1_DR
    // *((uint32_t *)0x40040108) = (6 << 12); // Set drive mode of P1.4 to Digital OP Push Pull in GPIO_PRT1_PC

    GPIO_Pin_Init(1, 6u, &LED8_P1_6_config, HSIOM_SEL_GPIO);
  ca:	4a28      	ldr	r2, [pc, #160]	@ (16c <main+0xac>)
  cc:	2300      	movs	r3, #0
  ce:	2106      	movs	r1, #6
  d0:	2001      	movs	r0, #1
  d2:	f000 f9bf 	bl	454 <GPIO_Pin_Init>
    GPIO_Pin_Init(1, 4u, &LED8_P1_6_config, HSIOM_SEL_GPIO);
  d6:	4a25      	ldr	r2, [pc, #148]	@ (16c <main+0xac>)
  d8:	2300      	movs	r3, #0
  da:	2104      	movs	r1, #4
  dc:	2001      	movs	r0, #1
  de:	f000 f9b9 	bl	454 <GPIO_Pin_Init>

    /* Peripheral clock initializatio*/
    init_peri_Clock_Config();
  e2:	f000 f884 	bl	1ee <init_peri_Clock_Config>

    NVIC_SetPriority(19u, 1u);
  e6:	2101      	movs	r1, #1
  e8:	2013      	movs	r0, #19
  ea:	f000 fc8f 	bl	a0c <NVIC_SetPriority>
    NVIC_ClearPendingIRQ(19u);
  ee:	2013      	movs	r0, #19
  f0:	f000 fcbc 	bl	a6c <NVIC_ClearPendingIRQ>
    NVIC_EnableIRQ(19u);
  f4:	2013      	movs	r0, #19
  f6:	f000 fccf 	bl	a98 <NVIC_EnableIRQ>
	// *((uint32_t *)0xE000E410) = (1 << 30); //Timer 2 IRQn=19 Priority  1 set
	// *((uint32_t *)0xE000E280) = 0xFFFFFFFF; //NVIC Clear Pending IRQs
	// *((uint32_t *)0xE000E100) = (1 << 19); //NVIC_EnableIRQ 19 


	TCPWM_Init(0, (TCPWM_Config_t *)&tcpwm2_config);
  fa:	4b1d      	ldr	r3, [pc, #116]	@ (170 <main+0xb0>)
  fc:	0019      	movs	r1, r3
  fe:	2000      	movs	r0, #0
 100:	f000 fb4a 	bl	798 <TCPWM_Init>
    // *((uint32_t *)0x40200000) |= (1<< 2); //Enable Timer 2  in TCPWM_CTRL Register

    // *((uint32_t *)0x40200008) = (1 << 26); //Triger start Timer 2  in TCPWM_CTRL Register
    /* Enable Interrupts at CPU level */
    // enable_irq();
    IRQ_EnableGlobal();
 104:	f000 fc76 	bl	9f4 <IRQ_EnableGlobal>
    GPIO_Clr(1, 4u);
 108:	2104      	movs	r1, #4
 10a:	2001      	movs	r0, #1
 10c:	f000 f8a8 	bl	260 <GPIO_Clr>
     for(;;)
    {

        /*Code profiling Code - measures the time required for execution */

        TCPWM_SetCounter(0, 0); //Reset the counter value to 0
 110:	2100      	movs	r1, #0
 112:	2000      	movs	r0, #0
 114:	f000 fc30 	bl	978 <TCPWM_SetCounter>
        TCPWM_Start(0); //Start the Timer
 118:	2000      	movs	r0, #0
 11a:	f000 fbd7 	bl	8cc <TCPWM_Start>
        Delay(5000);  //Processing time to be measured
 11e:	4b15      	ldr	r3, [pc, #84]	@ (174 <main+0xb4>)
 120:	0018      	movs	r0, r3
 122:	f000 f82d 	bl	180 <Delay>
        TCPWM_Stop(0); //Stop the Timer
 126:	2000      	movs	r0, #0
 128:	f000 fbec 	bl	904 <TCPWM_Stop>
        Time_CodeProfile = TCPWM_GetCounter(0);
 12c:	2000      	movs	r0, #0
 12e:	f000 fc05 	bl	93c <TCPWM_GetCounter>
 132:	0002      	movs	r2, r0
 134:	4b10      	ldr	r3, [pc, #64]	@ (178 <main+0xb8>)
 136:	601a      	str	r2, [r3, #0]

     //   *((uint32_t *)0x40200008) |= (1<<16); //Trigger stop for Timer0 in TCPWM_CMD REgister 
       	
      //  Time_CodeProfile = *((uint32_t *)0x40200108);
      
        GPIO_Inv(1, 4u);
 138:	2104      	movs	r1, #4
 13a:	2001      	movs	r0, #1
 13c:	f000 f8aa 	bl	294 <GPIO_Inv>
        GPIO_Inv(1, 6u);
 140:	2106      	movs	r1, #6
 142:	2001      	movs	r0, #1
 144:	f000 f8a6 	bl	294 <GPIO_Inv>
        timer_Delay_uS(20000u);
 148:	4b0c      	ldr	r3, [pc, #48]	@ (17c <main+0xbc>)
 14a:	0018      	movs	r0, r3
 14c:	f000 f835 	bl	1ba <timer_Delay_uS>

        GPIO_Inv(1, 4u);
 150:	2104      	movs	r1, #4
 152:	2001      	movs	r0, #1
 154:	f000 f89e 	bl	294 <GPIO_Inv>
        GPIO_Inv(1, 6u);
 158:	2106      	movs	r1, #6
 15a:	2001      	movs	r0, #1
 15c:	f000 f89a 	bl	294 <GPIO_Inv>
        timer_Delay_uS(20000u);
 160:	4b06      	ldr	r3, [pc, #24]	@ (17c <main+0xbc>)
 162:	0018      	movs	r0, r3
 164:	f000 f829 	bl	1ba <timer_Delay_uS>
        TCPWM_SetCounter(0, 0); //Reset the counter value to 0
 168:	46c0      	nop			@ (mov r8, r8)
 16a:	e7d1      	b.n	110 <main+0x50>
 16c:	00000d18 	.word	0x00000d18
 170:	00000d08 	.word	0x00000d08
 174:	00001388 	.word	0x00001388
 178:	20000000 	.word	0x20000000
 17c:	00004e20 	.word	0x00004e20

00000180 <Delay>:
}


/*Delay with simple for loops*/
void Delay(int32_t delayNumber)
{
 180:	b580      	push	{r7, lr}
 182:	b084      	sub	sp, #16
 184:	af00      	add	r7, sp, #0
 186:	6078      	str	r0, [r7, #4]
    for(int32_t i=0; i<delayNumber; i++);
 188:	2300      	movs	r3, #0
 18a:	60fb      	str	r3, [r7, #12]
 18c:	e002      	b.n	194 <Delay+0x14>
 18e:	68fb      	ldr	r3, [r7, #12]
 190:	3301      	adds	r3, #1
 192:	60fb      	str	r3, [r7, #12]
 194:	68fa      	ldr	r2, [r7, #12]
 196:	687b      	ldr	r3, [r7, #4]
 198:	429a      	cmp	r2, r3
 19a:	dbf8      	blt.n	18e <Delay+0xe>
    for(int32_t i=0; i<delayNumber; i++);
 19c:	2300      	movs	r3, #0
 19e:	60bb      	str	r3, [r7, #8]
 1a0:	e002      	b.n	1a8 <Delay+0x28>
 1a2:	68bb      	ldr	r3, [r7, #8]
 1a4:	3301      	adds	r3, #1
 1a6:	60bb      	str	r3, [r7, #8]
 1a8:	68ba      	ldr	r2, [r7, #8]
 1aa:	687b      	ldr	r3, [r7, #4]
 1ac:	429a      	cmp	r2, r3
 1ae:	dbf8      	blt.n	1a2 <Delay+0x22>
}
 1b0:	46c0      	nop			@ (mov r8, r8)
 1b2:	46c0      	nop			@ (mov r8, r8)
 1b4:	46bd      	mov	sp, r7
 1b6:	b004      	add	sp, #16
 1b8:	bd80      	pop	{r7, pc}

000001ba <timer_Delay_uS>:

/*Delay with timer block*/
void timer_Delay_uS(uint32_t delay_uS)
{
 1ba:	b580      	push	{r7, lr}
 1bc:	b082      	sub	sp, #8
 1be:	af00      	add	r7, sp, #0
 1c0:	6078      	str	r0, [r7, #4]
    TCPWM_SetCounter(0, 0); //Reset the counter value to 0
 1c2:	2100      	movs	r1, #0
 1c4:	2000      	movs	r0, #0
 1c6:	f000 fbd7 	bl	978 <TCPWM_SetCounter>
    TCPWM_Start(0); //Start the Timer
 1ca:	2000      	movs	r0, #0
 1cc:	f000 fb7e 	bl	8cc <TCPWM_Start>
    // *((uint32_t *)0x40200108) = 0; //Clear the counter register of  TCPWM0 TCPWM_CNT0_COUNTER Register
    // *((uint32_t *)0x40200008) |= (1<<24); //Trigger start for Timer0 in TCPWM_CMD REgister 
    // while (delay_uS > (*((uint32_t *)0x40200108)));// Keep Checking the TCPWM_CNT0_COUNTER Register 
    while (delay_uS > TCPWM_GetCounter(0)); // Keep Checking the TCPWM_CNT2_COUNTER Register
 1d0:	46c0      	nop			@ (mov r8, r8)
 1d2:	2000      	movs	r0, #0
 1d4:	f000 fbb2 	bl	93c <TCPWM_GetCounter>
 1d8:	0002      	movs	r2, r0
 1da:	687b      	ldr	r3, [r7, #4]
 1dc:	4293      	cmp	r3, r2
 1de:	d8f8      	bhi.n	1d2 <timer_Delay_uS+0x18>
    TCPWM_Stop(0); //Stop the Timer
 1e0:	2000      	movs	r0, #0
 1e2:	f000 fb8f 	bl	904 <TCPWM_Stop>
}
 1e6:	46c0      	nop			@ (mov r8, r8)
 1e8:	46bd      	mov	sp, r7
 1ea:	b002      	add	sp, #8
 1ec:	bd80      	pop	{r7, pc}

000001ee <init_peri_Clock_Config>:
//     /* Toggle the LED */
//     // *((uint32_t *)0x40040148) |= (1<<4); //Toggle the LED on P1.4 by inverting in GPIO_PRT1_DR_INV Register 
// }
/*Peripheral clock initilizations*/
void init_peri_Clock_Config()
{
 1ee:	b580      	push	{r7, lr}
 1f0:	af00      	add	r7, sp, #0
    //TIMER 0 for Code profiling
    *((uint32_t *)0x40010000) = (1<<30); // Disable the Divider using PERI_DIV_CMD 
 1f2:	4b0a      	ldr	r3, [pc, #40]	@ (21c <__HEAP_SIZE+0x1c>)
 1f4:	2280      	movs	r2, #128	@ 0x80
 1f6:	05d2      	lsls	r2, r2, #23
 1f8:	601a      	str	r2, [r3, #0]

    *((uint32_t *)0x40010304) = (24 - 1) << 8 ; //Set the divider value in PERI_DIV_16_CTL1, We are configuring Divider 1 
 1fa:	4b09      	ldr	r3, [pc, #36]	@ (220 <__HEAP_SIZE+0x20>)
 1fc:	22b8      	movs	r2, #184	@ 0xb8
 1fe:	0152      	lsls	r2, r2, #5
 200:	601a      	str	r2, [r3, #0]

    *((uint32_t *)0x40010000) |= (1<<31) |(3<<14) |(63<<8) |(1<<6) | (1 << 0); //PERI_DIV_CMD 
 202:	4b06      	ldr	r3, [pc, #24]	@ (21c <__HEAP_SIZE+0x1c>)
 204:	681a      	ldr	r2, [r3, #0]
 206:	4b05      	ldr	r3, [pc, #20]	@ (21c <__HEAP_SIZE+0x1c>)
 208:	4906      	ldr	r1, [pc, #24]	@ (224 <__HEAP_SIZE+0x24>)
 20a:	430a      	orrs	r2, r1
 20c:	601a      	str	r2, [r3, #0]
    //Enable the divder 31:bit, Keep 3 at 15:14 and 63 13:8 this selects the HFCLK as reference , Select 16 bit divider 7:6, and Select the divider no 1 using 5:0;

    *((uint32_t *)0x40010118) = (1<<6)|(1<<0); // Specify Divider type 7:6 and Selected Divider 3:0 in register PERI_PCLK_CTL6 TCPWM0 is PERIPHERAL 6
 20e:	4b06      	ldr	r3, [pc, #24]	@ (228 <__HEAP_SIZE+0x28>)
 210:	2241      	movs	r2, #65	@ 0x41
 212:	601a      	str	r2, [r3, #0]

 214:	46c0      	nop			@ (mov r8, r8)
 216:	46bd      	mov	sp, r7
 218:	bd80      	pop	{r7, pc}
 21a:	46c0      	nop			@ (mov r8, r8)
 21c:	40010000 	.word	0x40010000
 220:	40010304 	.word	0x40010304
 224:	8000ff41 	.word	0x8000ff41
 228:	40010118 	.word	0x40010118

0000022c <GPIO_Set>:
#include <stdint.h>
#include "gpio.h"

void GPIO_Set(uint8_t portNum, uint32_t pinNum)
{
 22c:	b580      	push	{r7, lr}
 22e:	b084      	sub	sp, #16
 230:	af00      	add	r7, sp, #0
 232:	0002      	movs	r2, r0
 234:	6039      	str	r1, [r7, #0]
 236:	1dfb      	adds	r3, r7, #7
 238:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 23a:	1dfb      	adds	r3, r7, #7
 23c:	781b      	ldrb	r3, [r3, #0]
 23e:	4a07      	ldr	r2, [pc, #28]	@ (25c <GPIO_Set+0x30>)
 240:	4694      	mov	ip, r2
 242:	4463      	add	r3, ip
 244:	021b      	lsls	r3, r3, #8
 246:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_SET(base) = GPIO_DR_MASK << pinNum;
 248:	2201      	movs	r2, #1
 24a:	683b      	ldr	r3, [r7, #0]
 24c:	409a      	lsls	r2, r3
 24e:	68fb      	ldr	r3, [r7, #12]
 250:	641a      	str	r2, [r3, #64]	@ 0x40
}
 252:	46c0      	nop			@ (mov r8, r8)
 254:	46bd      	mov	sp, r7
 256:	b004      	add	sp, #16
 258:	bd80      	pop	{r7, pc}
 25a:	46c0      	nop			@ (mov r8, r8)
 25c:	00400400 	.word	0x00400400

00000260 <GPIO_Clr>:

void GPIO_Clr(uint8_t portNum, uint32_t pinNum)
{
 260:	b580      	push	{r7, lr}
 262:	b084      	sub	sp, #16
 264:	af00      	add	r7, sp, #0
 266:	0002      	movs	r2, r0
 268:	6039      	str	r1, [r7, #0]
 26a:	1dfb      	adds	r3, r7, #7
 26c:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 26e:	1dfb      	adds	r3, r7, #7
 270:	781b      	ldrb	r3, [r3, #0]
 272:	4a07      	ldr	r2, [pc, #28]	@ (290 <GPIO_Clr+0x30>)
 274:	4694      	mov	ip, r2
 276:	4463      	add	r3, ip
 278:	021b      	lsls	r3, r3, #8
 27a:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_CLR(base) = GPIO_DR_MASK << pinNum;
 27c:	2201      	movs	r2, #1
 27e:	683b      	ldr	r3, [r7, #0]
 280:	409a      	lsls	r2, r3
 282:	68fb      	ldr	r3, [r7, #12]
 284:	645a      	str	r2, [r3, #68]	@ 0x44
}
 286:	46c0      	nop			@ (mov r8, r8)
 288:	46bd      	mov	sp, r7
 28a:	b004      	add	sp, #16
 28c:	bd80      	pop	{r7, pc}
 28e:	46c0      	nop			@ (mov r8, r8)
 290:	00400400 	.word	0x00400400

00000294 <GPIO_Inv>:

void GPIO_Inv(uint8_t portNum, uint32_t pinNum)
{
 294:	b580      	push	{r7, lr}
 296:	b084      	sub	sp, #16
 298:	af00      	add	r7, sp, #0
 29a:	0002      	movs	r2, r0
 29c:	6039      	str	r1, [r7, #0]
 29e:	1dfb      	adds	r3, r7, #7
 2a0:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 2a2:	1dfb      	adds	r3, r7, #7
 2a4:	781b      	ldrb	r3, [r3, #0]
 2a6:	4a07      	ldr	r2, [pc, #28]	@ (2c4 <GPIO_Inv+0x30>)
 2a8:	4694      	mov	ip, r2
 2aa:	4463      	add	r3, ip
 2ac:	021b      	lsls	r3, r3, #8
 2ae:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_INV(base) = GPIO_DR_MASK << pinNum;
 2b0:	2201      	movs	r2, #1
 2b2:	683b      	ldr	r3, [r7, #0]
 2b4:	409a      	lsls	r2, r3
 2b6:	68fb      	ldr	r3, [r7, #12]
 2b8:	649a      	str	r2, [r3, #72]	@ 0x48
}
 2ba:	46c0      	nop			@ (mov r8, r8)
 2bc:	46bd      	mov	sp, r7
 2be:	b004      	add	sp, #16
 2c0:	bd80      	pop	{r7, pc}
 2c2:	46c0      	nop			@ (mov r8, r8)
 2c4:	00400400 	.word	0x00400400

000002c8 <GPIO_Read>:

uint32_t GPIO_Read(uint8_t portNum, uint32_t pinNum)
{
 2c8:	b580      	push	{r7, lr}
 2ca:	b084      	sub	sp, #16
 2cc:	af00      	add	r7, sp, #0
 2ce:	0002      	movs	r2, r0
 2d0:	6039      	str	r1, [r7, #0]
 2d2:	1dfb      	adds	r3, r7, #7
 2d4:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 2d6:	1dfb      	adds	r3, r7, #7
 2d8:	781b      	ldrb	r3, [r3, #0]
 2da:	4a08      	ldr	r2, [pc, #32]	@ (2fc <GPIO_Read+0x34>)
 2dc:	4694      	mov	ip, r2
 2de:	4463      	add	r3, ip
 2e0:	021b      	lsls	r3, r3, #8
 2e2:	60fb      	str	r3, [r7, #12]
    return (GPIO_PRT_IN(base) >> (pinNum)) & GPIO_PS_MASK;
 2e4:	68fb      	ldr	r3, [r7, #12]
 2e6:	685a      	ldr	r2, [r3, #4]
 2e8:	683b      	ldr	r3, [r7, #0]
 2ea:	40da      	lsrs	r2, r3
 2ec:	0013      	movs	r3, r2
 2ee:	2201      	movs	r2, #1
 2f0:	4013      	ands	r3, r2
}
 2f2:	0018      	movs	r0, r3
 2f4:	46bd      	mov	sp, r7
 2f6:	b004      	add	sp, #16
 2f8:	bd80      	pop	{r7, pc}
 2fa:	46c0      	nop			@ (mov r8, r8)
 2fc:	00400400 	.word	0x00400400

00000300 <GPIO_SetDrivemode>:

void GPIO_SetDrivemode(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 300:	b580      	push	{r7, lr}
 302:	b088      	sub	sp, #32
 304:	af00      	add	r7, sp, #0
 306:	60b9      	str	r1, [r7, #8]
 308:	607a      	str	r2, [r7, #4]
 30a:	210f      	movs	r1, #15
 30c:	187b      	adds	r3, r7, r1
 30e:	1c02      	adds	r2, r0, #0
 310:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 312:	187b      	adds	r3, r7, r1
 314:	781b      	ldrb	r3, [r3, #0]
 316:	4a19      	ldr	r2, [pc, #100]	@ (37c <GPIO_SetDrivemode+0x7c>)
 318:	4694      	mov	ip, r2
 31a:	4463      	add	r3, ip
 31c:	021b      	lsls	r3, r3, #8
 31e:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum * GPIO_DRIVE_MODE_OFFSET;
 320:	68ba      	ldr	r2, [r7, #8]
 322:	0013      	movs	r3, r2
 324:	005b      	lsls	r3, r3, #1
 326:	189b      	adds	r3, r3, r2
 328:	61bb      	str	r3, [r7, #24]
    tempReg = ((((GPIO_PRT_Type*)(base))->PC) & ~(GPIO_PC_DM_MASK << pinLoc));
 32a:	69fb      	ldr	r3, [r7, #28]
 32c:	689b      	ldr	r3, [r3, #8]
 32e:	2107      	movs	r1, #7
 330:	69ba      	ldr	r2, [r7, #24]
 332:	4091      	lsls	r1, r2
 334:	000a      	movs	r2, r1
 336:	43d2      	mvns	r2, r2
 338:	4013      	ands	r3, r2
 33a:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC) = tempReg | ((value & GPIO_PC_DM_MASK) << pinLoc);
 33c:	687b      	ldr	r3, [r7, #4]
 33e:	2207      	movs	r2, #7
 340:	401a      	ands	r2, r3
 342:	69bb      	ldr	r3, [r7, #24]
 344:	409a      	lsls	r2, r3
 346:	697b      	ldr	r3, [r7, #20]
 348:	431a      	orrs	r2, r3
 34a:	69fb      	ldr	r3, [r7, #28]
 34c:	609a      	str	r2, [r3, #8]

    tempReg = ((((GPIO_PRT_Type*)(base))->PC2) & ~(GPIO_PC_DM_IBUF_MASK << pinNum));
 34e:	69fb      	ldr	r3, [r7, #28]
 350:	699b      	ldr	r3, [r3, #24]
 352:	2101      	movs	r1, #1
 354:	68ba      	ldr	r2, [r7, #8]
 356:	4091      	lsls	r1, r2
 358:	000a      	movs	r2, r1
 35a:	43d2      	mvns	r2, r2
 35c:	4013      	ands	r3, r2
 35e:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC2) = tempReg | (((value & GPIO_DM_VAL_IBUF_DISABLE_MASK) >> GPIO_DRIVE_MODE_OFFSET) << pinNum);
 360:	687b      	ldr	r3, [r7, #4]
 362:	08db      	lsrs	r3, r3, #3
 364:	2201      	movs	r2, #1
 366:	401a      	ands	r2, r3
 368:	68bb      	ldr	r3, [r7, #8]
 36a:	409a      	lsls	r2, r3
 36c:	697b      	ldr	r3, [r7, #20]
 36e:	431a      	orrs	r2, r3
 370:	69fb      	ldr	r3, [r7, #28]
 372:	619a      	str	r2, [r3, #24]
}
 374:	46c0      	nop			@ (mov r8, r8)
 376:	46bd      	mov	sp, r7
 378:	b008      	add	sp, #32
 37a:	bd80      	pop	{r7, pc}
 37c:	00400400 	.word	0x00400400

00000380 <GPIO_SetHSIOM>:


void GPIO_SetHSIOM(uint8_t portNum, uint32_t pinNum, uint8_t value)
{
 380:	b580      	push	{r7, lr}
 382:	b086      	sub	sp, #24
 384:	af00      	add	r7, sp, #0
 386:	6039      	str	r1, [r7, #0]
 388:	0011      	movs	r1, r2
 38a:	1dfb      	adds	r3, r7, #7
 38c:	1c02      	adds	r2, r0, #0
 38e:	701a      	strb	r2, [r3, #0]
 390:	1dbb      	adds	r3, r7, #6
 392:	1c0a      	adds	r2, r1, #0
 394:	701a      	strb	r2, [r3, #0]
    uint32_t HSIOM_portNum;
    uint32_t tempReg;
    HSIOM_PRT_Type* portAddrHSIOM;
    
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 396:	1dfb      	adds	r3, r7, #7
 398:	781b      	ldrb	r3, [r3, #0]
 39a:	4a15      	ldr	r2, [pc, #84]	@ (3f0 <GPIO_SetHSIOM+0x70>)
 39c:	4694      	mov	ip, r2
 39e:	4463      	add	r3, ip
 3a0:	021b      	lsls	r3, r3, #8
 3a2:	617b      	str	r3, [r7, #20]

    HSIOM_portNum = ((uint32_t)(base) - 0x40040000UL) / 0x00000100UL;
 3a4:	697b      	ldr	r3, [r7, #20]
 3a6:	4a13      	ldr	r2, [pc, #76]	@ (3f4 <GPIO_SetHSIOM+0x74>)
 3a8:	4694      	mov	ip, r2
 3aa:	4463      	add	r3, ip
 3ac:	0a1b      	lsrs	r3, r3, #8
 3ae:	613b      	str	r3, [r7, #16]
    portAddrHSIOM = (HSIOM_PRT_Type*)(0x40020000UL + (0x00000100UL * HSIOM_portNum));
 3b0:	693b      	ldr	r3, [r7, #16]
 3b2:	4a11      	ldr	r2, [pc, #68]	@ (3f8 <GPIO_SetHSIOM+0x78>)
 3b4:	4694      	mov	ip, r2
 3b6:	4463      	add	r3, ip
 3b8:	021b      	lsls	r3, r3, #8
 3ba:	60fb      	str	r3, [r7, #12]

    tempReg = (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) & ~(GPIO_HSIOM_MASK << (pinNum << GPIO_HSIOM_OFFSET));
 3bc:	68fb      	ldr	r3, [r7, #12]
 3be:	681b      	ldr	r3, [r3, #0]
 3c0:	683a      	ldr	r2, [r7, #0]
 3c2:	0092      	lsls	r2, r2, #2
 3c4:	210f      	movs	r1, #15
 3c6:	4091      	lsls	r1, r2
 3c8:	000a      	movs	r2, r1
 3ca:	43d2      	mvns	r2, r2
 3cc:	4013      	ands	r3, r2
 3ce:	60bb      	str	r3, [r7, #8]
    (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) = tempReg | (( (uint32_t) value & GPIO_HSIOM_MASK) << (pinNum << GPIO_HSIOM_OFFSET));
 3d0:	1dbb      	adds	r3, r7, #6
 3d2:	781b      	ldrb	r3, [r3, #0]
 3d4:	220f      	movs	r2, #15
 3d6:	401a      	ands	r2, r3
 3d8:	683b      	ldr	r3, [r7, #0]
 3da:	009b      	lsls	r3, r3, #2
 3dc:	409a      	lsls	r2, r3
 3de:	68bb      	ldr	r3, [r7, #8]
 3e0:	431a      	orrs	r2, r3
 3e2:	68fb      	ldr	r3, [r7, #12]
 3e4:	601a      	str	r2, [r3, #0]
}
 3e6:	46c0      	nop			@ (mov r8, r8)
 3e8:	46bd      	mov	sp, r7
 3ea:	b006      	add	sp, #24
 3ec:	bd80      	pop	{r7, pc}
 3ee:	46c0      	nop			@ (mov r8, r8)
 3f0:	00400400 	.word	0x00400400
 3f4:	bffc0000 	.word	0xbffc0000
 3f8:	00400200 	.word	0x00400200

000003fc <GPIO_SetInterruptEdge>:

void GPIO_SetInterruptEdge(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 3fc:	b580      	push	{r7, lr}
 3fe:	b088      	sub	sp, #32
 400:	af00      	add	r7, sp, #0
 402:	60b9      	str	r1, [r7, #8]
 404:	607a      	str	r2, [r7, #4]
 406:	210f      	movs	r1, #15
 408:	187b      	adds	r3, r7, r1
 40a:	1c02      	adds	r2, r0, #0
 40c:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 40e:	187b      	adds	r3, r7, r1
 410:	781b      	ldrb	r3, [r3, #0]
 412:	4a0f      	ldr	r2, [pc, #60]	@ (450 <GPIO_SetInterruptEdge+0x54>)
 414:	4694      	mov	ip, r2
 416:	4463      	add	r3, ip
 418:	021b      	lsls	r3, r3, #8
 41a:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum << 0x1u;
 41c:	68bb      	ldr	r3, [r7, #8]
 41e:	005b      	lsls	r3, r3, #1
 420:	61bb      	str	r3, [r7, #24]
    tempReg = (((GPIO_PRT_Type*)(base))->INTR_CFG) & ~(0x3u << pinLoc);
 422:	69fb      	ldr	r3, [r7, #28]
 424:	68db      	ldr	r3, [r3, #12]
 426:	2103      	movs	r1, #3
 428:	69ba      	ldr	r2, [r7, #24]
 42a:	4091      	lsls	r1, r2
 42c:	000a      	movs	r2, r1
 42e:	43d2      	mvns	r2, r2
 430:	4013      	ands	r3, r2
 432:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->INTR_CFG) = tempReg | ((value & 0x3u) << pinLoc);
 434:	687b      	ldr	r3, [r7, #4]
 436:	2203      	movs	r2, #3
 438:	401a      	ands	r2, r3
 43a:	69bb      	ldr	r3, [r7, #24]
 43c:	409a      	lsls	r2, r3
 43e:	697b      	ldr	r3, [r7, #20]
 440:	431a      	orrs	r2, r3
 442:	69fb      	ldr	r3, [r7, #28]
 444:	60da      	str	r2, [r3, #12]
}
 446:	46c0      	nop			@ (mov r8, r8)
 448:	46bd      	mov	sp, r7
 44a:	b008      	add	sp, #32
 44c:	bd80      	pop	{r7, pc}
 44e:	46c0      	nop			@ (mov r8, r8)
 450:	00400400 	.word	0x00400400

00000454 <GPIO_Pin_Init>:

void GPIO_Pin_Init(uint8_t portNum, uint32_t pinNum, const gpio_pin_config_t *config, uint8_t hsiom)
{
 454:	b590      	push	{r4, r7, lr}
 456:	b085      	sub	sp, #20
 458:	af00      	add	r7, sp, #0
 45a:	60b9      	str	r1, [r7, #8]
 45c:	607a      	str	r2, [r7, #4]
 45e:	0019      	movs	r1, r3
 460:	240f      	movs	r4, #15
 462:	193b      	adds	r3, r7, r4
 464:	1c02      	adds	r2, r0, #0
 466:	701a      	strb	r2, [r3, #0]
 468:	230e      	movs	r3, #14
 46a:	18fb      	adds	r3, r7, r3
 46c:	1c0a      	adds	r2, r1, #0
 46e:	701a      	strb	r2, [r3, #0]
    ((config -> outVal) == 0) ? GPIO_Clr(portNum, pinNum) : GPIO_Set(portNum,pinNum);
 470:	687b      	ldr	r3, [r7, #4]
 472:	681b      	ldr	r3, [r3, #0]
 474:	2b00      	cmp	r3, #0
 476:	d107      	bne.n	488 <GPIO_Pin_Init+0x34>
 478:	68ba      	ldr	r2, [r7, #8]
 47a:	193b      	adds	r3, r7, r4
 47c:	781b      	ldrb	r3, [r3, #0]
 47e:	0011      	movs	r1, r2
 480:	0018      	movs	r0, r3
 482:	f7ff feed 	bl	260 <GPIO_Clr>
 486:	e007      	b.n	498 <GPIO_Pin_Init+0x44>
 488:	68ba      	ldr	r2, [r7, #8]
 48a:	230f      	movs	r3, #15
 48c:	18fb      	adds	r3, r7, r3
 48e:	781b      	ldrb	r3, [r3, #0]
 490:	0011      	movs	r1, r2
 492:	0018      	movs	r0, r3
 494:	f7ff feca 	bl	22c <GPIO_Set>
    GPIO_SetDrivemode(portNum, pinNum, config->driveMode);
 498:	687b      	ldr	r3, [r7, #4]
 49a:	685a      	ldr	r2, [r3, #4]
 49c:	68b9      	ldr	r1, [r7, #8]
 49e:	240f      	movs	r4, #15
 4a0:	193b      	adds	r3, r7, r4
 4a2:	781b      	ldrb	r3, [r3, #0]
 4a4:	0018      	movs	r0, r3
 4a6:	f7ff ff2b 	bl	300 <GPIO_SetDrivemode>
    GPIO_SetHSIOM(portNum, pinNum, hsiom);
 4aa:	230e      	movs	r3, #14
 4ac:	18fb      	adds	r3, r7, r3
 4ae:	781a      	ldrb	r2, [r3, #0]
 4b0:	68b9      	ldr	r1, [r7, #8]
 4b2:	193b      	adds	r3, r7, r4
 4b4:	781b      	ldrb	r3, [r3, #0]
 4b6:	0018      	movs	r0, r3
 4b8:	f7ff ff62 	bl	380 <GPIO_SetHSIOM>
    GPIO_SetInterruptEdge(portNum, pinNum, config->intEdge);
 4bc:	687b      	ldr	r3, [r7, #4]
 4be:	689a      	ldr	r2, [r3, #8]
 4c0:	68b9      	ldr	r1, [r7, #8]
 4c2:	193b      	adds	r3, r7, r4
 4c4:	781b      	ldrb	r3, [r3, #0]
 4c6:	0018      	movs	r0, r3
 4c8:	f7ff ff98 	bl	3fc <GPIO_SetInterruptEdge>
}
 4cc:	46c0      	nop			@ (mov r8, r8)
 4ce:	46bd      	mov	sp, r7
 4d0:	b005      	add	sp, #20
 4d2:	bd90      	pop	{r4, r7, pc}

000004d4 <GPIO_ClearInterrupt>:

void GPIO_ClearInterrupt(uint8_t portNum, uint32_t pinNum)
{
 4d4:	b580      	push	{r7, lr}
 4d6:	b084      	sub	sp, #16
 4d8:	af00      	add	r7, sp, #0
 4da:	0002      	movs	r2, r0
 4dc:	6039      	str	r1, [r7, #0]
 4de:	1dfb      	adds	r3, r7, #7
 4e0:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 4e2:	1dfb      	adds	r3, r7, #7
 4e4:	781b      	ldrb	r3, [r3, #0]
 4e6:	4a09      	ldr	r2, [pc, #36]	@ (50c <GPIO_ClearInterrupt+0x38>)
 4e8:	4694      	mov	ip, r2
 4ea:	4463      	add	r3, ip
 4ec:	021b      	lsls	r3, r3, #8
 4ee:	60fb      	str	r3, [r7, #12]
    /* Any INTR MMIO registers AHB clearing must be preceded with an AHB read access */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 4f0:	68fb      	ldr	r3, [r7, #12]
 4f2:	691b      	ldr	r3, [r3, #16]

    (((GPIO_PRT_Type*)(base))->INTR) = (0x01UL) << pinNum;
 4f4:	2201      	movs	r2, #1
 4f6:	683b      	ldr	r3, [r7, #0]
 4f8:	409a      	lsls	r2, r3
 4fa:	68fb      	ldr	r3, [r7, #12]
 4fc:	611a      	str	r2, [r3, #16]

    /* This read ensures that the initial write has been flushed out to the hardware */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 4fe:	68fb      	ldr	r3, [r7, #12]
 500:	691b      	ldr	r3, [r3, #16]
 502:	46c0      	nop			@ (mov r8, r8)
 504:	46bd      	mov	sp, r7
 506:	b004      	add	sp, #16
 508:	bd80      	pop	{r7, pc}
 50a:	46c0      	nop			@ (mov r8, r8)
 50c:	00400400 	.word	0x00400400

00000510 <SysClk_PeriphDisableDivider>:
#include <stdint.h>
#include "Sys_Clock.h"

void SysClk_PeriphDisableDivider(cy_en_sysclk_divider_types_t dividerType, uint32_t dividerNum)
{
 510:	b580      	push	{r7, lr}
 512:	b082      	sub	sp, #8
 514:	af00      	add	r7, sp, #0
 516:	0002      	movs	r2, r0
 518:	6039      	str	r1, [r7, #0]
 51a:	1dfb      	adds	r3, r7, #7
 51c:	701a      	strb	r2, [r3, #0]
        /* specify the divider and disable it */
        PERI_DIV_CMD = PERI_DIV_CMD_DISABLE_Msk            |
              (((uint32_t)(dividerType) << PERI_DIV_CMD_SEL_TYPE_Pos) & PERI_DIV_CMD_SEL_TYPE_Msk) |
 51e:	1dfb      	adds	r3, r7, #7
 520:	781b      	ldrb	r3, [r3, #0]
 522:	019b      	lsls	r3, r3, #6
 524:	22ff      	movs	r2, #255	@ 0xff
 526:	401a      	ands	r2, r3
              (((uint32_t)(dividerNum) << PERI_DIV_CMD_SEL_DIV_Pos) & PERI_DIV_CMD_SEL_DIV_Msk);
 528:	683b      	ldr	r3, [r7, #0]
 52a:	213f      	movs	r1, #63	@ 0x3f
 52c:	400b      	ands	r3, r1
              (((uint32_t)(dividerType) << PERI_DIV_CMD_SEL_TYPE_Pos) & PERI_DIV_CMD_SEL_TYPE_Msk) |
 52e:	431a      	orrs	r2, r3
        PERI_DIV_CMD = PERI_DIV_CMD_DISABLE_Msk            |
 530:	4b04      	ldr	r3, [pc, #16]	@ (544 <SysClk_PeriphDisableDivider+0x34>)
              (((uint32_t)(dividerType) << PERI_DIV_CMD_SEL_TYPE_Pos) & PERI_DIV_CMD_SEL_TYPE_Msk) |
 532:	2180      	movs	r1, #128	@ 0x80
 534:	05c9      	lsls	r1, r1, #23
 536:	430a      	orrs	r2, r1
        PERI_DIV_CMD = PERI_DIV_CMD_DISABLE_Msk            |
 538:	601a      	str	r2, [r3, #0]
}
 53a:	46c0      	nop			@ (mov r8, r8)
 53c:	46bd      	mov	sp, r7
 53e:	b002      	add	sp, #8
 540:	bd80      	pop	{r7, pc}
 542:	46c0      	nop			@ (mov r8, r8)
 544:	40010000 	.word	0x40010000

00000548 <SysClk_PeriphSetDivider>:

void SysClk_PeriphSetDivider(cy_en_sysclk_divider_types_t dividerType, uint32_t dividerNum, uint32_t dividerValue)
{
 548:	b580      	push	{r7, lr}
 54a:	b084      	sub	sp, #16
 54c:	af00      	add	r7, sp, #0
 54e:	60b9      	str	r1, [r7, #8]
 550:	607a      	str	r2, [r7, #4]
 552:	210f      	movs	r1, #15
 554:	187b      	adds	r3, r7, r1
 556:	1c02      	adds	r2, r0, #0
 558:	701a      	strb	r2, [r3, #0]
        dividerType = dividerType;
 55a:	187b      	adds	r3, r7, r1
 55c:	187a      	adds	r2, r7, r1
 55e:	7812      	ldrb	r2, [r2, #0]
 560:	701a      	strb	r2, [r3, #0]
        PERI_DIV_16_CTL[dividerNum] =  ((((PERI_DIV_16_CTL[dividerNum])) & 
 562:	4a0a      	ldr	r2, [pc, #40]	@ (58c <SysClk_PeriphSetDivider+0x44>)
 564:	68bb      	ldr	r3, [r7, #8]
 566:	33c0      	adds	r3, #192	@ 0xc0
 568:	009b      	lsls	r3, r3, #2
 56a:	589b      	ldr	r3, [r3, r2]
 56c:	4a08      	ldr	r2, [pc, #32]	@ (590 <SysClk_PeriphSetDivider+0x48>)
 56e:	401a      	ands	r2, r3
                                        ((uint32_t)(~(PERI_DIV_16_CTL_INT16_DIV_Msk)))) | 
                                        ((((uint32_t)(dividerValue) << PERI_DIV_16_CTL_INT16_DIV_Pos) & 
 570:	687b      	ldr	r3, [r7, #4]
 572:	021b      	lsls	r3, r3, #8
 574:	4907      	ldr	r1, [pc, #28]	@ (594 <SysClk_PeriphSetDivider+0x4c>)
 576:	400b      	ands	r3, r1
        PERI_DIV_16_CTL[dividerNum] =  ((((PERI_DIV_16_CTL[dividerNum])) & 
 578:	4904      	ldr	r1, [pc, #16]	@ (58c <SysClk_PeriphSetDivider+0x44>)
                                        ((uint32_t)(~(PERI_DIV_16_CTL_INT16_DIV_Msk)))) | 
 57a:	431a      	orrs	r2, r3
        PERI_DIV_16_CTL[dividerNum] =  ((((PERI_DIV_16_CTL[dividerNum])) & 
 57c:	68bb      	ldr	r3, [r7, #8]
 57e:	33c0      	adds	r3, #192	@ 0xc0
 580:	009b      	lsls	r3, r3, #2
 582:	505a      	str	r2, [r3, r1]
                                        PERI_DIV_16_CTL_INT16_DIV_Msk)));

}
 584:	46c0      	nop			@ (mov r8, r8)
 586:	46bd      	mov	sp, r7
 588:	b004      	add	sp, #16
 58a:	bd80      	pop	{r7, pc}
 58c:	40010000 	.word	0x40010000
 590:	ff0000ff 	.word	0xff0000ff
 594:	00ffff00 	.word	0x00ffff00

00000598 <SysClk_PeriphEnableDivider>:

void SysClk_PeriphEnableDivider(cy_en_sysclk_divider_types_t dividerType, uint32_t dividerNum)
{
 598:	b580      	push	{r7, lr}
 59a:	b082      	sub	sp, #8
 59c:	af00      	add	r7, sp, #0
 59e:	0002      	movs	r2, r0
 5a0:	6039      	str	r1, [r7, #0]
 5a2:	1dfb      	adds	r3, r7, #7
 5a4:	701a      	strb	r2, [r3, #0]
        /* specify the divider, make the reference = clk_peri, and enable the divider */
        PERI_DIV_CMD = PERI_DIV_CMD_ENABLE_Msk             |
                       PERI_DIV_CMD_PA_SEL_TYPE_Msk        |
                       PERI_DIV_CMD_PA_SEL_DIV_Msk         |
              (((uint32_t)(dividerType) << PERI_DIV_CMD_SEL_TYPE_Pos) & PERI_DIV_CMD_SEL_TYPE_Msk) |
 5a6:	1dfb      	adds	r3, r7, #7
 5a8:	781b      	ldrb	r3, [r3, #0]
 5aa:	019b      	lsls	r3, r3, #6
 5ac:	22ff      	movs	r2, #255	@ 0xff
 5ae:	401a      	ands	r2, r3
              (((uint32_t)(dividerNum) << PERI_DIV_CMD_SEL_DIV_Pos) & PERI_DIV_CMD_SEL_DIV_Msk);
 5b0:	683b      	ldr	r3, [r7, #0]
 5b2:	213f      	movs	r1, #63	@ 0x3f
 5b4:	400b      	ands	r3, r1
              (((uint32_t)(dividerType) << PERI_DIV_CMD_SEL_TYPE_Pos) & PERI_DIV_CMD_SEL_TYPE_Msk) |
 5b6:	431a      	orrs	r2, r3
        PERI_DIV_CMD = PERI_DIV_CMD_ENABLE_Msk             |
 5b8:	4b04      	ldr	r3, [pc, #16]	@ (5cc <SysClk_PeriphEnableDivider+0x34>)
              (((uint32_t)(dividerType) << PERI_DIV_CMD_SEL_TYPE_Pos) & PERI_DIV_CMD_SEL_TYPE_Msk) |
 5ba:	4905      	ldr	r1, [pc, #20]	@ (5d0 <SysClk_PeriphEnableDivider+0x38>)
 5bc:	430a      	orrs	r2, r1
        PERI_DIV_CMD = PERI_DIV_CMD_ENABLE_Msk             |
 5be:	601a      	str	r2, [r3, #0]
        
        (void)PERI_DIV_CMD; /* dummy read to handle buffered writes */
 5c0:	4b02      	ldr	r3, [pc, #8]	@ (5cc <SysClk_PeriphEnableDivider+0x34>)
 5c2:	681b      	ldr	r3, [r3, #0]
}
 5c4:	46c0      	nop			@ (mov r8, r8)
 5c6:	46bd      	mov	sp, r7
 5c8:	b002      	add	sp, #8
 5ca:	bd80      	pop	{r7, pc}
 5cc:	40010000 	.word	0x40010000
 5d0:	8000ff00 	.word	0x8000ff00

000005d4 <SysClk_PeriphAssignDivider>:

void SysClk_PeriphAssignDivider(en_clk_dst_t periphNum, cy_en_sysclk_divider_types_t dividerType, uint32_t dividerNum)
{
 5d4:	b580      	push	{r7, lr}
 5d6:	b082      	sub	sp, #8
 5d8:	af00      	add	r7, sp, #0
 5da:	603a      	str	r2, [r7, #0]
 5dc:	1dfb      	adds	r3, r7, #7
 5de:	1c02      	adds	r2, r0, #0
 5e0:	701a      	strb	r2, [r3, #0]
 5e2:	1dbb      	adds	r3, r7, #6
 5e4:	1c0a      	adds	r2, r1, #0
 5e6:	701a      	strb	r2, [r3, #0]

        PERI_PCLK_CTL[periphNum] = (((uint32_t)(dividerType) << PERI_PCLK_CTL_SEL_TYPE_Pos) & PERI_PCLK_CTL_SEL_TYPE_Msk) | (((uint32_t)(dividerNum) << PERI_PCLK_CTL_SEL_DIV_Pos) & PERI_PCLK_CTL_SEL_DIV_Msk);
 5e8:	1dbb      	adds	r3, r7, #6
 5ea:	781b      	ldrb	r3, [r3, #0]
 5ec:	019b      	lsls	r3, r3, #6
 5ee:	22ff      	movs	r2, #255	@ 0xff
 5f0:	4013      	ands	r3, r2
 5f2:	0019      	movs	r1, r3
 5f4:	683b      	ldr	r3, [r7, #0]
 5f6:	223f      	movs	r2, #63	@ 0x3f
 5f8:	401a      	ands	r2, r3
 5fa:	4805      	ldr	r0, [pc, #20]	@ (610 <SysClk_PeriphAssignDivider+0x3c>)
 5fc:	1dfb      	adds	r3, r7, #7
 5fe:	781b      	ldrb	r3, [r3, #0]
 600:	430a      	orrs	r2, r1
 602:	3340      	adds	r3, #64	@ 0x40
 604:	009b      	lsls	r3, r3, #2
 606:	501a      	str	r2, [r3, r0]
}
 608:	46c0      	nop			@ (mov r8, r8)
 60a:	46bd      	mov	sp, r7
 60c:	b002      	add	sp, #8
 60e:	bd80      	pop	{r7, pc}
 610:	40010000 	.word	0x40010000

00000614 <Cy_SysClk_ClkHfSetDivider>:

void Cy_SysClk_ClkHfSetDivider(uint8_t divider)
{
 614:	b580      	push	{r7, lr}
 616:	b082      	sub	sp, #8
 618:	af00      	add	r7, sp, #0
 61a:	0002      	movs	r2, r0
 61c:	1dfb      	adds	r3, r7, #7
 61e:	701a      	strb	r2, [r3, #0]
        CY_REG32_CLR_SET(SRSSLT_CLK_SELECT, SRSSLT_CLK_SELECT_HFCLK_DIV, divider);
 620:	4b08      	ldr	r3, [pc, #32]	@ (644 <Cy_SysClk_ClkHfSetDivider+0x30>)
 622:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 624:	220c      	movs	r2, #12
 626:	4393      	bics	r3, r2
 628:	0019      	movs	r1, r3
 62a:	1dfb      	adds	r3, r7, #7
 62c:	781b      	ldrb	r3, [r3, #0]
 62e:	009b      	lsls	r3, r3, #2
 630:	220c      	movs	r2, #12
 632:	401a      	ands	r2, r3
 634:	4b03      	ldr	r3, [pc, #12]	@ (644 <Cy_SysClk_ClkHfSetDivider+0x30>)
 636:	430a      	orrs	r2, r1
 638:	629a      	str	r2, [r3, #40]	@ 0x28
}
 63a:	46c0      	nop			@ (mov r8, r8)
 63c:	46bd      	mov	sp, r7
 63e:	b002      	add	sp, #8
 640:	bd80      	pop	{r7, pc}
 642:	46c0      	nop			@ (mov r8, r8)
 644:	40030000 	.word	0x40030000

00000648 <Cy_SysClk_ImoEnable>:

void Cy_SysClk_ImoEnable(void)
{
 648:	b580      	push	{r7, lr}
 64a:	af00      	add	r7, sp, #0
   SRSSLT_CLK_IMO_CONFIG = SRSSLT_CLK_IMO_CONFIG_ENABLE_Msk;
 64c:	4b03      	ldr	r3, [pc, #12]	@ (65c <Cy_SysClk_ImoEnable+0x14>)
 64e:	2280      	movs	r2, #128	@ 0x80
 650:	0612      	lsls	r2, r2, #24
 652:	631a      	str	r2, [r3, #48]	@ 0x30
}
 654:	46c0      	nop			@ (mov r8, r8)
 656:	46bd      	mov	sp, r7
 658:	bd80      	pop	{r7, pc}
 65a:	46c0      	nop			@ (mov r8, r8)
 65c:	40030000 	.word	0x40030000

00000660 <Cy_SysClk_ImoGetFrequency>:

uint32_t Cy_SysClk_ImoGetFrequency(void)
{
 660:	b580      	push	{r7, lr}
 662:	af00      	add	r7, sp, #0
    return ((((((uint32_t)(SRSSLT_CLK_IMO_SELECT) & SRSSLT_CLK_IMO_SELECT_FREQ_Msk) >> SRSSLT_CLK_IMO_SELECT_FREQ_Pos) << 2UL) * 1000000UL) + (uint32_t)24000000UL);
 664:	4a0a      	ldr	r2, [pc, #40]	@ (690 <Cy_SysClk_ImoGetFrequency+0x30>)
 666:	4b0b      	ldr	r3, [pc, #44]	@ (694 <Cy_SysClk_ImoGetFrequency+0x34>)
 668:	58d3      	ldr	r3, [r2, r3]
 66a:	009b      	lsls	r3, r3, #2
 66c:	221c      	movs	r2, #28
 66e:	4013      	ands	r3, r2
 670:	0019      	movs	r1, r3
 672:	000a      	movs	r2, r1
 674:	0152      	lsls	r2, r2, #5
 676:	1a52      	subs	r2, r2, r1
 678:	0193      	lsls	r3, r2, #6
 67a:	1a9b      	subs	r3, r3, r2
 67c:	00db      	lsls	r3, r3, #3
 67e:	185b      	adds	r3, r3, r1
 680:	019b      	lsls	r3, r3, #6
 682:	4a05      	ldr	r2, [pc, #20]	@ (698 <Cy_SysClk_ImoGetFrequency+0x38>)
 684:	4694      	mov	ip, r2
 686:	4463      	add	r3, ip
}
 688:	0018      	movs	r0, r3
 68a:	46bd      	mov	sp, r7
 68c:	bd80      	pop	{r7, pc}
 68e:	46c0      	nop			@ (mov r8, r8)
 690:	40030000 	.word	0x40030000
 694:	00000f08 	.word	0x00000f08
 698:	016e3600 	.word	0x016e3600

0000069c <Cy_SysClk_ImoSetFrequency>:

void Cy_SysClk_ImoSetFrequency(cy_en_sysclk_imo_freq_t freq)
{
 69c:	b580      	push	{r7, lr}
 69e:	b086      	sub	sp, #24
 6a0:	af00      	add	r7, sp, #0
 6a2:	6078      	str	r0, [r7, #4]

        if ((uint32_t) freq != Cy_SysClk_ImoGetFrequency())
 6a4:	f7ff ffdc 	bl	660 <Cy_SysClk_ImoGetFrequency>
 6a8:	0002      	movs	r2, r0
 6aa:	687b      	ldr	r3, [r7, #4]
 6ac:	4293      	cmp	r3, r2
 6ae:	d05f      	beq.n	770 <Cy_SysClk_ImoSetFrequency+0xd4>
        {
        /* Convert the frequency value in Hz into the SFLASH.IMO_TRIM register index */
        uint32_t locFreq = ((uint32_t)freq - (uint32_t)24000000UL) / 1000000UL;
 6b0:	687b      	ldr	r3, [r7, #4]
 6b2:	4a31      	ldr	r2, [pc, #196]	@ (778 <Cy_SysClk_ImoSetFrequency+0xdc>)
 6b4:	4694      	mov	ip, r2
 6b6:	4463      	add	r3, ip
 6b8:	4930      	ldr	r1, [pc, #192]	@ (77c <Cy_SysClk_ImoSetFrequency+0xe0>)
 6ba:	0018      	movs	r0, r3
 6bc:	f000 fa74 	bl	ba8 <__udivsi3>
 6c0:	0003      	movs	r3, r0
 6c2:	60fb      	str	r3, [r7, #12]

        /* Set IMO to 24 MHz */
        SRSSLT_CLK_IMO_SELECT = 0UL;
 6c4:	4a2e      	ldr	r2, [pc, #184]	@ (780 <Cy_SysClk_ImoSetFrequency+0xe4>)
 6c6:	4b2f      	ldr	r3, [pc, #188]	@ (784 <Cy_SysClk_ImoSetFrequency+0xe8>)
 6c8:	2100      	movs	r1, #0
 6ca:	50d1      	str	r1, [r2, r3]

        /* Apply coarse trim */
        SRSSLT_CLK_IMO_TRIM1 = SFLASH_IMO_TRIM_LT(locFreq);
 6cc:	492e      	ldr	r1, [pc, #184]	@ (788 <Cy_SysClk_ImoSetFrequency+0xec>)
 6ce:	23e6      	movs	r3, #230	@ 0xe6
 6d0:	33ff      	adds	r3, #255	@ 0xff
 6d2:	68fa      	ldr	r2, [r7, #12]
 6d4:	188a      	adds	r2, r1, r2
 6d6:	18d3      	adds	r3, r2, r3
 6d8:	781b      	ldrb	r3, [r3, #0]
 6da:	b2db      	uxtb	r3, r3
 6dc:	4a28      	ldr	r2, [pc, #160]	@ (780 <Cy_SysClk_ImoSetFrequency+0xe4>)
 6de:	0019      	movs	r1, r3
 6e0:	4b2a      	ldr	r3, [pc, #168]	@ (78c <Cy_SysClk_ImoSetFrequency+0xf0>)
 6e2:	50d1      	str	r1, [r2, r3]

        /* Zero out fine trim */
        SRSSLT_CLK_IMO_TRIM2 = 0UL;
 6e4:	4a26      	ldr	r2, [pc, #152]	@ (780 <Cy_SysClk_ImoSetFrequency+0xe4>)
 6e6:	23f1      	movs	r3, #241	@ 0xf1
 6e8:	011b      	lsls	r3, r3, #4
 6ea:	2100      	movs	r1, #0
 6ec:	50d1      	str	r1, [r2, r3]

        /* Apply TC trim */
        SRSSLT_CLK_IMO_TRIM3 = SFLASH_IMO_TCTRIM_LT(locFreq);
 6ee:	4926      	ldr	r1, [pc, #152]	@ (788 <Cy_SysClk_ImoSetFrequency+0xec>)
 6f0:	23e6      	movs	r3, #230	@ 0xe6
 6f2:	005b      	lsls	r3, r3, #1
 6f4:	68fa      	ldr	r2, [r7, #12]
 6f6:	188a      	adds	r2, r1, r2
 6f8:	18d3      	adds	r3, r2, r3
 6fa:	781b      	ldrb	r3, [r3, #0]
 6fc:	b2db      	uxtb	r3, r3
 6fe:	4a20      	ldr	r2, [pc, #128]	@ (780 <Cy_SysClk_ImoSetFrequency+0xe4>)
 700:	0019      	movs	r1, r3
 702:	4b23      	ldr	r3, [pc, #140]	@ (790 <Cy_SysClk_ImoSetFrequency+0xf4>)
 704:	50d1      	str	r1, [r2, r3]

        /* Convert the SFLASH.IMO_TRIM register index into the frequency bitfield value */
        locFreq >>= 2UL;
 706:	68fb      	ldr	r3, [r7, #12]
 708:	089b      	lsrs	r3, r3, #2
 70a:	60fb      	str	r3, [r7, #12]

        for(int i=0; i<50000; i++); //short delay
 70c:	2300      	movs	r3, #0
 70e:	617b      	str	r3, [r7, #20]
 710:	e002      	b.n	718 <Cy_SysClk_ImoSetFrequency+0x7c>
 712:	697b      	ldr	r3, [r7, #20]
 714:	3301      	adds	r3, #1
 716:	617b      	str	r3, [r7, #20]
 718:	697b      	ldr	r3, [r7, #20]
 71a:	4a1e      	ldr	r2, [pc, #120]	@ (794 <Cy_SysClk_ImoSetFrequency+0xf8>)
 71c:	4293      	cmp	r3, r2
 71e:	ddf8      	ble.n	712 <Cy_SysClk_ImoSetFrequency+0x76>

        if (0UL != locFreq)
 720:	68fb      	ldr	r3, [r7, #12]
 722:	2b00      	cmp	r3, #0
 724:	d024      	beq.n	770 <Cy_SysClk_ImoSetFrequency+0xd4>
        {
                /* Select nearby intermediate frequency */
                CY_REG32_CLR_SET(SRSSLT_CLK_IMO_SELECT, SRSSLT_CLK_IMO_SELECT_FREQ, locFreq - 1UL);
 726:	4a16      	ldr	r2, [pc, #88]	@ (780 <Cy_SysClk_ImoSetFrequency+0xe4>)
 728:	4b16      	ldr	r3, [pc, #88]	@ (784 <Cy_SysClk_ImoSetFrequency+0xe8>)
 72a:	58d3      	ldr	r3, [r2, r3]
 72c:	2207      	movs	r2, #7
 72e:	4393      	bics	r3, r2
 730:	001a      	movs	r2, r3
 732:	68fb      	ldr	r3, [r7, #12]
 734:	3b01      	subs	r3, #1
 736:	2107      	movs	r1, #7
 738:	400b      	ands	r3, r1
 73a:	4911      	ldr	r1, [pc, #68]	@ (780 <Cy_SysClk_ImoSetFrequency+0xe4>)
 73c:	4313      	orrs	r3, r2
 73e:	4a11      	ldr	r2, [pc, #68]	@ (784 <Cy_SysClk_ImoSetFrequency+0xe8>)
 740:	508b      	str	r3, [r1, r2]
                for(int i=0; i<50000; i++); //short delay
 742:	2300      	movs	r3, #0
 744:	613b      	str	r3, [r7, #16]
 746:	e002      	b.n	74e <Cy_SysClk_ImoSetFrequency+0xb2>
 748:	693b      	ldr	r3, [r7, #16]
 74a:	3301      	adds	r3, #1
 74c:	613b      	str	r3, [r7, #16]
 74e:	693b      	ldr	r3, [r7, #16]
 750:	4a10      	ldr	r2, [pc, #64]	@ (794 <Cy_SysClk_ImoSetFrequency+0xf8>)
 752:	4293      	cmp	r3, r2
 754:	ddf8      	ble.n	748 <Cy_SysClk_ImoSetFrequency+0xac>
                CY_REG32_CLR_SET(SRSSLT_CLK_IMO_SELECT, SRSSLT_CLK_IMO_SELECT_FREQ, locFreq);
 756:	4a0a      	ldr	r2, [pc, #40]	@ (780 <Cy_SysClk_ImoSetFrequency+0xe4>)
 758:	4b0a      	ldr	r3, [pc, #40]	@ (784 <Cy_SysClk_ImoSetFrequency+0xe8>)
 75a:	58d3      	ldr	r3, [r2, r3]
 75c:	2207      	movs	r2, #7
 75e:	4393      	bics	r3, r2
 760:	001a      	movs	r2, r3
 762:	68fb      	ldr	r3, [r7, #12]
 764:	2107      	movs	r1, #7
 766:	400b      	ands	r3, r1
 768:	4905      	ldr	r1, [pc, #20]	@ (780 <Cy_SysClk_ImoSetFrequency+0xe4>)
 76a:	4313      	orrs	r3, r2
 76c:	4a05      	ldr	r2, [pc, #20]	@ (784 <Cy_SysClk_ImoSetFrequency+0xe8>)
 76e:	508b      	str	r3, [r1, r2]
        }
        }

 770:	46c0      	nop			@ (mov r8, r8)
 772:	46bd      	mov	sp, r7
 774:	b006      	add	sp, #24
 776:	bd80      	pop	{r7, pc}
 778:	fe91ca00 	.word	0xfe91ca00
 77c:	000f4240 	.word	0x000f4240
 780:	40030000 	.word	0x40030000
 784:	00000f08 	.word	0x00000f08
 788:	0ffff000 	.word	0x0ffff000
 78c:	00000f0c 	.word	0x00000f0c
 790:	00000f18 	.word	0x00000f18
 794:	0000c34f 	.word	0x0000c34f

00000798 <TCPWM_Init>:
#include <stdint.h>
#include "tcpwm.h"

void TCPWM_Init(uint8_t tcpwm_Num, TCPWM_Config_t *config)
{
 798:	b580      	push	{r7, lr}
 79a:	b084      	sub	sp, #16
 79c:	af00      	add	r7, sp, #0
 79e:	0002      	movs	r2, r0
 7a0:	6039      	str	r1, [r7, #0]
 7a2:	1dfb      	adds	r3, r7, #7
 7a4:	701a      	strb	r2, [r3, #0]
    uint32_t mask;
    if(tcpwm_Num > 7){
 7a6:	1dfb      	adds	r3, r7, #7
 7a8:	781b      	ldrb	r3, [r3, #0]
 7aa:	2b07      	cmp	r3, #7
 7ac:	d84e      	bhi.n	84c <TCPWM_Init+0xb4>
        return;
    }
    TCPWM_CNT_Type* tcpwm;
    tcpwm = GET_TCPWM_NUM(tcpwm_Num);
 7ae:	1dfb      	adds	r3, r7, #7
 7b0:	781b      	ldrb	r3, [r3, #0]
 7b2:	019b      	lsls	r3, r3, #6
 7b4:	4a27      	ldr	r2, [pc, #156]	@ (854 <TCPWM_Init+0xbc>)
 7b6:	4694      	mov	ip, r2
 7b8:	4463      	add	r3, ip
 7ba:	60fb      	str	r3, [r7, #12]
    
    TCPWM_Disable(tcpwm_Num);
 7bc:	1dfb      	adds	r3, r7, #7
 7be:	781b      	ldrb	r3, [r3, #0]
 7c0:	0018      	movs	r0, r3
 7c2:	f000 f867 	bl	894 <TCPWM_Disable>
    TCPWM_SetCounter(tcpwm_Num, 0u);
 7c6:	1dfb      	adds	r3, r7, #7
 7c8:	781b      	ldrb	r3, [r3, #0]
 7ca:	2100      	movs	r1, #0
 7cc:	0018      	movs	r0, r3
 7ce:	f000 f8d3 	bl	978 <TCPWM_SetCounter>
    
    mask = (0x7u << 24u) | (0x7u << 8u);
 7d2:	4b21      	ldr	r3, [pc, #132]	@ (858 <TCPWM_Init+0xc0>)
 7d4:	60bb      	str	r3, [r7, #8]
    tcpwm->CTRL = (tcpwm->CTRL & ~mask) | ((config->mode & 0x07u) << 24u) | ((config->prescaler & 0x07u) << 8u);
 7d6:	68fb      	ldr	r3, [r7, #12]
 7d8:	681b      	ldr	r3, [r3, #0]
 7da:	68ba      	ldr	r2, [r7, #8]
 7dc:	43d2      	mvns	r2, r2
 7de:	401a      	ands	r2, r3
 7e0:	683b      	ldr	r3, [r7, #0]
 7e2:	781b      	ldrb	r3, [r3, #0]
 7e4:	0619      	lsls	r1, r3, #24
 7e6:	23e0      	movs	r3, #224	@ 0xe0
 7e8:	04db      	lsls	r3, r3, #19
 7ea:	400b      	ands	r3, r1
 7ec:	431a      	orrs	r2, r3
 7ee:	683b      	ldr	r3, [r7, #0]
 7f0:	7b5b      	ldrb	r3, [r3, #13]
 7f2:	0219      	lsls	r1, r3, #8
 7f4:	23e0      	movs	r3, #224	@ 0xe0
 7f6:	00db      	lsls	r3, r3, #3
 7f8:	400b      	ands	r3, r1
 7fa:	431a      	orrs	r2, r3
 7fc:	68fb      	ldr	r3, [r7, #12]
 7fe:	601a      	str	r2, [r3, #0]
    if(config->mode == 4u){
 800:	683b      	ldr	r3, [r7, #0]
 802:	781b      	ldrb	r3, [r3, #0]
 804:	2b04      	cmp	r3, #4
 806:	d102      	bne.n	80e <TCPWM_Init+0x76>
        tcpwm->TR_CTRL2 = 0x31; 
 808:	68fb      	ldr	r3, [r7, #12]
 80a:	2231      	movs	r2, #49	@ 0x31
 80c:	629a      	str	r2, [r3, #40]	@ 0x28
    }
    tcpwm->PERIOD = config->period - 1u;
 80e:	683b      	ldr	r3, [r7, #0]
 810:	685b      	ldr	r3, [r3, #4]
 812:	1e5a      	subs	r2, r3, #1
 814:	68fb      	ldr	r3, [r7, #12]
 816:	615a      	str	r2, [r3, #20]
    if (config->compare == 0u) {
 818:	683b      	ldr	r3, [r7, #0]
 81a:	689b      	ldr	r3, [r3, #8]
 81c:	2b00      	cmp	r3, #0
 81e:	d103      	bne.n	828 <TCPWM_Init+0x90>
        tcpwm->CC = 0xFFFFu;
 820:	68fb      	ldr	r3, [r7, #12]
 822:	4a0e      	ldr	r2, [pc, #56]	@ (85c <TCPWM_Init+0xc4>)
 824:	60da      	str	r2, [r3, #12]
 826:	e004      	b.n	832 <TCPWM_Init+0x9a>
    } else {
        tcpwm->CC = config->compare - 1u;
 828:	683b      	ldr	r3, [r7, #0]
 82a:	689b      	ldr	r3, [r3, #8]
 82c:	1e5a      	subs	r2, r3, #1
 82e:	68fb      	ldr	r3, [r7, #12]
 830:	60da      	str	r2, [r3, #12]
    }
    tcpwm->INTR_MASK = config->intrMask & 0x03;
 832:	683b      	ldr	r3, [r7, #0]
 834:	7b1b      	ldrb	r3, [r3, #12]
 836:	001a      	movs	r2, r3
 838:	2303      	movs	r3, #3
 83a:	401a      	ands	r2, r3
 83c:	68fb      	ldr	r3, [r7, #12]
 83e:	639a      	str	r2, [r3, #56]	@ 0x38
    TCPWM_Enable(tcpwm_Num);
 840:	1dfb      	adds	r3, r7, #7
 842:	781b      	ldrb	r3, [r3, #0]
 844:	0018      	movs	r0, r3
 846:	f000 f80b 	bl	860 <TCPWM_Enable>
 84a:	e000      	b.n	84e <TCPWM_Init+0xb6>
        return;
 84c:	46c0      	nop			@ (mov r8, r8)
}
 84e:	46bd      	mov	sp, r7
 850:	b004      	add	sp, #16
 852:	bd80      	pop	{r7, pc}
 854:	40200100 	.word	0x40200100
 858:	07000700 	.word	0x07000700
 85c:	0000ffff 	.word	0x0000ffff

00000860 <TCPWM_Enable>:

void TCPWM_Enable(uint8_t tcpwm_Num)
{
 860:	b580      	push	{r7, lr}
 862:	b082      	sub	sp, #8
 864:	af00      	add	r7, sp, #0
 866:	0002      	movs	r2, r0
 868:	1dfb      	adds	r3, r7, #7
 86a:	701a      	strb	r2, [r3, #0]
    if(tcpwm_Num > 7){
 86c:	1dfb      	adds	r3, r7, #7
 86e:	781b      	ldrb	r3, [r3, #0]
 870:	2b07      	cmp	r3, #7
 872:	d809      	bhi.n	888 <TCPWM_Enable+0x28>
        return;
    }
    TCPWM->CTRL |= (1u << tcpwm_Num);
 874:	4b06      	ldr	r3, [pc, #24]	@ (890 <TCPWM_Enable+0x30>)
 876:	6819      	ldr	r1, [r3, #0]
 878:	1dfb      	adds	r3, r7, #7
 87a:	781b      	ldrb	r3, [r3, #0]
 87c:	2201      	movs	r2, #1
 87e:	409a      	lsls	r2, r3
 880:	4b03      	ldr	r3, [pc, #12]	@ (890 <TCPWM_Enable+0x30>)
 882:	430a      	orrs	r2, r1
 884:	601a      	str	r2, [r3, #0]
 886:	e000      	b.n	88a <TCPWM_Enable+0x2a>
        return;
 888:	46c0      	nop			@ (mov r8, r8)
}
 88a:	46bd      	mov	sp, r7
 88c:	b002      	add	sp, #8
 88e:	bd80      	pop	{r7, pc}
 890:	40200000 	.word	0x40200000

00000894 <TCPWM_Disable>:

void TCPWM_Disable(uint8_t tcpwm_Num)
{
 894:	b580      	push	{r7, lr}
 896:	b082      	sub	sp, #8
 898:	af00      	add	r7, sp, #0
 89a:	0002      	movs	r2, r0
 89c:	1dfb      	adds	r3, r7, #7
 89e:	701a      	strb	r2, [r3, #0]
    if(tcpwm_Num > 7){
 8a0:	1dfb      	adds	r3, r7, #7
 8a2:	781b      	ldrb	r3, [r3, #0]
 8a4:	2b07      	cmp	r3, #7
 8a6:	d80b      	bhi.n	8c0 <TCPWM_Disable+0x2c>
        return;
    }
    TCPWM->CTRL &= ~(1u << tcpwm_Num);
 8a8:	4b07      	ldr	r3, [pc, #28]	@ (8c8 <TCPWM_Disable+0x34>)
 8aa:	681a      	ldr	r2, [r3, #0]
 8ac:	1dfb      	adds	r3, r7, #7
 8ae:	781b      	ldrb	r3, [r3, #0]
 8b0:	2101      	movs	r1, #1
 8b2:	4099      	lsls	r1, r3
 8b4:	000b      	movs	r3, r1
 8b6:	43d9      	mvns	r1, r3
 8b8:	4b03      	ldr	r3, [pc, #12]	@ (8c8 <TCPWM_Disable+0x34>)
 8ba:	400a      	ands	r2, r1
 8bc:	601a      	str	r2, [r3, #0]
 8be:	e000      	b.n	8c2 <TCPWM_Disable+0x2e>
        return;
 8c0:	46c0      	nop			@ (mov r8, r8)
}
 8c2:	46bd      	mov	sp, r7
 8c4:	b002      	add	sp, #8
 8c6:	bd80      	pop	{r7, pc}
 8c8:	40200000 	.word	0x40200000

000008cc <TCPWM_Start>:

void TCPWM_Start(uint8_t tcpwm_Num)
{
 8cc:	b580      	push	{r7, lr}
 8ce:	b082      	sub	sp, #8
 8d0:	af00      	add	r7, sp, #0
 8d2:	0002      	movs	r2, r0
 8d4:	1dfb      	adds	r3, r7, #7
 8d6:	701a      	strb	r2, [r3, #0]
    if(tcpwm_Num > 7){
 8d8:	1dfb      	adds	r3, r7, #7
 8da:	781b      	ldrb	r3, [r3, #0]
 8dc:	2b07      	cmp	r3, #7
 8de:	d80a      	bhi.n	8f6 <TCPWM_Start+0x2a>
        return;
    }
    TCPWM->CMD |= (1u << (24u + tcpwm_Num));
 8e0:	4b07      	ldr	r3, [pc, #28]	@ (900 <TCPWM_Start+0x34>)
 8e2:	6899      	ldr	r1, [r3, #8]
 8e4:	1dfb      	adds	r3, r7, #7
 8e6:	781b      	ldrb	r3, [r3, #0]
 8e8:	3318      	adds	r3, #24
 8ea:	2201      	movs	r2, #1
 8ec:	409a      	lsls	r2, r3
 8ee:	4b04      	ldr	r3, [pc, #16]	@ (900 <TCPWM_Start+0x34>)
 8f0:	430a      	orrs	r2, r1
 8f2:	609a      	str	r2, [r3, #8]
 8f4:	e000      	b.n	8f8 <TCPWM_Start+0x2c>
        return;
 8f6:	46c0      	nop			@ (mov r8, r8)
}
 8f8:	46bd      	mov	sp, r7
 8fa:	b002      	add	sp, #8
 8fc:	bd80      	pop	{r7, pc}
 8fe:	46c0      	nop			@ (mov r8, r8)
 900:	40200000 	.word	0x40200000

00000904 <TCPWM_Stop>:

void TCPWM_Stop(uint8_t tcpwm_Num)
{
 904:	b580      	push	{r7, lr}
 906:	b082      	sub	sp, #8
 908:	af00      	add	r7, sp, #0
 90a:	0002      	movs	r2, r0
 90c:	1dfb      	adds	r3, r7, #7
 90e:	701a      	strb	r2, [r3, #0]
    if(tcpwm_Num > 7){
 910:	1dfb      	adds	r3, r7, #7
 912:	781b      	ldrb	r3, [r3, #0]
 914:	2b07      	cmp	r3, #7
 916:	d80a      	bhi.n	92e <TCPWM_Stop+0x2a>
        return;
    }
    TCPWM->CMD |= (1u << (16u + tcpwm_Num));
 918:	4b07      	ldr	r3, [pc, #28]	@ (938 <TCPWM_Stop+0x34>)
 91a:	6899      	ldr	r1, [r3, #8]
 91c:	1dfb      	adds	r3, r7, #7
 91e:	781b      	ldrb	r3, [r3, #0]
 920:	3310      	adds	r3, #16
 922:	2201      	movs	r2, #1
 924:	409a      	lsls	r2, r3
 926:	4b04      	ldr	r3, [pc, #16]	@ (938 <TCPWM_Stop+0x34>)
 928:	430a      	orrs	r2, r1
 92a:	609a      	str	r2, [r3, #8]
 92c:	e000      	b.n	930 <TCPWM_Stop+0x2c>
        return;
 92e:	46c0      	nop			@ (mov r8, r8)
}
 930:	46bd      	mov	sp, r7
 932:	b002      	add	sp, #8
 934:	bd80      	pop	{r7, pc}
 936:	46c0      	nop			@ (mov r8, r8)
 938:	40200000 	.word	0x40200000

0000093c <TCPWM_GetCounter>:

uint32_t TCPWM_GetCounter(uint8_t tcpwm_Num)
{
 93c:	b580      	push	{r7, lr}
 93e:	b084      	sub	sp, #16
 940:	af00      	add	r7, sp, #0
 942:	0002      	movs	r2, r0
 944:	1dfb      	adds	r3, r7, #7
 946:	701a      	strb	r2, [r3, #0]
    if(tcpwm_Num > 7){
 948:	1dfb      	adds	r3, r7, #7
 94a:	781b      	ldrb	r3, [r3, #0]
 94c:	2b07      	cmp	r3, #7
 94e:	d901      	bls.n	954 <TCPWM_GetCounter+0x18>
        return 0;
 950:	2300      	movs	r3, #0
 952:	e00a      	b.n	96a <TCPWM_GetCounter+0x2e>
    }
    TCPWM_CNT_Type* tcpwm;
    tcpwm = GET_TCPWM_NUM(tcpwm_Num);
 954:	1dfb      	adds	r3, r7, #7
 956:	781b      	ldrb	r3, [r3, #0]
 958:	019b      	lsls	r3, r3, #6
 95a:	4a06      	ldr	r2, [pc, #24]	@ (974 <TCPWM_GetCounter+0x38>)
 95c:	4694      	mov	ip, r2
 95e:	4463      	add	r3, ip
 960:	60fb      	str	r3, [r7, #12]
    return (uint32_t)(tcpwm->COUNTER & 0x0000FFFFu);
 962:	68fb      	ldr	r3, [r7, #12]
 964:	689b      	ldr	r3, [r3, #8]
 966:	041b      	lsls	r3, r3, #16
 968:	0c1b      	lsrs	r3, r3, #16
}
 96a:	0018      	movs	r0, r3
 96c:	46bd      	mov	sp, r7
 96e:	b004      	add	sp, #16
 970:	bd80      	pop	{r7, pc}
 972:	46c0      	nop			@ (mov r8, r8)
 974:	40200100 	.word	0x40200100

00000978 <TCPWM_SetCounter>:

void TCPWM_SetCounter(uint8_t tcpwm_Num, uint32_t count)
{
 978:	b580      	push	{r7, lr}
 97a:	b084      	sub	sp, #16
 97c:	af00      	add	r7, sp, #0
 97e:	0002      	movs	r2, r0
 980:	6039      	str	r1, [r7, #0]
 982:	1dfb      	adds	r3, r7, #7
 984:	701a      	strb	r2, [r3, #0]
    if(tcpwm_Num > 7){
 986:	1dfb      	adds	r3, r7, #7
 988:	781b      	ldrb	r3, [r3, #0]
 98a:	2b07      	cmp	r3, #7
 98c:	d80a      	bhi.n	9a4 <TCPWM_SetCounter+0x2c>
        return;
    }
    TCPWM_CNT_Type* tcpwm;
    tcpwm = GET_TCPWM_NUM(tcpwm_Num);
 98e:	1dfb      	adds	r3, r7, #7
 990:	781b      	ldrb	r3, [r3, #0]
 992:	019b      	lsls	r3, r3, #6
 994:	4a05      	ldr	r2, [pc, #20]	@ (9ac <TCPWM_SetCounter+0x34>)
 996:	4694      	mov	ip, r2
 998:	4463      	add	r3, ip
 99a:	60fb      	str	r3, [r7, #12]
    tcpwm->COUNTER = count;
 99c:	68fb      	ldr	r3, [r7, #12]
 99e:	683a      	ldr	r2, [r7, #0]
 9a0:	609a      	str	r2, [r3, #8]
 9a2:	e000      	b.n	9a6 <TCPWM_SetCounter+0x2e>
        return;
 9a4:	46c0      	nop			@ (mov r8, r8)
}
 9a6:	46bd      	mov	sp, r7
 9a8:	b004      	add	sp, #16
 9aa:	bd80      	pop	{r7, pc}
 9ac:	40200100 	.word	0x40200100

000009b0 <TCPWM_ClearInterrupt>:

void TCPWM_ClearInterrupt(uint8_t tcpwm_Num, uint8_t intrMask)
{
 9b0:	b580      	push	{r7, lr}
 9b2:	b084      	sub	sp, #16
 9b4:	af00      	add	r7, sp, #0
 9b6:	0002      	movs	r2, r0
 9b8:	1dfb      	adds	r3, r7, #7
 9ba:	701a      	strb	r2, [r3, #0]
 9bc:	1dbb      	adds	r3, r7, #6
 9be:	1c0a      	adds	r2, r1, #0
 9c0:	701a      	strb	r2, [r3, #0]
    if(tcpwm_Num > 7){
 9c2:	1dfb      	adds	r3, r7, #7
 9c4:	781b      	ldrb	r3, [r3, #0]
 9c6:	2b07      	cmp	r3, #7
 9c8:	d80d      	bhi.n	9e6 <TCPWM_ClearInterrupt+0x36>
        return;
    }
    TCPWM_CNT_Type* tcpwm;
    tcpwm = GET_TCPWM_NUM(tcpwm_Num);
 9ca:	1dfb      	adds	r3, r7, #7
 9cc:	781b      	ldrb	r3, [r3, #0]
 9ce:	019b      	lsls	r3, r3, #6
 9d0:	4a07      	ldr	r2, [pc, #28]	@ (9f0 <TCPWM_ClearInterrupt+0x40>)
 9d2:	4694      	mov	ip, r2
 9d4:	4463      	add	r3, ip
 9d6:	60fb      	str	r3, [r7, #12]
    tcpwm->INTR = intrMask & 0x03;
 9d8:	1dbb      	adds	r3, r7, #6
 9da:	781b      	ldrb	r3, [r3, #0]
 9dc:	2203      	movs	r2, #3
 9de:	401a      	ands	r2, r3
 9e0:	68fb      	ldr	r3, [r7, #12]
 9e2:	631a      	str	r2, [r3, #48]	@ 0x30
 9e4:	e000      	b.n	9e8 <TCPWM_ClearInterrupt+0x38>
        return;
 9e6:	46c0      	nop			@ (mov r8, r8)
}
 9e8:	46bd      	mov	sp, r7
 9ea:	b004      	add	sp, #16
 9ec:	bd80      	pop	{r7, pc}
 9ee:	46c0      	nop			@ (mov r8, r8)
 9f0:	40200100 	.word	0x40200100

000009f4 <IRQ_EnableGlobal>:
#include <stdint.h>

/*
 * Uses the Thumb-2 "CPSIE i" instruction.
 */
void IRQ_EnableGlobal(void) {
 9f4:	b580      	push	{r7, lr}
 9f6:	af00      	add	r7, sp, #0
    __asm volatile ("cpsie i" : : : "memory");
 9f8:	b662      	cpsie	i
}
 9fa:	46c0      	nop			@ (mov r8, r8)
 9fc:	46bd      	mov	sp, r7
 9fe:	bd80      	pop	{r7, pc}

00000a00 <IRQ_DisableGlobal>:

/*
 * Uses the Thumb-2 "CPSID i" instruction.
 */
void IRQ_DisableGlobal(void) {
 a00:	b580      	push	{r7, lr}
 a02:	af00      	add	r7, sp, #0
    __asm volatile ("cpsid i" : : : "memory");
 a04:	b672      	cpsid	i
}
 a06:	46c0      	nop			@ (mov r8, r8)
 a08:	46bd      	mov	sp, r7
 a0a:	bd80      	pop	{r7, pc}

00000a0c <NVIC_SetPriority>:

void NVIC_SetPriority(uint32_t IRQn, uint32_t priority)
{
 a0c:	b580      	push	{r7, lr}
 a0e:	b084      	sub	sp, #16
 a10:	af00      	add	r7, sp, #0
 a12:	6078      	str	r0, [r7, #4]
 a14:	6039      	str	r1, [r7, #0]
    if ((int32_t)(IRQn) >= 0){
 a16:	687b      	ldr	r3, [r7, #4]
 a18:	2b00      	cmp	r3, #0
 a1a:	db20      	blt.n	a5e <NVIC_SetPriority+0x52>
        uint32_t IRQ_LDX = IRQn >> 2u;
 a1c:	687b      	ldr	r3, [r7, #4]
 a1e:	089b      	lsrs	r3, r3, #2
 a20:	60fb      	str	r3, [r7, #12]
        NVIC->IPR[IRQ_LDX] = (NVIC->IPR[IRQ_LDX] & ~(0xFFUL << ((IRQn & 0x03) << 3))) | (((priority & 0x03) << 6) << ((IRQn & 0x03) << 3));
 a22:	4a11      	ldr	r2, [pc, #68]	@ (a68 <NVIC_SetPriority+0x5c>)
 a24:	68fb      	ldr	r3, [r7, #12]
 a26:	33c0      	adds	r3, #192	@ 0xc0
 a28:	009b      	lsls	r3, r3, #2
 a2a:	589b      	ldr	r3, [r3, r2]
 a2c:	687a      	ldr	r2, [r7, #4]
 a2e:	00d2      	lsls	r2, r2, #3
 a30:	2118      	movs	r1, #24
 a32:	400a      	ands	r2, r1
 a34:	21ff      	movs	r1, #255	@ 0xff
 a36:	4091      	lsls	r1, r2
 a38:	000a      	movs	r2, r1
 a3a:	43d2      	mvns	r2, r2
 a3c:	401a      	ands	r2, r3
 a3e:	683b      	ldr	r3, [r7, #0]
 a40:	019b      	lsls	r3, r3, #6
 a42:	21ff      	movs	r1, #255	@ 0xff
 a44:	4019      	ands	r1, r3
 a46:	687b      	ldr	r3, [r7, #4]
 a48:	00db      	lsls	r3, r3, #3
 a4a:	2018      	movs	r0, #24
 a4c:	4003      	ands	r3, r0
 a4e:	4099      	lsls	r1, r3
 a50:	000b      	movs	r3, r1
 a52:	4905      	ldr	r1, [pc, #20]	@ (a68 <NVIC_SetPriority+0x5c>)
 a54:	431a      	orrs	r2, r3
 a56:	68fb      	ldr	r3, [r7, #12]
 a58:	33c0      	adds	r3, #192	@ 0xc0
 a5a:	009b      	lsls	r3, r3, #2
 a5c:	505a      	str	r2, [r3, r1]
    }
}
 a5e:	46c0      	nop			@ (mov r8, r8)
 a60:	46bd      	mov	sp, r7
 a62:	b004      	add	sp, #16
 a64:	bd80      	pop	{r7, pc}
 a66:	46c0      	nop			@ (mov r8, r8)
 a68:	e000e100 	.word	0xe000e100

00000a6c <NVIC_ClearPendingIRQ>:

void NVIC_ClearPendingIRQ(uint32_t IRQn)
{
 a6c:	b580      	push	{r7, lr}
 a6e:	b082      	sub	sp, #8
 a70:	af00      	add	r7, sp, #0
 a72:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 a74:	687b      	ldr	r3, [r7, #4]
 a76:	2b00      	cmp	r3, #0
 a78:	db08      	blt.n	a8c <NVIC_ClearPendingIRQ+0x20>
  {
    NVIC->ICPR = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 a7a:	687b      	ldr	r3, [r7, #4]
 a7c:	221f      	movs	r2, #31
 a7e:	4013      	ands	r3, r2
 a80:	4904      	ldr	r1, [pc, #16]	@ (a94 <NVIC_ClearPendingIRQ+0x28>)
 a82:	2201      	movs	r2, #1
 a84:	409a      	lsls	r2, r3
 a86:	23c0      	movs	r3, #192	@ 0xc0
 a88:	005b      	lsls	r3, r3, #1
 a8a:	50ca      	str	r2, [r1, r3]
  }
}
 a8c:	46c0      	nop			@ (mov r8, r8)
 a8e:	46bd      	mov	sp, r7
 a90:	b002      	add	sp, #8
 a92:	bd80      	pop	{r7, pc}
 a94:	e000e100 	.word	0xe000e100

00000a98 <NVIC_EnableIRQ>:

void NVIC_EnableIRQ(uint32_t IRQn)
{
 a98:	b580      	push	{r7, lr}
 a9a:	b082      	sub	sp, #8
 a9c:	af00      	add	r7, sp, #0
 a9e:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 aa0:	687b      	ldr	r3, [r7, #4]
 aa2:	2b00      	cmp	r3, #0
 aa4:	db07      	blt.n	ab6 <NVIC_EnableIRQ+0x1e>
  {
    __asm volatile("":::"memory");
    NVIC->ISER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 aa6:	687b      	ldr	r3, [r7, #4]
 aa8:	221f      	movs	r2, #31
 aaa:	401a      	ands	r2, r3
 aac:	4b04      	ldr	r3, [pc, #16]	@ (ac0 <NVIC_EnableIRQ+0x28>)
 aae:	2101      	movs	r1, #1
 ab0:	4091      	lsls	r1, r2
 ab2:	000a      	movs	r2, r1
 ab4:	601a      	str	r2, [r3, #0]
    __asm volatile("":::"memory");
  }
}
 ab6:	46c0      	nop			@ (mov r8, r8)
 ab8:	46bd      	mov	sp, r7
 aba:	b002      	add	sp, #8
 abc:	bd80      	pop	{r7, pc}
 abe:	46c0      	nop			@ (mov r8, r8)
 ac0:	e000e100 	.word	0xe000e100

00000ac4 <NVIC_DisableIRQ>:

void NVIC_DisableIRQ(uint32_t IRQn)
{
 ac4:	b580      	push	{r7, lr}
 ac6:	b082      	sub	sp, #8
 ac8:	af00      	add	r7, sp, #0
 aca:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 acc:	687b      	ldr	r3, [r7, #4]
 ace:	2b00      	cmp	r3, #0
 ad0:	db0c      	blt.n	aec <NVIC_DisableIRQ+0x28>
  {
    NVIC->ICER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 ad2:	687b      	ldr	r3, [r7, #4]
 ad4:	221f      	movs	r2, #31
 ad6:	4013      	ands	r3, r2
 ad8:	4906      	ldr	r1, [pc, #24]	@ (af4 <NVIC_DisableIRQ+0x30>)
 ada:	2201      	movs	r2, #1
 adc:	409a      	lsls	r2, r3
 ade:	0013      	movs	r3, r2
 ae0:	2280      	movs	r2, #128	@ 0x80
 ae2:	508b      	str	r3, [r1, r2]
    __asm volatile ("dsb 0xF":::"memory");
 ae4:	f3bf 8f4f 	dsb	sy
    __asm volatile ("isb 0xF":::"memory");
 ae8:	f3bf 8f6f 	isb	sy
  }
}
 aec:	46c0      	nop			@ (mov r8, r8)
 aee:	46bd      	mov	sp, r7
 af0:	b002      	add	sp, #8
 af2:	bd80      	pop	{r7, pc}
 af4:	e000e100 	.word	0xe000e100

00000af8 <_init>:
extern uint32_t __bss_start__;
extern uint32_t __bss_end__;

extern uint32_t __STACK_START;
extern uint32_t __STACK_END;
extern void _init(void) {;}
 af8:	b580      	push	{r7, lr}
 afa:	af00      	add	r7, sp, #0
 afc:	46c0      	nop			@ (mov r8, r8)
 afe:	46bd      	mov	sp, r7
 b00:	bd80      	pop	{r7, pc}

00000b02 <Reset_handler>:
    (uint32_t)can_interrupt_can_IRQHandler,             /*  26 CAN Interrupt */
    (uint32_t)crypto_interrupt_IRQHandler               /*  27 Crypto Interrupt */
};

void Reset_handler(void)
{
 b02:	b580      	push	{r7, lr}
 b04:	b086      	sub	sp, #24
 b06:	af00      	add	r7, sp, #0
    //disable watchdog
    (*(uint32_t *) CYREG_WDT_DISABLE_KEY) = CY_SYS_WDT_KEY;
 b08:	4b1c      	ldr	r3, [pc, #112]	@ (b7c <Reset_handler+0x7a>)
 b0a:	4a1d      	ldr	r2, [pc, #116]	@ (b80 <Reset_handler+0x7e>)
 b0c:	601a      	str	r2, [r3, #0]

    //copy .data section to SRAM
    uint32_t size = &__data_end - &__data_start;
 b0e:	4a1d      	ldr	r2, [pc, #116]	@ (b84 <Reset_handler+0x82>)
 b10:	4b1d      	ldr	r3, [pc, #116]	@ (b88 <Reset_handler+0x86>)
 b12:	1ad3      	subs	r3, r2, r3
 b14:	109b      	asrs	r3, r3, #2
 b16:	607b      	str	r3, [r7, #4]
    uint32_t *pDst = (uint32_t*)&__data_start;
 b18:	4b1b      	ldr	r3, [pc, #108]	@ (b88 <Reset_handler+0x86>)
 b1a:	617b      	str	r3, [r7, #20]
    uint32_t *pSrc = (uint32_t*)&_la_data;
 b1c:	4b1b      	ldr	r3, [pc, #108]	@ (b8c <Reset_handler+0x8a>)
 b1e:	613b      	str	r3, [r7, #16]

    for(uint32_t i = 0; i< size; i++)
 b20:	2300      	movs	r3, #0
 b22:	60fb      	str	r3, [r7, #12]
 b24:	e00a      	b.n	b3c <Reset_handler+0x3a>
    {
        *pDst++ = *pSrc++;
 b26:	693a      	ldr	r2, [r7, #16]
 b28:	1d13      	adds	r3, r2, #4
 b2a:	613b      	str	r3, [r7, #16]
 b2c:	697b      	ldr	r3, [r7, #20]
 b2e:	1d19      	adds	r1, r3, #4
 b30:	6179      	str	r1, [r7, #20]
 b32:	6812      	ldr	r2, [r2, #0]
 b34:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 b36:	68fb      	ldr	r3, [r7, #12]
 b38:	3301      	adds	r3, #1
 b3a:	60fb      	str	r3, [r7, #12]
 b3c:	68fa      	ldr	r2, [r7, #12]
 b3e:	687b      	ldr	r3, [r7, #4]
 b40:	429a      	cmp	r2, r3
 b42:	d3f0      	bcc.n	b26 <Reset_handler+0x24>
    }
    //int the .bss section to zero in SRAM
    size = &__bss_end__ - &__bss_start__;
 b44:	4a12      	ldr	r2, [pc, #72]	@ (b90 <Reset_handler+0x8e>)
 b46:	4b13      	ldr	r3, [pc, #76]	@ (b94 <Reset_handler+0x92>)
 b48:	1ad3      	subs	r3, r2, r3
 b4a:	109b      	asrs	r3, r3, #2
 b4c:	607b      	str	r3, [r7, #4]
    pDst = (uint32_t*)&__bss_start__;
 b4e:	4b11      	ldr	r3, [pc, #68]	@ (b94 <Reset_handler+0x92>)
 b50:	617b      	str	r3, [r7, #20]

    for(uint32_t i = 0; i< size; i++)
 b52:	2300      	movs	r3, #0
 b54:	60bb      	str	r3, [r7, #8]
 b56:	e007      	b.n	b68 <Reset_handler+0x66>
    {
        *pDst++ = 0;
 b58:	697b      	ldr	r3, [r7, #20]
 b5a:	1d1a      	adds	r2, r3, #4
 b5c:	617a      	str	r2, [r7, #20]
 b5e:	2200      	movs	r2, #0
 b60:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 b62:	68bb      	ldr	r3, [r7, #8]
 b64:	3301      	adds	r3, #1
 b66:	60bb      	str	r3, [r7, #8]
 b68:	68ba      	ldr	r2, [r7, #8]
 b6a:	687b      	ldr	r3, [r7, #4]
 b6c:	429a      	cmp	r2, r3
 b6e:	d3f3      	bcc.n	b58 <Reset_handler+0x56>
    }

    // Init C std libs
    __libc_init_array();
 b70:	f000 f8a6 	bl	cc0 <__libc_init_array>
    

    //call main()
    main();
 b74:	f7ff faa4 	bl	c0 <main>

    while (1)
 b78:	46c0      	nop			@ (mov r8, r8)
 b7a:	e7fd      	b.n	b78 <Reset_handler+0x76>
 b7c:	40030038 	.word	0x40030038
 b80:	aced8865 	.word	0xaced8865
 b84:	20000000 	.word	0x20000000
 b88:	20000000 	.word	0x20000000
 b8c:	00000d24 	.word	0x00000d24
 b90:	20000004 	.word	0x20000004
 b94:	20000000 	.word	0x20000000

00000b98 <Default_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Exceptions / Interrupts
 *----------------------------------------------------------------------------*/
void Default_Handler(void)
{
 b98:	b580      	push	{r7, lr}
 b9a:	af00      	add	r7, sp, #0
    while(1);
 b9c:	46c0      	nop			@ (mov r8, r8)
 b9e:	e7fd      	b.n	b9c <Default_Handler+0x4>

00000ba0 <HRDFLT_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Hard Fault
 *----------------------------------------------------------------------------*/
void HRDFLT_Handler(void)
{
 ba0:	b580      	push	{r7, lr}
 ba2:	af00      	add	r7, sp, #0
    while(1);
 ba4:	46c0      	nop			@ (mov r8, r8)
 ba6:	e7fd      	b.n	ba4 <HRDFLT_Handler+0x4>

00000ba8 <__udivsi3>:
 ba8:	2200      	movs	r2, #0
 baa:	0843      	lsrs	r3, r0, #1
 bac:	428b      	cmp	r3, r1
 bae:	d374      	bcc.n	c9a <__udivsi3+0xf2>
 bb0:	0903      	lsrs	r3, r0, #4
 bb2:	428b      	cmp	r3, r1
 bb4:	d35f      	bcc.n	c76 <__udivsi3+0xce>
 bb6:	0a03      	lsrs	r3, r0, #8
 bb8:	428b      	cmp	r3, r1
 bba:	d344      	bcc.n	c46 <__udivsi3+0x9e>
 bbc:	0b03      	lsrs	r3, r0, #12
 bbe:	428b      	cmp	r3, r1
 bc0:	d328      	bcc.n	c14 <__udivsi3+0x6c>
 bc2:	0c03      	lsrs	r3, r0, #16
 bc4:	428b      	cmp	r3, r1
 bc6:	d30d      	bcc.n	be4 <__udivsi3+0x3c>
 bc8:	22ff      	movs	r2, #255	@ 0xff
 bca:	0209      	lsls	r1, r1, #8
 bcc:	ba12      	rev	r2, r2
 bce:	0c03      	lsrs	r3, r0, #16
 bd0:	428b      	cmp	r3, r1
 bd2:	d302      	bcc.n	bda <__udivsi3+0x32>
 bd4:	1212      	asrs	r2, r2, #8
 bd6:	0209      	lsls	r1, r1, #8
 bd8:	d065      	beq.n	ca6 <__udivsi3+0xfe>
 bda:	0b03      	lsrs	r3, r0, #12
 bdc:	428b      	cmp	r3, r1
 bde:	d319      	bcc.n	c14 <__udivsi3+0x6c>
 be0:	e000      	b.n	be4 <__udivsi3+0x3c>
 be2:	0a09      	lsrs	r1, r1, #8
 be4:	0bc3      	lsrs	r3, r0, #15
 be6:	428b      	cmp	r3, r1
 be8:	d301      	bcc.n	bee <__udivsi3+0x46>
 bea:	03cb      	lsls	r3, r1, #15
 bec:	1ac0      	subs	r0, r0, r3
 bee:	4152      	adcs	r2, r2
 bf0:	0b83      	lsrs	r3, r0, #14
 bf2:	428b      	cmp	r3, r1
 bf4:	d301      	bcc.n	bfa <__udivsi3+0x52>
 bf6:	038b      	lsls	r3, r1, #14
 bf8:	1ac0      	subs	r0, r0, r3
 bfa:	4152      	adcs	r2, r2
 bfc:	0b43      	lsrs	r3, r0, #13
 bfe:	428b      	cmp	r3, r1
 c00:	d301      	bcc.n	c06 <__udivsi3+0x5e>
 c02:	034b      	lsls	r3, r1, #13
 c04:	1ac0      	subs	r0, r0, r3
 c06:	4152      	adcs	r2, r2
 c08:	0b03      	lsrs	r3, r0, #12
 c0a:	428b      	cmp	r3, r1
 c0c:	d301      	bcc.n	c12 <__udivsi3+0x6a>
 c0e:	030b      	lsls	r3, r1, #12
 c10:	1ac0      	subs	r0, r0, r3
 c12:	4152      	adcs	r2, r2
 c14:	0ac3      	lsrs	r3, r0, #11
 c16:	428b      	cmp	r3, r1
 c18:	d301      	bcc.n	c1e <__udivsi3+0x76>
 c1a:	02cb      	lsls	r3, r1, #11
 c1c:	1ac0      	subs	r0, r0, r3
 c1e:	4152      	adcs	r2, r2
 c20:	0a83      	lsrs	r3, r0, #10
 c22:	428b      	cmp	r3, r1
 c24:	d301      	bcc.n	c2a <__udivsi3+0x82>
 c26:	028b      	lsls	r3, r1, #10
 c28:	1ac0      	subs	r0, r0, r3
 c2a:	4152      	adcs	r2, r2
 c2c:	0a43      	lsrs	r3, r0, #9
 c2e:	428b      	cmp	r3, r1
 c30:	d301      	bcc.n	c36 <__udivsi3+0x8e>
 c32:	024b      	lsls	r3, r1, #9
 c34:	1ac0      	subs	r0, r0, r3
 c36:	4152      	adcs	r2, r2
 c38:	0a03      	lsrs	r3, r0, #8
 c3a:	428b      	cmp	r3, r1
 c3c:	d301      	bcc.n	c42 <__udivsi3+0x9a>
 c3e:	020b      	lsls	r3, r1, #8
 c40:	1ac0      	subs	r0, r0, r3
 c42:	4152      	adcs	r2, r2
 c44:	d2cd      	bcs.n	be2 <__udivsi3+0x3a>
 c46:	09c3      	lsrs	r3, r0, #7
 c48:	428b      	cmp	r3, r1
 c4a:	d301      	bcc.n	c50 <__udivsi3+0xa8>
 c4c:	01cb      	lsls	r3, r1, #7
 c4e:	1ac0      	subs	r0, r0, r3
 c50:	4152      	adcs	r2, r2
 c52:	0983      	lsrs	r3, r0, #6
 c54:	428b      	cmp	r3, r1
 c56:	d301      	bcc.n	c5c <__udivsi3+0xb4>
 c58:	018b      	lsls	r3, r1, #6
 c5a:	1ac0      	subs	r0, r0, r3
 c5c:	4152      	adcs	r2, r2
 c5e:	0943      	lsrs	r3, r0, #5
 c60:	428b      	cmp	r3, r1
 c62:	d301      	bcc.n	c68 <__udivsi3+0xc0>
 c64:	014b      	lsls	r3, r1, #5
 c66:	1ac0      	subs	r0, r0, r3
 c68:	4152      	adcs	r2, r2
 c6a:	0903      	lsrs	r3, r0, #4
 c6c:	428b      	cmp	r3, r1
 c6e:	d301      	bcc.n	c74 <__udivsi3+0xcc>
 c70:	010b      	lsls	r3, r1, #4
 c72:	1ac0      	subs	r0, r0, r3
 c74:	4152      	adcs	r2, r2
 c76:	08c3      	lsrs	r3, r0, #3
 c78:	428b      	cmp	r3, r1
 c7a:	d301      	bcc.n	c80 <__udivsi3+0xd8>
 c7c:	00cb      	lsls	r3, r1, #3
 c7e:	1ac0      	subs	r0, r0, r3
 c80:	4152      	adcs	r2, r2
 c82:	0883      	lsrs	r3, r0, #2
 c84:	428b      	cmp	r3, r1
 c86:	d301      	bcc.n	c8c <__udivsi3+0xe4>
 c88:	008b      	lsls	r3, r1, #2
 c8a:	1ac0      	subs	r0, r0, r3
 c8c:	4152      	adcs	r2, r2
 c8e:	0843      	lsrs	r3, r0, #1
 c90:	428b      	cmp	r3, r1
 c92:	d301      	bcc.n	c98 <__udivsi3+0xf0>
 c94:	004b      	lsls	r3, r1, #1
 c96:	1ac0      	subs	r0, r0, r3
 c98:	4152      	adcs	r2, r2
 c9a:	1a41      	subs	r1, r0, r1
 c9c:	d200      	bcs.n	ca0 <__udivsi3+0xf8>
 c9e:	4601      	mov	r1, r0
 ca0:	4152      	adcs	r2, r2
 ca2:	4610      	mov	r0, r2
 ca4:	4770      	bx	lr
 ca6:	e7ff      	b.n	ca8 <__udivsi3+0x100>
 ca8:	b501      	push	{r0, lr}
 caa:	2000      	movs	r0, #0
 cac:	f000 f806 	bl	cbc <__aeabi_idiv0>
 cb0:	bd02      	pop	{r1, pc}
 cb2:	46c0      	nop			@ (mov r8, r8)

00000cb4 <__aeabi_uidivmod>:
 cb4:	2900      	cmp	r1, #0
 cb6:	d0f7      	beq.n	ca8 <__udivsi3+0x100>
 cb8:	e776      	b.n	ba8 <__udivsi3>
 cba:	4770      	bx	lr

00000cbc <__aeabi_idiv0>:
 cbc:	4770      	bx	lr
 cbe:	46c0      	nop			@ (mov r8, r8)

00000cc0 <__libc_init_array>:
 cc0:	b570      	push	{r4, r5, r6, lr}
 cc2:	2600      	movs	r6, #0
 cc4:	4c0c      	ldr	r4, [pc, #48]	@ (cf8 <__libc_init_array+0x38>)
 cc6:	4d0d      	ldr	r5, [pc, #52]	@ (cfc <__libc_init_array+0x3c>)
 cc8:	1b64      	subs	r4, r4, r5
 cca:	10a4      	asrs	r4, r4, #2
 ccc:	42a6      	cmp	r6, r4
 cce:	d109      	bne.n	ce4 <__libc_init_array+0x24>
 cd0:	2600      	movs	r6, #0
 cd2:	f7ff ff11 	bl	af8 <_init>
 cd6:	4c0a      	ldr	r4, [pc, #40]	@ (d00 <__libc_init_array+0x40>)
 cd8:	4d0a      	ldr	r5, [pc, #40]	@ (d04 <__libc_init_array+0x44>)
 cda:	1b64      	subs	r4, r4, r5
 cdc:	10a4      	asrs	r4, r4, #2
 cde:	42a6      	cmp	r6, r4
 ce0:	d105      	bne.n	cee <__libc_init_array+0x2e>
 ce2:	bd70      	pop	{r4, r5, r6, pc}
 ce4:	00b3      	lsls	r3, r6, #2
 ce6:	58eb      	ldr	r3, [r5, r3]
 ce8:	4798      	blx	r3
 cea:	3601      	adds	r6, #1
 cec:	e7ee      	b.n	ccc <__libc_init_array+0xc>
 cee:	00b3      	lsls	r3, r6, #2
 cf0:	58eb      	ldr	r3, [r5, r3]
 cf2:	4798      	blx	r3
 cf4:	3601      	adds	r6, #1
 cf6:	e7f2      	b.n	cde <__libc_init_array+0x1e>
	...

00000d08 <tcpwm2_config>:
 d08:	0000 0000 8000 0000 0000 0000 0000 0000     ................

00000d18 <LED8_P1_6_config>:
 d18:	0001 0000 0006 0000 0000 0000               ............
