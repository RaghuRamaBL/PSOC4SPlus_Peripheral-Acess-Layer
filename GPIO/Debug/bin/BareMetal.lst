
bin/BareMetal.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006f8  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  20000000  20000000  000016f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  20000000  20000000  00000000  2**0
                  ALLOC
  3 .heap         00000000  20002df0  20002df0  000016f8  2**0
                  CONTENTS
  4 .stack        00003000  20000000  20000000  00002000  2**0
                  ALLOC
  5 .debug_info   00000b65  00000000  00000000  000016f8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_abbrev 00000481  00000000  00000000  0000225d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_aranges 00000080  00000000  00000000  000026de  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00000803  00000000  00000000  0000275e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    000004b1  00000000  00000000  00002f61  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000044  00000000  00000000  00003412  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002c  00000000  00000000  00003456  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000310  00000000  00000000  00003484  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <vector>:
   0:	00 30 00 20 db 05 00 00 71 06 00 00 79 06 00 00     .0. ....q...y...
	...
  2c:	71 06 00 00 00 00 00 00 00 00 00 00 71 06 00 00     q...........q...
  3c:	71 06 00 00 71 06 00 00 71 06 00 00 c5 01 00 00     q...q...q.......
  4c:	93 01 00 00 71 06 00 00 71 06 00 00 71 06 00 00     ....q...q...q...
  5c:	71 06 00 00 71 06 00 00 71 06 00 00 71 06 00 00     q...q...q...q...
  6c:	71 06 00 00 71 06 00 00 71 06 00 00 71 06 00 00     q...q...q...q...
  7c:	71 06 00 00 71 06 00 00 71 06 00 00 71 06 00 00     q...q...q...q...
  8c:	71 06 00 00 71 06 00 00 71 06 00 00 71 06 00 00     q...q...q...q...
  9c:	71 06 00 00 71 06 00 00 71 06 00 00 71 06 00 00     q...q...q...q...
  ac:	71 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00     q...............
  bc:	00 00 00 00                                         ....

000000c0 <main>:
};

void Delay(int32_t);

int main()
{
  c0:	b580      	push	{r7, lr}
  c2:	af00      	add	r7, sp, #0
   // register int Var_1, Var_2, Var_3, Var_4, Var_5; 
    enable_irq();
  c4:	f000 fa0a 	bl	4dc <enable_irq>
    GPIO_Pin_Init(2, 2u, &LED10_P2_2_config, HSIOM_SEL_GPIO);
  c8:	4a1e      	ldr	r2, [pc, #120]	@ (144 <main+0x84>)
  ca:	2300      	movs	r3, #0
  cc:	2102      	movs	r1, #2
  ce:	2002      	movs	r0, #2
  d0:	f000 f9a6 	bl	420 <GPIO_Pin_Init>
    GPIO_Pin_Init(3, 7u, &SW2_P3_7_config, HSIOM_SEL_GPIO);
  d4:	4a1c      	ldr	r2, [pc, #112]	@ (148 <main+0x88>)
  d6:	2300      	movs	r3, #0
  d8:	2107      	movs	r1, #7
  da:	2003      	movs	r0, #3
  dc:	f000 f9a0 	bl	420 <GPIO_Pin_Init>
    // GPIO_Pin_Init((GPIO_PRT_Type *)CYREG_GPIO_PRT2_DR, 0u, &LED9_P2_0_config, HSIOM_SEL_GPIO);
    GPIO_Pin_Init(2, 0u, &SW_LED9_P2_0_config, HSIOM_SEL_GPIO);
  e0:	4a1a      	ldr	r2, [pc, #104]	@ (14c <main+0x8c>)
  e2:	2300      	movs	r3, #0
  e4:	2100      	movs	r1, #0
  e6:	2002      	movs	r0, #2
  e8:	f000 f99a 	bl	420 <GPIO_Pin_Init>
    GPIO_Pin_Init(1, 6u, &LED8_P1_6_config, HSIOM_SEL_GPIO);
  ec:	4a18      	ldr	r2, [pc, #96]	@ (150 <main+0x90>)
  ee:	2300      	movs	r3, #0
  f0:	2106      	movs	r1, #6
  f2:	2001      	movs	r0, #1
  f4:	f000 f994 	bl	420 <GPIO_Pin_Init>

    NVIC_SetPriority(3u, 1u);
  f8:	2101      	movs	r1, #1
  fa:	2003      	movs	r0, #3
  fc:	f000 f9f4 	bl	4e8 <NVIC_SetPriority>
    NVIC_SetPriority(2u, 1u);
 100:	2101      	movs	r1, #1
 102:	2002      	movs	r0, #2
 104:	f000 f9f0 	bl	4e8 <NVIC_SetPriority>
    /* Clearing and enabling the GPIO interrupt in NVIC */
    NVIC_ClearPendingIRQ(3u);
 108:	2003      	movs	r0, #3
 10a:	f000 fa1b 	bl	544 <NVIC_ClearPendingIRQ>
    NVIC_ClearPendingIRQ(2u);
 10e:	2002      	movs	r0, #2
 110:	f000 fa18 	bl	544 <NVIC_ClearPendingIRQ>
    NVIC_EnableIRQ(3u);
 114:	2003      	movs	r0, #3
 116:	f000 fa2b 	bl	570 <NVIC_EnableIRQ>
    NVIC_EnableIRQ(2u);
 11a:	2002      	movs	r0, #2
 11c:	f000 fa28 	bl	570 <NVIC_EnableIRQ>

    for(;;)
    {
        GPIO_Set(1, 6u);
 120:	2106      	movs	r1, #6
 122:	2001      	movs	r0, #1
 124:	f000 f868 	bl	1f8 <GPIO_Set>
        Delay(60000);
 128:	4b0a      	ldr	r3, [pc, #40]	@ (154 <main+0x94>)
 12a:	0018      	movs	r0, r3
 12c:	f000 f814 	bl	158 <Delay>

        GPIO_Clr(1, 6u);
 130:	2106      	movs	r1, #6
 132:	2001      	movs	r0, #1
 134:	f000 f87a 	bl	22c <GPIO_Clr>
        Delay(60000);  
 138:	4b06      	ldr	r3, [pc, #24]	@ (154 <main+0x94>)
 13a:	0018      	movs	r0, r3
 13c:	f000 f80c 	bl	158 <Delay>
        GPIO_Set(1, 6u);
 140:	46c0      	nop			@ (mov r8, r8)
 142:	e7ed      	b.n	120 <main+0x60>
 144:	000006c8 	.word	0x000006c8
 148:	000006ec 	.word	0x000006ec
 14c:	000006d4 	.word	0x000006d4
 150:	000006e0 	.word	0x000006e0
 154:	0000ea60 	.word	0x0000ea60

00000158 <Delay>:
    }
    return 0;
}

void Delay(int32_t delayNumber)
{
 158:	b580      	push	{r7, lr}
 15a:	b084      	sub	sp, #16
 15c:	af00      	add	r7, sp, #0
 15e:	6078      	str	r0, [r7, #4]
    for(int32_t i=0; i<delayNumber; i++);
 160:	2300      	movs	r3, #0
 162:	60fb      	str	r3, [r7, #12]
 164:	e002      	b.n	16c <Delay+0x14>
 166:	68fb      	ldr	r3, [r7, #12]
 168:	3301      	adds	r3, #1
 16a:	60fb      	str	r3, [r7, #12]
 16c:	68fa      	ldr	r2, [r7, #12]
 16e:	687b      	ldr	r3, [r7, #4]
 170:	429a      	cmp	r2, r3
 172:	dbf8      	blt.n	166 <Delay+0xe>
    for(int32_t i=0; i<delayNumber; i++);
 174:	2300      	movs	r3, #0
 176:	60bb      	str	r3, [r7, #8]
 178:	e002      	b.n	180 <Delay+0x28>
 17a:	68bb      	ldr	r3, [r7, #8]
 17c:	3301      	adds	r3, #1
 17e:	60bb      	str	r3, [r7, #8]
 180:	68ba      	ldr	r2, [r7, #8]
 182:	687b      	ldr	r3, [r7, #4]
 184:	429a      	cmp	r2, r3
 186:	dbf8      	blt.n	17a <Delay+0x22>
}
 188:	46c0      	nop			@ (mov r8, r8)
 18a:	46c0      	nop			@ (mov r8, r8)
 18c:	46bd      	mov	sp, r7
 18e:	b004      	add	sp, #16
 190:	bd80      	pop	{r7, pc}

00000192 <ioss_interrupts_gpio_3_IRQHandler>:

void ioss_interrupts_gpio_3_IRQHandler(void)
{
 192:	b580      	push	{r7, lr}
 194:	af00      	add	r7, sp, #0

    GPIO_ClearInterrupt(3, 7u);
 196:	2107      	movs	r1, #7
 198:	2003      	movs	r0, #3
 19a:	f000 f981 	bl	4a0 <GPIO_ClearInterrupt>
    Delay(20000);
 19e:	4b08      	ldr	r3, [pc, #32]	@ (1c0 <ioss_interrupts_gpio_3_IRQHandler+0x2e>)
 1a0:	0018      	movs	r0, r3
 1a2:	f7ff ffd9 	bl	158 <Delay>

    if((GPIO_Read(3, 7u) == 0u))
 1a6:	2107      	movs	r1, #7
 1a8:	2003      	movs	r0, #3
 1aa:	f000 f873 	bl	294 <GPIO_Read>
 1ae:	1e03      	subs	r3, r0, #0
 1b0:	d103      	bne.n	1ba <ioss_interrupts_gpio_3_IRQHandler+0x28>
    {
        GPIO_Inv(2, 2u);
 1b2:	2102      	movs	r1, #2
 1b4:	2002      	movs	r0, #2
 1b6:	f000 f853 	bl	260 <GPIO_Inv>
    }  

}
 1ba:	46c0      	nop			@ (mov r8, r8)
 1bc:	46bd      	mov	sp, r7
 1be:	bd80      	pop	{r7, pc}
 1c0:	00004e20 	.word	0x00004e20

000001c4 <ioss_interrupts_gpio_2_IRQHandler>:

void ioss_interrupts_gpio_2_IRQHandler(void)
{
 1c4:	b580      	push	{r7, lr}
 1c6:	af00      	add	r7, sp, #0

    GPIO_ClearInterrupt(2, 0u);
 1c8:	2100      	movs	r1, #0
 1ca:	2002      	movs	r0, #2
 1cc:	f000 f968 	bl	4a0 <GPIO_ClearInterrupt>
    Delay(20000);
 1d0:	4b08      	ldr	r3, [pc, #32]	@ (1f4 <ioss_interrupts_gpio_2_IRQHandler+0x30>)
 1d2:	0018      	movs	r0, r3
 1d4:	f7ff ffc0 	bl	158 <Delay>

    if((GPIO_Read(2, 0u) == 0u))
 1d8:	2100      	movs	r1, #0
 1da:	2002      	movs	r0, #2
 1dc:	f000 f85a 	bl	294 <GPIO_Read>
 1e0:	1e03      	subs	r3, r0, #0
 1e2:	d103      	bne.n	1ec <ioss_interrupts_gpio_2_IRQHandler+0x28>
    {
        GPIO_Inv(2, 2u);
 1e4:	2102      	movs	r1, #2
 1e6:	2002      	movs	r0, #2
 1e8:	f000 f83a 	bl	260 <GPIO_Inv>
    }  

 1ec:	46c0      	nop			@ (mov r8, r8)
 1ee:	46bd      	mov	sp, r7
 1f0:	bd80      	pop	{r7, pc}
 1f2:	46c0      	nop			@ (mov r8, r8)
 1f4:	00004e20 	.word	0x00004e20

000001f8 <GPIO_Set>:
#include <stdint.h>
#include "gpio.h"

void GPIO_Set(uint8_t portNum, uint32_t pinNum)
{
 1f8:	b580      	push	{r7, lr}
 1fa:	b084      	sub	sp, #16
 1fc:	af00      	add	r7, sp, #0
 1fe:	0002      	movs	r2, r0
 200:	6039      	str	r1, [r7, #0]
 202:	1dfb      	adds	r3, r7, #7
 204:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = (GPIO_PRT_Type*)(0x40040000UL + (0x00000100UL * portNum));
 206:	1dfb      	adds	r3, r7, #7
 208:	781b      	ldrb	r3, [r3, #0]
 20a:	4a07      	ldr	r2, [pc, #28]	@ (228 <__HEAP_SIZE+0x28>)
 20c:	4694      	mov	ip, r2
 20e:	4463      	add	r3, ip
 210:	021b      	lsls	r3, r3, #8
 212:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_SET(base) = GPIO_DR_MASK << pinNum;
 214:	2201      	movs	r2, #1
 216:	683b      	ldr	r3, [r7, #0]
 218:	409a      	lsls	r2, r3
 21a:	68fb      	ldr	r3, [r7, #12]
 21c:	641a      	str	r2, [r3, #64]	@ 0x40
}
 21e:	46c0      	nop			@ (mov r8, r8)
 220:	46bd      	mov	sp, r7
 222:	b004      	add	sp, #16
 224:	bd80      	pop	{r7, pc}
 226:	46c0      	nop			@ (mov r8, r8)
 228:	00400400 	.word	0x00400400

0000022c <GPIO_Clr>:

void GPIO_Clr(uint8_t portNum, uint32_t pinNum)
{
 22c:	b580      	push	{r7, lr}
 22e:	b084      	sub	sp, #16
 230:	af00      	add	r7, sp, #0
 232:	0002      	movs	r2, r0
 234:	6039      	str	r1, [r7, #0]
 236:	1dfb      	adds	r3, r7, #7
 238:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = (GPIO_PRT_Type*)(0x40040000UL + (0x00000100UL * portNum));
 23a:	1dfb      	adds	r3, r7, #7
 23c:	781b      	ldrb	r3, [r3, #0]
 23e:	4a07      	ldr	r2, [pc, #28]	@ (25c <GPIO_Clr+0x30>)
 240:	4694      	mov	ip, r2
 242:	4463      	add	r3, ip
 244:	021b      	lsls	r3, r3, #8
 246:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_CLR(base) = GPIO_DR_MASK << pinNum;
 248:	2201      	movs	r2, #1
 24a:	683b      	ldr	r3, [r7, #0]
 24c:	409a      	lsls	r2, r3
 24e:	68fb      	ldr	r3, [r7, #12]
 250:	645a      	str	r2, [r3, #68]	@ 0x44
}
 252:	46c0      	nop			@ (mov r8, r8)
 254:	46bd      	mov	sp, r7
 256:	b004      	add	sp, #16
 258:	bd80      	pop	{r7, pc}
 25a:	46c0      	nop			@ (mov r8, r8)
 25c:	00400400 	.word	0x00400400

00000260 <GPIO_Inv>:

void GPIO_Inv(uint8_t portNum, uint32_t pinNum)
{
 260:	b580      	push	{r7, lr}
 262:	b084      	sub	sp, #16
 264:	af00      	add	r7, sp, #0
 266:	0002      	movs	r2, r0
 268:	6039      	str	r1, [r7, #0]
 26a:	1dfb      	adds	r3, r7, #7
 26c:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = (GPIO_PRT_Type*)(0x40040000UL + (0x00000100UL * portNum));
 26e:	1dfb      	adds	r3, r7, #7
 270:	781b      	ldrb	r3, [r3, #0]
 272:	4a07      	ldr	r2, [pc, #28]	@ (290 <GPIO_Inv+0x30>)
 274:	4694      	mov	ip, r2
 276:	4463      	add	r3, ip
 278:	021b      	lsls	r3, r3, #8
 27a:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_INV(base) = GPIO_DR_MASK << pinNum;
 27c:	2201      	movs	r2, #1
 27e:	683b      	ldr	r3, [r7, #0]
 280:	409a      	lsls	r2, r3
 282:	68fb      	ldr	r3, [r7, #12]
 284:	649a      	str	r2, [r3, #72]	@ 0x48
}
 286:	46c0      	nop			@ (mov r8, r8)
 288:	46bd      	mov	sp, r7
 28a:	b004      	add	sp, #16
 28c:	bd80      	pop	{r7, pc}
 28e:	46c0      	nop			@ (mov r8, r8)
 290:	00400400 	.word	0x00400400

00000294 <GPIO_Read>:

uint32_t GPIO_Read(uint8_t portNum, uint32_t pinNum)
{
 294:	b580      	push	{r7, lr}
 296:	b084      	sub	sp, #16
 298:	af00      	add	r7, sp, #0
 29a:	0002      	movs	r2, r0
 29c:	6039      	str	r1, [r7, #0]
 29e:	1dfb      	adds	r3, r7, #7
 2a0:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = (GPIO_PRT_Type*)(0x40040000UL + (0x00000100UL * portNum));
 2a2:	1dfb      	adds	r3, r7, #7
 2a4:	781b      	ldrb	r3, [r3, #0]
 2a6:	4a08      	ldr	r2, [pc, #32]	@ (2c8 <GPIO_Read+0x34>)
 2a8:	4694      	mov	ip, r2
 2aa:	4463      	add	r3, ip
 2ac:	021b      	lsls	r3, r3, #8
 2ae:	60fb      	str	r3, [r7, #12]
    return (GPIO_PRT_IN(base) >> (pinNum)) & GPIO_PS_MASK;
 2b0:	68fb      	ldr	r3, [r7, #12]
 2b2:	685a      	ldr	r2, [r3, #4]
 2b4:	683b      	ldr	r3, [r7, #0]
 2b6:	40da      	lsrs	r2, r3
 2b8:	0013      	movs	r3, r2
 2ba:	2201      	movs	r2, #1
 2bc:	4013      	ands	r3, r2
}
 2be:	0018      	movs	r0, r3
 2c0:	46bd      	mov	sp, r7
 2c2:	b004      	add	sp, #16
 2c4:	bd80      	pop	{r7, pc}
 2c6:	46c0      	nop			@ (mov r8, r8)
 2c8:	00400400 	.word	0x00400400

000002cc <GPIO_SetDrivemode>:

void GPIO_SetDrivemode(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 2cc:	b580      	push	{r7, lr}
 2ce:	b088      	sub	sp, #32
 2d0:	af00      	add	r7, sp, #0
 2d2:	60b9      	str	r1, [r7, #8]
 2d4:	607a      	str	r2, [r7, #4]
 2d6:	210f      	movs	r1, #15
 2d8:	187b      	adds	r3, r7, r1
 2da:	1c02      	adds	r2, r0, #0
 2dc:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = (GPIO_PRT_Type*)(0x40040000UL + (0x00000100UL * portNum));
 2de:	187b      	adds	r3, r7, r1
 2e0:	781b      	ldrb	r3, [r3, #0]
 2e2:	4a19      	ldr	r2, [pc, #100]	@ (348 <GPIO_SetDrivemode+0x7c>)
 2e4:	4694      	mov	ip, r2
 2e6:	4463      	add	r3, ip
 2e8:	021b      	lsls	r3, r3, #8
 2ea:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum * GPIO_DRIVE_MODE_OFFSET;
 2ec:	68ba      	ldr	r2, [r7, #8]
 2ee:	0013      	movs	r3, r2
 2f0:	005b      	lsls	r3, r3, #1
 2f2:	189b      	adds	r3, r3, r2
 2f4:	61bb      	str	r3, [r7, #24]
    tempReg = ((((GPIO_PRT_Type*)(base))->PC) & ~(GPIO_PC_DM_MASK << pinLoc));
 2f6:	69fb      	ldr	r3, [r7, #28]
 2f8:	689b      	ldr	r3, [r3, #8]
 2fa:	2107      	movs	r1, #7
 2fc:	69ba      	ldr	r2, [r7, #24]
 2fe:	4091      	lsls	r1, r2
 300:	000a      	movs	r2, r1
 302:	43d2      	mvns	r2, r2
 304:	4013      	ands	r3, r2
 306:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC) = tempReg | ((value & GPIO_PC_DM_MASK) << pinLoc);
 308:	687b      	ldr	r3, [r7, #4]
 30a:	2207      	movs	r2, #7
 30c:	401a      	ands	r2, r3
 30e:	69bb      	ldr	r3, [r7, #24]
 310:	409a      	lsls	r2, r3
 312:	697b      	ldr	r3, [r7, #20]
 314:	431a      	orrs	r2, r3
 316:	69fb      	ldr	r3, [r7, #28]
 318:	609a      	str	r2, [r3, #8]

    tempReg = ((((GPIO_PRT_Type*)(base))->PC2) & ~(GPIO_PC_DM_IBUF_MASK << pinNum));
 31a:	69fb      	ldr	r3, [r7, #28]
 31c:	699b      	ldr	r3, [r3, #24]
 31e:	2101      	movs	r1, #1
 320:	68ba      	ldr	r2, [r7, #8]
 322:	4091      	lsls	r1, r2
 324:	000a      	movs	r2, r1
 326:	43d2      	mvns	r2, r2
 328:	4013      	ands	r3, r2
 32a:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC2) = tempReg | (((value & GPIO_DM_VAL_IBUF_DISABLE_MASK) >> GPIO_DRIVE_MODE_OFFSET) << pinNum);
 32c:	687b      	ldr	r3, [r7, #4]
 32e:	08db      	lsrs	r3, r3, #3
 330:	2201      	movs	r2, #1
 332:	401a      	ands	r2, r3
 334:	68bb      	ldr	r3, [r7, #8]
 336:	409a      	lsls	r2, r3
 338:	697b      	ldr	r3, [r7, #20]
 33a:	431a      	orrs	r2, r3
 33c:	69fb      	ldr	r3, [r7, #28]
 33e:	619a      	str	r2, [r3, #24]
}
 340:	46c0      	nop			@ (mov r8, r8)
 342:	46bd      	mov	sp, r7
 344:	b008      	add	sp, #32
 346:	bd80      	pop	{r7, pc}
 348:	00400400 	.word	0x00400400

0000034c <GPIO_SetHSIOM>:


void GPIO_SetHSIOM(uint8_t gpioportNum, uint32_t pinNum, uint8_t value)
{
 34c:	b580      	push	{r7, lr}
 34e:	b086      	sub	sp, #24
 350:	af00      	add	r7, sp, #0
 352:	6039      	str	r1, [r7, #0]
 354:	0011      	movs	r1, r2
 356:	1dfb      	adds	r3, r7, #7
 358:	1c02      	adds	r2, r0, #0
 35a:	701a      	strb	r2, [r3, #0]
 35c:	1dbb      	adds	r3, r7, #6
 35e:	1c0a      	adds	r2, r1, #0
 360:	701a      	strb	r2, [r3, #0]
    uint32_t portNum;
    uint32_t tempReg;
    HSIOM_PRT_Type* portAddrHSIOM;
    GPIO_PRT_Type* base;
    
    base = (GPIO_PRT_Type*)(0x40040000UL + (0x00000100UL * gpioportNum));
 362:	1dfb      	adds	r3, r7, #7
 364:	781b      	ldrb	r3, [r3, #0]
 366:	4a15      	ldr	r2, [pc, #84]	@ (3bc <GPIO_SetHSIOM+0x70>)
 368:	4694      	mov	ip, r2
 36a:	4463      	add	r3, ip
 36c:	021b      	lsls	r3, r3, #8
 36e:	617b      	str	r3, [r7, #20]

    portNum = ((uint32_t)(base) - 0x40040000UL) / 0x00000100UL;
 370:	697b      	ldr	r3, [r7, #20]
 372:	4a13      	ldr	r2, [pc, #76]	@ (3c0 <GPIO_SetHSIOM+0x74>)
 374:	4694      	mov	ip, r2
 376:	4463      	add	r3, ip
 378:	0a1b      	lsrs	r3, r3, #8
 37a:	613b      	str	r3, [r7, #16]
    portAddrHSIOM = (HSIOM_PRT_Type*)(0x40020000UL + (0x00000100UL * portNum));
 37c:	693b      	ldr	r3, [r7, #16]
 37e:	4a11      	ldr	r2, [pc, #68]	@ (3c4 <GPIO_SetHSIOM+0x78>)
 380:	4694      	mov	ip, r2
 382:	4463      	add	r3, ip
 384:	021b      	lsls	r3, r3, #8
 386:	60fb      	str	r3, [r7, #12]

    tempReg = (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) & ~(GPIO_HSIOM_MASK << (pinNum << GPIO_HSIOM_OFFSET));
 388:	68fb      	ldr	r3, [r7, #12]
 38a:	681b      	ldr	r3, [r3, #0]
 38c:	683a      	ldr	r2, [r7, #0]
 38e:	0092      	lsls	r2, r2, #2
 390:	210f      	movs	r1, #15
 392:	4091      	lsls	r1, r2
 394:	000a      	movs	r2, r1
 396:	43d2      	mvns	r2, r2
 398:	4013      	ands	r3, r2
 39a:	60bb      	str	r3, [r7, #8]
    (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) = tempReg | (( (uint32_t) value & GPIO_HSIOM_MASK) << (pinNum << GPIO_HSIOM_OFFSET));
 39c:	1dbb      	adds	r3, r7, #6
 39e:	781b      	ldrb	r3, [r3, #0]
 3a0:	220f      	movs	r2, #15
 3a2:	401a      	ands	r2, r3
 3a4:	683b      	ldr	r3, [r7, #0]
 3a6:	009b      	lsls	r3, r3, #2
 3a8:	409a      	lsls	r2, r3
 3aa:	68bb      	ldr	r3, [r7, #8]
 3ac:	431a      	orrs	r2, r3
 3ae:	68fb      	ldr	r3, [r7, #12]
 3b0:	601a      	str	r2, [r3, #0]
}
 3b2:	46c0      	nop			@ (mov r8, r8)
 3b4:	46bd      	mov	sp, r7
 3b6:	b006      	add	sp, #24
 3b8:	bd80      	pop	{r7, pc}
 3ba:	46c0      	nop			@ (mov r8, r8)
 3bc:	00400400 	.word	0x00400400
 3c0:	bffc0000 	.word	0xbffc0000
 3c4:	00400200 	.word	0x00400200

000003c8 <GPIO_SetInterruptEdge>:

void GPIO_SetInterruptEdge(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 3c8:	b580      	push	{r7, lr}
 3ca:	b088      	sub	sp, #32
 3cc:	af00      	add	r7, sp, #0
 3ce:	60b9      	str	r1, [r7, #8]
 3d0:	607a      	str	r2, [r7, #4]
 3d2:	210f      	movs	r1, #15
 3d4:	187b      	adds	r3, r7, r1
 3d6:	1c02      	adds	r2, r0, #0
 3d8:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = (GPIO_PRT_Type*)(0x40040000UL + (0x00000100UL * portNum));
 3da:	187b      	adds	r3, r7, r1
 3dc:	781b      	ldrb	r3, [r3, #0]
 3de:	4a0f      	ldr	r2, [pc, #60]	@ (41c <GPIO_SetInterruptEdge+0x54>)
 3e0:	4694      	mov	ip, r2
 3e2:	4463      	add	r3, ip
 3e4:	021b      	lsls	r3, r3, #8
 3e6:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum << 0x1u;
 3e8:	68bb      	ldr	r3, [r7, #8]
 3ea:	005b      	lsls	r3, r3, #1
 3ec:	61bb      	str	r3, [r7, #24]
    tempReg = (((GPIO_PRT_Type*)(base))->INTR_CFG) & ~(0x3u << pinLoc);
 3ee:	69fb      	ldr	r3, [r7, #28]
 3f0:	68db      	ldr	r3, [r3, #12]
 3f2:	2103      	movs	r1, #3
 3f4:	69ba      	ldr	r2, [r7, #24]
 3f6:	4091      	lsls	r1, r2
 3f8:	000a      	movs	r2, r1
 3fa:	43d2      	mvns	r2, r2
 3fc:	4013      	ands	r3, r2
 3fe:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->INTR_CFG) = tempReg | ((value & 0x3u) << pinLoc);
 400:	687b      	ldr	r3, [r7, #4]
 402:	2203      	movs	r2, #3
 404:	401a      	ands	r2, r3
 406:	69bb      	ldr	r3, [r7, #24]
 408:	409a      	lsls	r2, r3
 40a:	697b      	ldr	r3, [r7, #20]
 40c:	431a      	orrs	r2, r3
 40e:	69fb      	ldr	r3, [r7, #28]
 410:	60da      	str	r2, [r3, #12]
}
 412:	46c0      	nop			@ (mov r8, r8)
 414:	46bd      	mov	sp, r7
 416:	b008      	add	sp, #32
 418:	bd80      	pop	{r7, pc}
 41a:	46c0      	nop			@ (mov r8, r8)
 41c:	00400400 	.word	0x00400400

00000420 <GPIO_Pin_Init>:

void GPIO_Pin_Init(uint8_t portNum, uint32_t pinNum, const gpio_pin_config_t *config, uint8_t hsiom)
{
 420:	b590      	push	{r4, r7, lr}
 422:	b085      	sub	sp, #20
 424:	af00      	add	r7, sp, #0
 426:	60b9      	str	r1, [r7, #8]
 428:	607a      	str	r2, [r7, #4]
 42a:	0019      	movs	r1, r3
 42c:	240f      	movs	r4, #15
 42e:	193b      	adds	r3, r7, r4
 430:	1c02      	adds	r2, r0, #0
 432:	701a      	strb	r2, [r3, #0]
 434:	230e      	movs	r3, #14
 436:	18fb      	adds	r3, r7, r3
 438:	1c0a      	adds	r2, r1, #0
 43a:	701a      	strb	r2, [r3, #0]
    ((config -> outVal) == 0) ? GPIO_Clr(portNum, pinNum) : GPIO_Set(portNum,pinNum);
 43c:	687b      	ldr	r3, [r7, #4]
 43e:	681b      	ldr	r3, [r3, #0]
 440:	2b00      	cmp	r3, #0
 442:	d107      	bne.n	454 <GPIO_Pin_Init+0x34>
 444:	68ba      	ldr	r2, [r7, #8]
 446:	193b      	adds	r3, r7, r4
 448:	781b      	ldrb	r3, [r3, #0]
 44a:	0011      	movs	r1, r2
 44c:	0018      	movs	r0, r3
 44e:	f7ff feed 	bl	22c <GPIO_Clr>
 452:	e007      	b.n	464 <GPIO_Pin_Init+0x44>
 454:	68ba      	ldr	r2, [r7, #8]
 456:	230f      	movs	r3, #15
 458:	18fb      	adds	r3, r7, r3
 45a:	781b      	ldrb	r3, [r3, #0]
 45c:	0011      	movs	r1, r2
 45e:	0018      	movs	r0, r3
 460:	f7ff feca 	bl	1f8 <GPIO_Set>
    GPIO_SetDrivemode(portNum, pinNum, config->driveMode);
 464:	687b      	ldr	r3, [r7, #4]
 466:	685a      	ldr	r2, [r3, #4]
 468:	68b9      	ldr	r1, [r7, #8]
 46a:	240f      	movs	r4, #15
 46c:	193b      	adds	r3, r7, r4
 46e:	781b      	ldrb	r3, [r3, #0]
 470:	0018      	movs	r0, r3
 472:	f7ff ff2b 	bl	2cc <GPIO_SetDrivemode>
    GPIO_SetHSIOM(portNum, pinNum, hsiom);
 476:	230e      	movs	r3, #14
 478:	18fb      	adds	r3, r7, r3
 47a:	781a      	ldrb	r2, [r3, #0]
 47c:	68b9      	ldr	r1, [r7, #8]
 47e:	193b      	adds	r3, r7, r4
 480:	781b      	ldrb	r3, [r3, #0]
 482:	0018      	movs	r0, r3
 484:	f7ff ff62 	bl	34c <GPIO_SetHSIOM>
    GPIO_SetInterruptEdge(portNum, pinNum, config->intEdge);
 488:	687b      	ldr	r3, [r7, #4]
 48a:	689a      	ldr	r2, [r3, #8]
 48c:	68b9      	ldr	r1, [r7, #8]
 48e:	193b      	adds	r3, r7, r4
 490:	781b      	ldrb	r3, [r3, #0]
 492:	0018      	movs	r0, r3
 494:	f7ff ff98 	bl	3c8 <GPIO_SetInterruptEdge>
}
 498:	46c0      	nop			@ (mov r8, r8)
 49a:	46bd      	mov	sp, r7
 49c:	b005      	add	sp, #20
 49e:	bd90      	pop	{r4, r7, pc}

000004a0 <GPIO_ClearInterrupt>:

void GPIO_ClearInterrupt(uint8_t portNum, uint32_t pinNum)
{
 4a0:	b580      	push	{r7, lr}
 4a2:	b084      	sub	sp, #16
 4a4:	af00      	add	r7, sp, #0
 4a6:	0002      	movs	r2, r0
 4a8:	6039      	str	r1, [r7, #0]
 4aa:	1dfb      	adds	r3, r7, #7
 4ac:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = (GPIO_PRT_Type*)(0x40040000UL + (0x00000100UL * portNum));
 4ae:	1dfb      	adds	r3, r7, #7
 4b0:	781b      	ldrb	r3, [r3, #0]
 4b2:	4a09      	ldr	r2, [pc, #36]	@ (4d8 <GPIO_ClearInterrupt+0x38>)
 4b4:	4694      	mov	ip, r2
 4b6:	4463      	add	r3, ip
 4b8:	021b      	lsls	r3, r3, #8
 4ba:	60fb      	str	r3, [r7, #12]
    /* Any INTR MMIO registers AHB clearing must be preceded with an AHB read access */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 4bc:	68fb      	ldr	r3, [r7, #12]
 4be:	691b      	ldr	r3, [r3, #16]

    (((GPIO_PRT_Type*)(base))->INTR) = (0x01UL) << pinNum;
 4c0:	2201      	movs	r2, #1
 4c2:	683b      	ldr	r3, [r7, #0]
 4c4:	409a      	lsls	r2, r3
 4c6:	68fb      	ldr	r3, [r7, #12]
 4c8:	611a      	str	r2, [r3, #16]

    /* This read ensures that the initial write has been flushed out to the hardware */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 4ca:	68fb      	ldr	r3, [r7, #12]
 4cc:	691b      	ldr	r3, [r3, #16]
 4ce:	46c0      	nop			@ (mov r8, r8)
 4d0:	46bd      	mov	sp, r7
 4d2:	b004      	add	sp, #16
 4d4:	bd80      	pop	{r7, pc}
 4d6:	46c0      	nop			@ (mov r8, r8)
 4d8:	00400400 	.word	0x00400400

000004dc <enable_irq>:
#include "cmsis_gcc.h"
#include <stdint.h>

void enable_irq(void)
{
 4dc:	b580      	push	{r7, lr}
 4de:	af00      	add	r7, sp, #0
  __asm volatile ("cpsie i" : : : "memory");
 4e0:	b662      	cpsie	i
}
 4e2:	46c0      	nop			@ (mov r8, r8)
 4e4:	46bd      	mov	sp, r7
 4e6:	bd80      	pop	{r7, pc}

000004e8 <NVIC_SetPriority>:

void NVIC_SetPriority(uint32_t IRQn, uint32_t priority)
{
 4e8:	b580      	push	{r7, lr}
 4ea:	b082      	sub	sp, #8
 4ec:	af00      	add	r7, sp, #0
 4ee:	6078      	str	r0, [r7, #4]
 4f0:	6039      	str	r1, [r7, #0]
  if ((int32_t)(IRQn) >= 0)
 4f2:	687b      	ldr	r3, [r7, #4]
 4f4:	2b00      	cmp	r3, #0
 4f6:	db1f      	blt.n	538 <NVIC_SetPriority+0x50>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 4f8:	4a11      	ldr	r2, [pc, #68]	@ (540 <NVIC_SetPriority+0x58>)
 4fa:	687b      	ldr	r3, [r7, #4]
 4fc:	089b      	lsrs	r3, r3, #2
 4fe:	33c0      	adds	r3, #192	@ 0xc0
 500:	009b      	lsls	r3, r3, #2
 502:	589b      	ldr	r3, [r3, r2]
 504:	687a      	ldr	r2, [r7, #4]
 506:	2103      	movs	r1, #3
 508:	400a      	ands	r2, r1
 50a:	00d2      	lsls	r2, r2, #3
 50c:	21ff      	movs	r1, #255	@ 0xff
 50e:	4091      	lsls	r1, r2
 510:	000a      	movs	r2, r1
 512:	43d2      	mvns	r2, r2
 514:	401a      	ands	r2, r3
 516:	0011      	movs	r1, r2
       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 518:	683b      	ldr	r3, [r7, #0]
 51a:	019b      	lsls	r3, r3, #6
 51c:	22ff      	movs	r2, #255	@ 0xff
 51e:	401a      	ands	r2, r3
 520:	687b      	ldr	r3, [r7, #4]
 522:	2003      	movs	r0, #3
 524:	4003      	ands	r3, r0
 526:	00db      	lsls	r3, r3, #3
 528:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 52a:	4805      	ldr	r0, [pc, #20]	@ (540 <NVIC_SetPriority+0x58>)
 52c:	687b      	ldr	r3, [r7, #4]
 52e:	089b      	lsrs	r3, r3, #2
 530:	430a      	orrs	r2, r1
 532:	33c0      	adds	r3, #192	@ 0xc0
 534:	009b      	lsls	r3, r3, #2
 536:	501a      	str	r2, [r3, r0]
  }

}
 538:	46c0      	nop			@ (mov r8, r8)
 53a:	46bd      	mov	sp, r7
 53c:	b002      	add	sp, #8
 53e:	bd80      	pop	{r7, pc}
 540:	e000e100 	.word	0xe000e100

00000544 <NVIC_ClearPendingIRQ>:

void NVIC_ClearPendingIRQ(uint32_t IRQn)
{
 544:	b580      	push	{r7, lr}
 546:	b082      	sub	sp, #8
 548:	af00      	add	r7, sp, #0
 54a:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 54c:	687b      	ldr	r3, [r7, #4]
 54e:	2b00      	cmp	r3, #0
 550:	db08      	blt.n	564 <NVIC_ClearPendingIRQ+0x20>
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 552:	687b      	ldr	r3, [r7, #4]
 554:	221f      	movs	r2, #31
 556:	4013      	ands	r3, r2
 558:	4904      	ldr	r1, [pc, #16]	@ (56c <NVIC_ClearPendingIRQ+0x28>)
 55a:	2201      	movs	r2, #1
 55c:	409a      	lsls	r2, r3
 55e:	23c0      	movs	r3, #192	@ 0xc0
 560:	005b      	lsls	r3, r3, #1
 562:	50ca      	str	r2, [r1, r3]
  }
}
 564:	46c0      	nop			@ (mov r8, r8)
 566:	46bd      	mov	sp, r7
 568:	b002      	add	sp, #8
 56a:	bd80      	pop	{r7, pc}
 56c:	e000e100 	.word	0xe000e100

00000570 <NVIC_EnableIRQ>:

void NVIC_EnableIRQ(uint32_t IRQn)
{
 570:	b580      	push	{r7, lr}
 572:	b082      	sub	sp, #8
 574:	af00      	add	r7, sp, #0
 576:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 578:	687b      	ldr	r3, [r7, #4]
 57a:	2b00      	cmp	r3, #0
 57c:	db07      	blt.n	58e <NVIC_EnableIRQ+0x1e>
  {
    __asm volatile("":::"memory");
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 57e:	687b      	ldr	r3, [r7, #4]
 580:	221f      	movs	r2, #31
 582:	401a      	ands	r2, r3
 584:	4b04      	ldr	r3, [pc, #16]	@ (598 <NVIC_EnableIRQ+0x28>)
 586:	2101      	movs	r1, #1
 588:	4091      	lsls	r1, r2
 58a:	000a      	movs	r2, r1
 58c:	601a      	str	r2, [r3, #0]
    __asm volatile("":::"memory");
  }
}
 58e:	46c0      	nop			@ (mov r8, r8)
 590:	46bd      	mov	sp, r7
 592:	b002      	add	sp, #8
 594:	bd80      	pop	{r7, pc}
 596:	46c0      	nop			@ (mov r8, r8)
 598:	e000e100 	.word	0xe000e100

0000059c <NVIC_DisableIRQ>:

void NVIC_DisableIRQ(uint32_t IRQn)
{
 59c:	b580      	push	{r7, lr}
 59e:	b082      	sub	sp, #8
 5a0:	af00      	add	r7, sp, #0
 5a2:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 5a4:	687b      	ldr	r3, [r7, #4]
 5a6:	2b00      	cmp	r3, #0
 5a8:	db0c      	blt.n	5c4 <NVIC_DisableIRQ+0x28>
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 5aa:	687b      	ldr	r3, [r7, #4]
 5ac:	221f      	movs	r2, #31
 5ae:	4013      	ands	r3, r2
 5b0:	4906      	ldr	r1, [pc, #24]	@ (5cc <NVIC_DisableIRQ+0x30>)
 5b2:	2201      	movs	r2, #1
 5b4:	409a      	lsls	r2, r3
 5b6:	0013      	movs	r3, r2
 5b8:	2280      	movs	r2, #128	@ 0x80
 5ba:	508b      	str	r3, [r1, r2]
    __asm volatile ("dsb 0xF":::"memory");
 5bc:	f3bf 8f4f 	dsb	sy
    __asm volatile ("isb 0xF":::"memory");
 5c0:	f3bf 8f6f 	isb	sy
  }
 5c4:	46c0      	nop			@ (mov r8, r8)
 5c6:	46bd      	mov	sp, r7
 5c8:	b002      	add	sp, #8
 5ca:	bd80      	pop	{r7, pc}
 5cc:	e000e100 	.word	0xe000e100

000005d0 <_init>:

extern uint32_t __stack_Start__;
extern uint32_t __STACK_START;
extern uint32_t __STACK_END;

extern void _init(void) {;}
 5d0:	b580      	push	{r7, lr}
 5d2:	af00      	add	r7, sp, #0
 5d4:	46c0      	nop			@ (mov r8, r8)
 5d6:	46bd      	mov	sp, r7
 5d8:	bd80      	pop	{r7, pc}

000005da <Reset_handler>:
    (uint32_t)can_interrupt_can_IRQHandler,             /*  26 CAN Interrupt */
    (uint32_t)crypto_interrupt_IRQHandler               /*  27 Crypto Interrupt */
};

void Reset_handler(void)
{
 5da:	b580      	push	{r7, lr}
 5dc:	b086      	sub	sp, #24
 5de:	af00      	add	r7, sp, #0
    //disable watchdog
    (*(uint32_t *) CYREG_WDT_DISABLE_KEY) = CY_SYS_WDT_KEY;
 5e0:	4b1c      	ldr	r3, [pc, #112]	@ (654 <Reset_handler+0x7a>)
 5e2:	4a1d      	ldr	r2, [pc, #116]	@ (658 <Reset_handler+0x7e>)
 5e4:	601a      	str	r2, [r3, #0]

    //copy .data section to SRAM
    uint32_t size = &__data_end - &__data_start;
 5e6:	4a1d      	ldr	r2, [pc, #116]	@ (65c <Reset_handler+0x82>)
 5e8:	4b1d      	ldr	r3, [pc, #116]	@ (660 <Reset_handler+0x86>)
 5ea:	1ad3      	subs	r3, r2, r3
 5ec:	109b      	asrs	r3, r3, #2
 5ee:	607b      	str	r3, [r7, #4]
    uint32_t *pDst = (uint32_t*)&__data_start;
 5f0:	4b1b      	ldr	r3, [pc, #108]	@ (660 <Reset_handler+0x86>)
 5f2:	617b      	str	r3, [r7, #20]
    uint32_t *pSrc = (uint32_t*)&_la_data;
 5f4:	4b1b      	ldr	r3, [pc, #108]	@ (664 <Reset_handler+0x8a>)
 5f6:	613b      	str	r3, [r7, #16]

    for(uint32_t i = 0; i< size; i++)
 5f8:	2300      	movs	r3, #0
 5fa:	60fb      	str	r3, [r7, #12]
 5fc:	e00a      	b.n	614 <Reset_handler+0x3a>
    {
        *pDst++ = *pSrc++;
 5fe:	693a      	ldr	r2, [r7, #16]
 600:	1d13      	adds	r3, r2, #4
 602:	613b      	str	r3, [r7, #16]
 604:	697b      	ldr	r3, [r7, #20]
 606:	1d19      	adds	r1, r3, #4
 608:	6179      	str	r1, [r7, #20]
 60a:	6812      	ldr	r2, [r2, #0]
 60c:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 60e:	68fb      	ldr	r3, [r7, #12]
 610:	3301      	adds	r3, #1
 612:	60fb      	str	r3, [r7, #12]
 614:	68fa      	ldr	r2, [r7, #12]
 616:	687b      	ldr	r3, [r7, #4]
 618:	429a      	cmp	r2, r3
 61a:	d3f0      	bcc.n	5fe <Reset_handler+0x24>
    }
    //int the .bss section to zero in SRAM
    size = &__bss_end__ - &__bss_start__;
 61c:	4a12      	ldr	r2, [pc, #72]	@ (668 <Reset_handler+0x8e>)
 61e:	4b13      	ldr	r3, [pc, #76]	@ (66c <Reset_handler+0x92>)
 620:	1ad3      	subs	r3, r2, r3
 622:	109b      	asrs	r3, r3, #2
 624:	607b      	str	r3, [r7, #4]
    pDst = (uint32_t*)&__bss_start__;
 626:	4b11      	ldr	r3, [pc, #68]	@ (66c <Reset_handler+0x92>)
 628:	617b      	str	r3, [r7, #20]

    for(uint32_t i = 0; i< size; i++)
 62a:	2300      	movs	r3, #0
 62c:	60bb      	str	r3, [r7, #8]
 62e:	e007      	b.n	640 <Reset_handler+0x66>
    {
        *pDst++ = 0;
 630:	697b      	ldr	r3, [r7, #20]
 632:	1d1a      	adds	r2, r3, #4
 634:	617a      	str	r2, [r7, #20]
 636:	2200      	movs	r2, #0
 638:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 63a:	68bb      	ldr	r3, [r7, #8]
 63c:	3301      	adds	r3, #1
 63e:	60bb      	str	r3, [r7, #8]
 640:	68ba      	ldr	r2, [r7, #8]
 642:	687b      	ldr	r3, [r7, #4]
 644:	429a      	cmp	r2, r3
 646:	d3f3      	bcc.n	630 <Reset_handler+0x56>
    }

    // Init C std libs
    __libc_init_array();
 648:	f000 f81a 	bl	680 <__libc_init_array>

    //call main()
    main();
 64c:	f7ff fd38 	bl	c0 <main>

    while (1)
 650:	46c0      	nop			@ (mov r8, r8)
 652:	e7fd      	b.n	650 <Reset_handler+0x76>
 654:	40030038 	.word	0x40030038
 658:	aced8865 	.word	0xaced8865
 65c:	20000000 	.word	0x20000000
 660:	20000000 	.word	0x20000000
 664:	000006f8 	.word	0x000006f8
 668:	20000000 	.word	0x20000000
 66c:	20000000 	.word	0x20000000

00000670 <Default_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Exceptions / Interrupts
 *----------------------------------------------------------------------------*/
void Default_Handler(void)
{
 670:	b580      	push	{r7, lr}
 672:	af00      	add	r7, sp, #0
    while(1);
 674:	46c0      	nop			@ (mov r8, r8)
 676:	e7fd      	b.n	674 <Default_Handler+0x4>

00000678 <HRDFLT_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Hard Fault
 *----------------------------------------------------------------------------*/
void HRDFLT_Handler(void)
{
 678:	b580      	push	{r7, lr}
 67a:	af00      	add	r7, sp, #0
    while (1)
 67c:	46c0      	nop			@ (mov r8, r8)
 67e:	e7fd      	b.n	67c <HRDFLT_Handler+0x4>

00000680 <__libc_init_array>:
 680:	b570      	push	{r4, r5, r6, lr}
 682:	2600      	movs	r6, #0
 684:	4c0c      	ldr	r4, [pc, #48]	@ (6b8 <__libc_init_array+0x38>)
 686:	4d0d      	ldr	r5, [pc, #52]	@ (6bc <__libc_init_array+0x3c>)
 688:	1b64      	subs	r4, r4, r5
 68a:	10a4      	asrs	r4, r4, #2
 68c:	42a6      	cmp	r6, r4
 68e:	d109      	bne.n	6a4 <__libc_init_array+0x24>
 690:	2600      	movs	r6, #0
 692:	f7ff ff9d 	bl	5d0 <_init>
 696:	4c0a      	ldr	r4, [pc, #40]	@ (6c0 <__libc_init_array+0x40>)
 698:	4d0a      	ldr	r5, [pc, #40]	@ (6c4 <__libc_init_array+0x44>)
 69a:	1b64      	subs	r4, r4, r5
 69c:	10a4      	asrs	r4, r4, #2
 69e:	42a6      	cmp	r6, r4
 6a0:	d105      	bne.n	6ae <__libc_init_array+0x2e>
 6a2:	bd70      	pop	{r4, r5, r6, pc}
 6a4:	00b3      	lsls	r3, r6, #2
 6a6:	58eb      	ldr	r3, [r5, r3]
 6a8:	4798      	blx	r3
 6aa:	3601      	adds	r6, #1
 6ac:	e7ee      	b.n	68c <__libc_init_array+0xc>
 6ae:	00b3      	lsls	r3, r6, #2
 6b0:	58eb      	ldr	r3, [r5, r3]
 6b2:	4798      	blx	r3
 6b4:	3601      	adds	r6, #1
 6b6:	e7f2      	b.n	69e <__libc_init_array+0x1e>
	...

000006c8 <LED10_P2_2_config>:
 6c8:	0001 0000 000e 0000 0000 0000               ............

000006d4 <SW_LED9_P2_0_config>:
 6d4:	0001 0000 0002 0000 0002 0000               ............

000006e0 <LED8_P1_6_config>:
 6e0:	0001 0000 0006 0000 0000 0000               ............

000006ec <SW2_P3_7_config>:
 6ec:	0001 0000 0002 0000 0002 0000               ............
