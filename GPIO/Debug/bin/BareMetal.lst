
bin/BareMetal.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000708  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  20000000  20000000  00001708  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  20000000  20000000  00000000  2**0
                  ALLOC
  3 .heap         00000000  20002df0  20002df0  00001708  2**0
                  CONTENTS
  4 .stack        00003000  20000000  20000000  00002000  2**0
                  ALLOC
  5 .debug_info   00000b6b  00000000  00000000  00001708  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_abbrev 0000049d  00000000  00000000  00002273  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_aranges 00000080  00000000  00000000  00002710  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   000007ca  00000000  00000000  00002790  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    000004c0  00000000  00000000  00002f5a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      00000044  00000000  00000000  0000341a  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002c  00000000  00000000  0000345e  2**0
                  CONTENTS, READONLY
 12 .debug_frame  0000032c  00000000  00000000  0000348c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <vector>:
   0:	00 30 00 20 eb 05 00 00 81 06 00 00 89 06 00 00     .0. ............
	...
  2c:	81 06 00 00 00 00 00 00 00 00 00 00 81 06 00 00     ................
  3c:	81 06 00 00 81 06 00 00 81 06 00 00 c5 01 00 00     ................
  4c:	93 01 00 00 81 06 00 00 81 06 00 00 81 06 00 00     ................
  5c:	81 06 00 00 81 06 00 00 81 06 00 00 81 06 00 00     ................
  6c:	81 06 00 00 81 06 00 00 81 06 00 00 81 06 00 00     ................
  7c:	81 06 00 00 81 06 00 00 81 06 00 00 81 06 00 00     ................
  8c:	81 06 00 00 81 06 00 00 81 06 00 00 81 06 00 00     ................
  9c:	81 06 00 00 81 06 00 00 81 06 00 00 81 06 00 00     ................
  ac:	81 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
  bc:	00 00 00 00                                         ....

000000c0 <main>:
};

void Delay(int32_t);

int main()
{
  c0:	b580      	push	{r7, lr}
  c2:	af00      	add	r7, sp, #0
   // register int Var_1, Var_2, Var_3, Var_4, Var_5; 
    IRQ_EnableGlobal();
  c4:	f000 fa0a 	bl	4dc <IRQ_EnableGlobal>
    GPIO_Pin_Init(2, 2u, &LED10_P2_2_config, HSIOM_SEL_GPIO);
  c8:	4a1e      	ldr	r2, [pc, #120]	@ (144 <main+0x84>)
  ca:	2300      	movs	r3, #0
  cc:	2102      	movs	r1, #2
  ce:	2002      	movs	r0, #2
  d0:	f000 f9a6 	bl	420 <GPIO_Pin_Init>
    GPIO_Pin_Init(3, 7u, &SW2_P3_7_config, HSIOM_SEL_GPIO);
  d4:	4a1c      	ldr	r2, [pc, #112]	@ (148 <main+0x88>)
  d6:	2300      	movs	r3, #0
  d8:	2107      	movs	r1, #7
  da:	2003      	movs	r0, #3
  dc:	f000 f9a0 	bl	420 <GPIO_Pin_Init>
    // GPIO_Pin_Init((GPIO_PRT_Type *)CYREG_GPIO_PRT2_DR, 0u, &LED9_P2_0_config, HSIOM_SEL_GPIO);
    GPIO_Pin_Init(2, 0u, &SW_LED9_P2_0_config, HSIOM_SEL_GPIO);
  e0:	4a1a      	ldr	r2, [pc, #104]	@ (14c <main+0x8c>)
  e2:	2300      	movs	r3, #0
  e4:	2100      	movs	r1, #0
  e6:	2002      	movs	r0, #2
  e8:	f000 f99a 	bl	420 <GPIO_Pin_Init>
    GPIO_Pin_Init(1, 6u, &LED8_P1_6_config, HSIOM_SEL_GPIO);
  ec:	4a18      	ldr	r2, [pc, #96]	@ (150 <main+0x90>)
  ee:	2300      	movs	r3, #0
  f0:	2106      	movs	r1, #6
  f2:	2001      	movs	r0, #1
  f4:	f000 f994 	bl	420 <GPIO_Pin_Init>

    NVIC_SetPriority(3u, 1u);
  f8:	2101      	movs	r1, #1
  fa:	2003      	movs	r0, #3
  fc:	f000 f9fa 	bl	4f4 <NVIC_SetPriority>
    NVIC_SetPriority(2u, 1u);
 100:	2101      	movs	r1, #1
 102:	2002      	movs	r0, #2
 104:	f000 f9f6 	bl	4f4 <NVIC_SetPriority>
    /* Clearing and enabling the GPIO interrupt in NVIC */
    NVIC_ClearPendingIRQ(3u);
 108:	2003      	movs	r0, #3
 10a:	f000 fa23 	bl	554 <NVIC_ClearPendingIRQ>
    NVIC_ClearPendingIRQ(2u);
 10e:	2002      	movs	r0, #2
 110:	f000 fa20 	bl	554 <NVIC_ClearPendingIRQ>
    NVIC_EnableIRQ(3u);
 114:	2003      	movs	r0, #3
 116:	f000 fa33 	bl	580 <NVIC_EnableIRQ>
    NVIC_EnableIRQ(2u);
 11a:	2002      	movs	r0, #2
 11c:	f000 fa30 	bl	580 <NVIC_EnableIRQ>

    for(;;)
    {
        GPIO_Set(1, 6u);
 120:	2106      	movs	r1, #6
 122:	2001      	movs	r0, #1
 124:	f000 f868 	bl	1f8 <GPIO_Set>
        Delay(60000);
 128:	4b0a      	ldr	r3, [pc, #40]	@ (154 <main+0x94>)
 12a:	0018      	movs	r0, r3
 12c:	f000 f814 	bl	158 <Delay>

        GPIO_Clr(1, 6u);
 130:	2106      	movs	r1, #6
 132:	2001      	movs	r0, #1
 134:	f000 f87a 	bl	22c <GPIO_Clr>
        Delay(60000);  
 138:	4b06      	ldr	r3, [pc, #24]	@ (154 <main+0x94>)
 13a:	0018      	movs	r0, r3
 13c:	f000 f80c 	bl	158 <Delay>
        GPIO_Set(1, 6u);
 140:	46c0      	nop			@ (mov r8, r8)
 142:	e7ed      	b.n	120 <main+0x60>
 144:	000006d8 	.word	0x000006d8
 148:	000006fc 	.word	0x000006fc
 14c:	000006e4 	.word	0x000006e4
 150:	000006f0 	.word	0x000006f0
 154:	0000ea60 	.word	0x0000ea60

00000158 <Delay>:
    }
    return 0;
}

void Delay(int32_t delayNumber)
{
 158:	b580      	push	{r7, lr}
 15a:	b084      	sub	sp, #16
 15c:	af00      	add	r7, sp, #0
 15e:	6078      	str	r0, [r7, #4]
    for(int32_t i=0; i<delayNumber; i++);
 160:	2300      	movs	r3, #0
 162:	60fb      	str	r3, [r7, #12]
 164:	e002      	b.n	16c <Delay+0x14>
 166:	68fb      	ldr	r3, [r7, #12]
 168:	3301      	adds	r3, #1
 16a:	60fb      	str	r3, [r7, #12]
 16c:	68fa      	ldr	r2, [r7, #12]
 16e:	687b      	ldr	r3, [r7, #4]
 170:	429a      	cmp	r2, r3
 172:	dbf8      	blt.n	166 <Delay+0xe>
    for(int32_t i=0; i<delayNumber; i++);
 174:	2300      	movs	r3, #0
 176:	60bb      	str	r3, [r7, #8]
 178:	e002      	b.n	180 <Delay+0x28>
 17a:	68bb      	ldr	r3, [r7, #8]
 17c:	3301      	adds	r3, #1
 17e:	60bb      	str	r3, [r7, #8]
 180:	68ba      	ldr	r2, [r7, #8]
 182:	687b      	ldr	r3, [r7, #4]
 184:	429a      	cmp	r2, r3
 186:	dbf8      	blt.n	17a <Delay+0x22>
}
 188:	46c0      	nop			@ (mov r8, r8)
 18a:	46c0      	nop			@ (mov r8, r8)
 18c:	46bd      	mov	sp, r7
 18e:	b004      	add	sp, #16
 190:	bd80      	pop	{r7, pc}

00000192 <ioss_interrupts_gpio_3_IRQHandler>:

void ioss_interrupts_gpio_3_IRQHandler(void)
{
 192:	b580      	push	{r7, lr}
 194:	af00      	add	r7, sp, #0

    GPIO_ClearInterrupt(3, 7u);
 196:	2107      	movs	r1, #7
 198:	2003      	movs	r0, #3
 19a:	f000 f981 	bl	4a0 <GPIO_ClearInterrupt>
    Delay(20000);
 19e:	4b08      	ldr	r3, [pc, #32]	@ (1c0 <ioss_interrupts_gpio_3_IRQHandler+0x2e>)
 1a0:	0018      	movs	r0, r3
 1a2:	f7ff ffd9 	bl	158 <Delay>

    if((GPIO_Read(3, 7u) == 0u))
 1a6:	2107      	movs	r1, #7
 1a8:	2003      	movs	r0, #3
 1aa:	f000 f873 	bl	294 <GPIO_Read>
 1ae:	1e03      	subs	r3, r0, #0
 1b0:	d103      	bne.n	1ba <ioss_interrupts_gpio_3_IRQHandler+0x28>
    {
        GPIO_Inv(2, 2u);
 1b2:	2102      	movs	r1, #2
 1b4:	2002      	movs	r0, #2
 1b6:	f000 f853 	bl	260 <GPIO_Inv>
    }  

}
 1ba:	46c0      	nop			@ (mov r8, r8)
 1bc:	46bd      	mov	sp, r7
 1be:	bd80      	pop	{r7, pc}
 1c0:	00004e20 	.word	0x00004e20

000001c4 <ioss_interrupts_gpio_2_IRQHandler>:

void ioss_interrupts_gpio_2_IRQHandler(void)
{
 1c4:	b580      	push	{r7, lr}
 1c6:	af00      	add	r7, sp, #0

    GPIO_ClearInterrupt(2, 0u);
 1c8:	2100      	movs	r1, #0
 1ca:	2002      	movs	r0, #2
 1cc:	f000 f968 	bl	4a0 <GPIO_ClearInterrupt>
    Delay(20000);
 1d0:	4b08      	ldr	r3, [pc, #32]	@ (1f4 <ioss_interrupts_gpio_2_IRQHandler+0x30>)
 1d2:	0018      	movs	r0, r3
 1d4:	f7ff ffc0 	bl	158 <Delay>

    if((GPIO_Read(2, 0u) == 0u))
 1d8:	2100      	movs	r1, #0
 1da:	2002      	movs	r0, #2
 1dc:	f000 f85a 	bl	294 <GPIO_Read>
 1e0:	1e03      	subs	r3, r0, #0
 1e2:	d103      	bne.n	1ec <ioss_interrupts_gpio_2_IRQHandler+0x28>
    {
        GPIO_Inv(2, 2u);
 1e4:	2102      	movs	r1, #2
 1e6:	2002      	movs	r0, #2
 1e8:	f000 f83a 	bl	260 <GPIO_Inv>
    }  

 1ec:	46c0      	nop			@ (mov r8, r8)
 1ee:	46bd      	mov	sp, r7
 1f0:	bd80      	pop	{r7, pc}
 1f2:	46c0      	nop			@ (mov r8, r8)
 1f4:	00004e20 	.word	0x00004e20

000001f8 <GPIO_Set>:
#include <stdint.h>
#include "gpio.h"

void GPIO_Set(uint8_t portNum, uint32_t pinNum)
{
 1f8:	b580      	push	{r7, lr}
 1fa:	b084      	sub	sp, #16
 1fc:	af00      	add	r7, sp, #0
 1fe:	0002      	movs	r2, r0
 200:	6039      	str	r1, [r7, #0]
 202:	1dfb      	adds	r3, r7, #7
 204:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 206:	1dfb      	adds	r3, r7, #7
 208:	781b      	ldrb	r3, [r3, #0]
 20a:	4a07      	ldr	r2, [pc, #28]	@ (228 <__HEAP_SIZE+0x28>)
 20c:	4694      	mov	ip, r2
 20e:	4463      	add	r3, ip
 210:	021b      	lsls	r3, r3, #8
 212:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_SET(base) = GPIO_DR_MASK << pinNum;
 214:	2201      	movs	r2, #1
 216:	683b      	ldr	r3, [r7, #0]
 218:	409a      	lsls	r2, r3
 21a:	68fb      	ldr	r3, [r7, #12]
 21c:	641a      	str	r2, [r3, #64]	@ 0x40
}
 21e:	46c0      	nop			@ (mov r8, r8)
 220:	46bd      	mov	sp, r7
 222:	b004      	add	sp, #16
 224:	bd80      	pop	{r7, pc}
 226:	46c0      	nop			@ (mov r8, r8)
 228:	00400400 	.word	0x00400400

0000022c <GPIO_Clr>:

void GPIO_Clr(uint8_t portNum, uint32_t pinNum)
{
 22c:	b580      	push	{r7, lr}
 22e:	b084      	sub	sp, #16
 230:	af00      	add	r7, sp, #0
 232:	0002      	movs	r2, r0
 234:	6039      	str	r1, [r7, #0]
 236:	1dfb      	adds	r3, r7, #7
 238:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 23a:	1dfb      	adds	r3, r7, #7
 23c:	781b      	ldrb	r3, [r3, #0]
 23e:	4a07      	ldr	r2, [pc, #28]	@ (25c <GPIO_Clr+0x30>)
 240:	4694      	mov	ip, r2
 242:	4463      	add	r3, ip
 244:	021b      	lsls	r3, r3, #8
 246:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_CLR(base) = GPIO_DR_MASK << pinNum;
 248:	2201      	movs	r2, #1
 24a:	683b      	ldr	r3, [r7, #0]
 24c:	409a      	lsls	r2, r3
 24e:	68fb      	ldr	r3, [r7, #12]
 250:	645a      	str	r2, [r3, #68]	@ 0x44
}
 252:	46c0      	nop			@ (mov r8, r8)
 254:	46bd      	mov	sp, r7
 256:	b004      	add	sp, #16
 258:	bd80      	pop	{r7, pc}
 25a:	46c0      	nop			@ (mov r8, r8)
 25c:	00400400 	.word	0x00400400

00000260 <GPIO_Inv>:

void GPIO_Inv(uint8_t portNum, uint32_t pinNum)
{
 260:	b580      	push	{r7, lr}
 262:	b084      	sub	sp, #16
 264:	af00      	add	r7, sp, #0
 266:	0002      	movs	r2, r0
 268:	6039      	str	r1, [r7, #0]
 26a:	1dfb      	adds	r3, r7, #7
 26c:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 26e:	1dfb      	adds	r3, r7, #7
 270:	781b      	ldrb	r3, [r3, #0]
 272:	4a07      	ldr	r2, [pc, #28]	@ (290 <GPIO_Inv+0x30>)
 274:	4694      	mov	ip, r2
 276:	4463      	add	r3, ip
 278:	021b      	lsls	r3, r3, #8
 27a:	60fb      	str	r3, [r7, #12]
    GPIO_PRT_OUT_INV(base) = GPIO_DR_MASK << pinNum;
 27c:	2201      	movs	r2, #1
 27e:	683b      	ldr	r3, [r7, #0]
 280:	409a      	lsls	r2, r3
 282:	68fb      	ldr	r3, [r7, #12]
 284:	649a      	str	r2, [r3, #72]	@ 0x48
}
 286:	46c0      	nop			@ (mov r8, r8)
 288:	46bd      	mov	sp, r7
 28a:	b004      	add	sp, #16
 28c:	bd80      	pop	{r7, pc}
 28e:	46c0      	nop			@ (mov r8, r8)
 290:	00400400 	.word	0x00400400

00000294 <GPIO_Read>:

uint32_t GPIO_Read(uint8_t portNum, uint32_t pinNum)
{
 294:	b580      	push	{r7, lr}
 296:	b084      	sub	sp, #16
 298:	af00      	add	r7, sp, #0
 29a:	0002      	movs	r2, r0
 29c:	6039      	str	r1, [r7, #0]
 29e:	1dfb      	adds	r3, r7, #7
 2a0:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 2a2:	1dfb      	adds	r3, r7, #7
 2a4:	781b      	ldrb	r3, [r3, #0]
 2a6:	4a08      	ldr	r2, [pc, #32]	@ (2c8 <GPIO_Read+0x34>)
 2a8:	4694      	mov	ip, r2
 2aa:	4463      	add	r3, ip
 2ac:	021b      	lsls	r3, r3, #8
 2ae:	60fb      	str	r3, [r7, #12]
    return (GPIO_PRT_IN(base) >> (pinNum)) & GPIO_PS_MASK;
 2b0:	68fb      	ldr	r3, [r7, #12]
 2b2:	685a      	ldr	r2, [r3, #4]
 2b4:	683b      	ldr	r3, [r7, #0]
 2b6:	40da      	lsrs	r2, r3
 2b8:	0013      	movs	r3, r2
 2ba:	2201      	movs	r2, #1
 2bc:	4013      	ands	r3, r2
}
 2be:	0018      	movs	r0, r3
 2c0:	46bd      	mov	sp, r7
 2c2:	b004      	add	sp, #16
 2c4:	bd80      	pop	{r7, pc}
 2c6:	46c0      	nop			@ (mov r8, r8)
 2c8:	00400400 	.word	0x00400400

000002cc <GPIO_SetDrivemode>:

void GPIO_SetDrivemode(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 2cc:	b580      	push	{r7, lr}
 2ce:	b088      	sub	sp, #32
 2d0:	af00      	add	r7, sp, #0
 2d2:	60b9      	str	r1, [r7, #8]
 2d4:	607a      	str	r2, [r7, #4]
 2d6:	210f      	movs	r1, #15
 2d8:	187b      	adds	r3, r7, r1
 2da:	1c02      	adds	r2, r0, #0
 2dc:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 2de:	187b      	adds	r3, r7, r1
 2e0:	781b      	ldrb	r3, [r3, #0]
 2e2:	4a19      	ldr	r2, [pc, #100]	@ (348 <GPIO_SetDrivemode+0x7c>)
 2e4:	4694      	mov	ip, r2
 2e6:	4463      	add	r3, ip
 2e8:	021b      	lsls	r3, r3, #8
 2ea:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum * GPIO_DRIVE_MODE_OFFSET;
 2ec:	68ba      	ldr	r2, [r7, #8]
 2ee:	0013      	movs	r3, r2
 2f0:	005b      	lsls	r3, r3, #1
 2f2:	189b      	adds	r3, r3, r2
 2f4:	61bb      	str	r3, [r7, #24]
    tempReg = ((((GPIO_PRT_Type*)(base))->PC) & ~(GPIO_PC_DM_MASK << pinLoc));
 2f6:	69fb      	ldr	r3, [r7, #28]
 2f8:	689b      	ldr	r3, [r3, #8]
 2fa:	2107      	movs	r1, #7
 2fc:	69ba      	ldr	r2, [r7, #24]
 2fe:	4091      	lsls	r1, r2
 300:	000a      	movs	r2, r1
 302:	43d2      	mvns	r2, r2
 304:	4013      	ands	r3, r2
 306:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC) = tempReg | ((value & GPIO_PC_DM_MASK) << pinLoc);
 308:	687b      	ldr	r3, [r7, #4]
 30a:	2207      	movs	r2, #7
 30c:	401a      	ands	r2, r3
 30e:	69bb      	ldr	r3, [r7, #24]
 310:	409a      	lsls	r2, r3
 312:	697b      	ldr	r3, [r7, #20]
 314:	431a      	orrs	r2, r3
 316:	69fb      	ldr	r3, [r7, #28]
 318:	609a      	str	r2, [r3, #8]

    tempReg = ((((GPIO_PRT_Type*)(base))->PC2) & ~(GPIO_PC_DM_IBUF_MASK << pinNum));
 31a:	69fb      	ldr	r3, [r7, #28]
 31c:	699b      	ldr	r3, [r3, #24]
 31e:	2101      	movs	r1, #1
 320:	68ba      	ldr	r2, [r7, #8]
 322:	4091      	lsls	r1, r2
 324:	000a      	movs	r2, r1
 326:	43d2      	mvns	r2, r2
 328:	4013      	ands	r3, r2
 32a:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->PC2) = tempReg | (((value & GPIO_DM_VAL_IBUF_DISABLE_MASK) >> GPIO_DRIVE_MODE_OFFSET) << pinNum);
 32c:	687b      	ldr	r3, [r7, #4]
 32e:	08db      	lsrs	r3, r3, #3
 330:	2201      	movs	r2, #1
 332:	401a      	ands	r2, r3
 334:	68bb      	ldr	r3, [r7, #8]
 336:	409a      	lsls	r2, r3
 338:	697b      	ldr	r3, [r7, #20]
 33a:	431a      	orrs	r2, r3
 33c:	69fb      	ldr	r3, [r7, #28]
 33e:	619a      	str	r2, [r3, #24]
}
 340:	46c0      	nop			@ (mov r8, r8)
 342:	46bd      	mov	sp, r7
 344:	b008      	add	sp, #32
 346:	bd80      	pop	{r7, pc}
 348:	00400400 	.word	0x00400400

0000034c <GPIO_SetHSIOM>:


void GPIO_SetHSIOM(uint8_t portNum, uint32_t pinNum, uint8_t value)
{
 34c:	b580      	push	{r7, lr}
 34e:	b086      	sub	sp, #24
 350:	af00      	add	r7, sp, #0
 352:	6039      	str	r1, [r7, #0]
 354:	0011      	movs	r1, r2
 356:	1dfb      	adds	r3, r7, #7
 358:	1c02      	adds	r2, r0, #0
 35a:	701a      	strb	r2, [r3, #0]
 35c:	1dbb      	adds	r3, r7, #6
 35e:	1c0a      	adds	r2, r1, #0
 360:	701a      	strb	r2, [r3, #0]
    uint32_t HSIOM_portNum;
    uint32_t tempReg;
    HSIOM_PRT_Type* portAddrHSIOM;
    
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 362:	1dfb      	adds	r3, r7, #7
 364:	781b      	ldrb	r3, [r3, #0]
 366:	4a15      	ldr	r2, [pc, #84]	@ (3bc <GPIO_SetHSIOM+0x70>)
 368:	4694      	mov	ip, r2
 36a:	4463      	add	r3, ip
 36c:	021b      	lsls	r3, r3, #8
 36e:	617b      	str	r3, [r7, #20]

    HSIOM_portNum = ((uint32_t)(base) - 0x40040000UL) / 0x00000100UL;
 370:	697b      	ldr	r3, [r7, #20]
 372:	4a13      	ldr	r2, [pc, #76]	@ (3c0 <GPIO_SetHSIOM+0x74>)
 374:	4694      	mov	ip, r2
 376:	4463      	add	r3, ip
 378:	0a1b      	lsrs	r3, r3, #8
 37a:	613b      	str	r3, [r7, #16]
    portAddrHSIOM = (HSIOM_PRT_Type*)(0x40020000UL + (0x00000100UL * HSIOM_portNum));
 37c:	693b      	ldr	r3, [r7, #16]
 37e:	4a11      	ldr	r2, [pc, #68]	@ (3c4 <GPIO_SetHSIOM+0x78>)
 380:	4694      	mov	ip, r2
 382:	4463      	add	r3, ip
 384:	021b      	lsls	r3, r3, #8
 386:	60fb      	str	r3, [r7, #12]

    tempReg = (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) & ~(GPIO_HSIOM_MASK << (pinNum << GPIO_HSIOM_OFFSET));
 388:	68fb      	ldr	r3, [r7, #12]
 38a:	681b      	ldr	r3, [r3, #0]
 38c:	683a      	ldr	r2, [r7, #0]
 38e:	0092      	lsls	r2, r2, #2
 390:	210f      	movs	r1, #15
 392:	4091      	lsls	r1, r2
 394:	000a      	movs	r2, r1
 396:	43d2      	mvns	r2, r2
 398:	4013      	ands	r3, r2
 39a:	60bb      	str	r3, [r7, #8]
    (((HSIOM_PRT_Type *)(portAddrHSIOM))->PORT_SEL) = tempReg | (( (uint32_t) value & GPIO_HSIOM_MASK) << (pinNum << GPIO_HSIOM_OFFSET));
 39c:	1dbb      	adds	r3, r7, #6
 39e:	781b      	ldrb	r3, [r3, #0]
 3a0:	220f      	movs	r2, #15
 3a2:	401a      	ands	r2, r3
 3a4:	683b      	ldr	r3, [r7, #0]
 3a6:	009b      	lsls	r3, r3, #2
 3a8:	409a      	lsls	r2, r3
 3aa:	68bb      	ldr	r3, [r7, #8]
 3ac:	431a      	orrs	r2, r3
 3ae:	68fb      	ldr	r3, [r7, #12]
 3b0:	601a      	str	r2, [r3, #0]
}
 3b2:	46c0      	nop			@ (mov r8, r8)
 3b4:	46bd      	mov	sp, r7
 3b6:	b006      	add	sp, #24
 3b8:	bd80      	pop	{r7, pc}
 3ba:	46c0      	nop			@ (mov r8, r8)
 3bc:	00400400 	.word	0x00400400
 3c0:	bffc0000 	.word	0xbffc0000
 3c4:	00400200 	.word	0x00400200

000003c8 <GPIO_SetInterruptEdge>:

void GPIO_SetInterruptEdge(uint8_t portNum, uint32_t pinNum, uint32_t value)
{
 3c8:	b580      	push	{r7, lr}
 3ca:	b088      	sub	sp, #32
 3cc:	af00      	add	r7, sp, #0
 3ce:	60b9      	str	r1, [r7, #8]
 3d0:	607a      	str	r2, [r7, #4]
 3d2:	210f      	movs	r1, #15
 3d4:	187b      	adds	r3, r7, r1
 3d6:	1c02      	adds	r2, r0, #0
 3d8:	701a      	strb	r2, [r3, #0]
    uint32_t tempReg;
    uint32_t pinLoc;

    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 3da:	187b      	adds	r3, r7, r1
 3dc:	781b      	ldrb	r3, [r3, #0]
 3de:	4a0f      	ldr	r2, [pc, #60]	@ (41c <GPIO_SetInterruptEdge+0x54>)
 3e0:	4694      	mov	ip, r2
 3e2:	4463      	add	r3, ip
 3e4:	021b      	lsls	r3, r3, #8
 3e6:	61fb      	str	r3, [r7, #28]

    pinLoc = pinNum << 0x1u;
 3e8:	68bb      	ldr	r3, [r7, #8]
 3ea:	005b      	lsls	r3, r3, #1
 3ec:	61bb      	str	r3, [r7, #24]
    tempReg = (((GPIO_PRT_Type*)(base))->INTR_CFG) & ~(0x3u << pinLoc);
 3ee:	69fb      	ldr	r3, [r7, #28]
 3f0:	68db      	ldr	r3, [r3, #12]
 3f2:	2103      	movs	r1, #3
 3f4:	69ba      	ldr	r2, [r7, #24]
 3f6:	4091      	lsls	r1, r2
 3f8:	000a      	movs	r2, r1
 3fa:	43d2      	mvns	r2, r2
 3fc:	4013      	ands	r3, r2
 3fe:	617b      	str	r3, [r7, #20]
    (((GPIO_PRT_Type*)(base))->INTR_CFG) = tempReg | ((value & 0x3u) << pinLoc);
 400:	687b      	ldr	r3, [r7, #4]
 402:	2203      	movs	r2, #3
 404:	401a      	ands	r2, r3
 406:	69bb      	ldr	r3, [r7, #24]
 408:	409a      	lsls	r2, r3
 40a:	697b      	ldr	r3, [r7, #20]
 40c:	431a      	orrs	r2, r3
 40e:	69fb      	ldr	r3, [r7, #28]
 410:	60da      	str	r2, [r3, #12]
}
 412:	46c0      	nop			@ (mov r8, r8)
 414:	46bd      	mov	sp, r7
 416:	b008      	add	sp, #32
 418:	bd80      	pop	{r7, pc}
 41a:	46c0      	nop			@ (mov r8, r8)
 41c:	00400400 	.word	0x00400400

00000420 <GPIO_Pin_Init>:

void GPIO_Pin_Init(uint8_t portNum, uint32_t pinNum, const gpio_pin_config_t *config, uint8_t hsiom)
{
 420:	b590      	push	{r4, r7, lr}
 422:	b085      	sub	sp, #20
 424:	af00      	add	r7, sp, #0
 426:	60b9      	str	r1, [r7, #8]
 428:	607a      	str	r2, [r7, #4]
 42a:	0019      	movs	r1, r3
 42c:	240f      	movs	r4, #15
 42e:	193b      	adds	r3, r7, r4
 430:	1c02      	adds	r2, r0, #0
 432:	701a      	strb	r2, [r3, #0]
 434:	230e      	movs	r3, #14
 436:	18fb      	adds	r3, r7, r3
 438:	1c0a      	adds	r2, r1, #0
 43a:	701a      	strb	r2, [r3, #0]
    ((config -> outVal) == 0) ? GPIO_Clr(portNum, pinNum) : GPIO_Set(portNum,pinNum);
 43c:	687b      	ldr	r3, [r7, #4]
 43e:	681b      	ldr	r3, [r3, #0]
 440:	2b00      	cmp	r3, #0
 442:	d107      	bne.n	454 <GPIO_Pin_Init+0x34>
 444:	68ba      	ldr	r2, [r7, #8]
 446:	193b      	adds	r3, r7, r4
 448:	781b      	ldrb	r3, [r3, #0]
 44a:	0011      	movs	r1, r2
 44c:	0018      	movs	r0, r3
 44e:	f7ff feed 	bl	22c <GPIO_Clr>
 452:	e007      	b.n	464 <GPIO_Pin_Init+0x44>
 454:	68ba      	ldr	r2, [r7, #8]
 456:	230f      	movs	r3, #15
 458:	18fb      	adds	r3, r7, r3
 45a:	781b      	ldrb	r3, [r3, #0]
 45c:	0011      	movs	r1, r2
 45e:	0018      	movs	r0, r3
 460:	f7ff feca 	bl	1f8 <GPIO_Set>
    GPIO_SetDrivemode(portNum, pinNum, config->driveMode);
 464:	687b      	ldr	r3, [r7, #4]
 466:	685a      	ldr	r2, [r3, #4]
 468:	68b9      	ldr	r1, [r7, #8]
 46a:	240f      	movs	r4, #15
 46c:	193b      	adds	r3, r7, r4
 46e:	781b      	ldrb	r3, [r3, #0]
 470:	0018      	movs	r0, r3
 472:	f7ff ff2b 	bl	2cc <GPIO_SetDrivemode>
    GPIO_SetHSIOM(portNum, pinNum, hsiom);
 476:	230e      	movs	r3, #14
 478:	18fb      	adds	r3, r7, r3
 47a:	781a      	ldrb	r2, [r3, #0]
 47c:	68b9      	ldr	r1, [r7, #8]
 47e:	193b      	adds	r3, r7, r4
 480:	781b      	ldrb	r3, [r3, #0]
 482:	0018      	movs	r0, r3
 484:	f7ff ff62 	bl	34c <GPIO_SetHSIOM>
    GPIO_SetInterruptEdge(portNum, pinNum, config->intEdge);
 488:	687b      	ldr	r3, [r7, #4]
 48a:	689a      	ldr	r2, [r3, #8]
 48c:	68b9      	ldr	r1, [r7, #8]
 48e:	193b      	adds	r3, r7, r4
 490:	781b      	ldrb	r3, [r3, #0]
 492:	0018      	movs	r0, r3
 494:	f7ff ff98 	bl	3c8 <GPIO_SetInterruptEdge>
}
 498:	46c0      	nop			@ (mov r8, r8)
 49a:	46bd      	mov	sp, r7
 49c:	b005      	add	sp, #20
 49e:	bd90      	pop	{r4, r7, pc}

000004a0 <GPIO_ClearInterrupt>:

void GPIO_ClearInterrupt(uint8_t portNum, uint32_t pinNum)
{
 4a0:	b580      	push	{r7, lr}
 4a2:	b084      	sub	sp, #16
 4a4:	af00      	add	r7, sp, #0
 4a6:	0002      	movs	r2, r0
 4a8:	6039      	str	r1, [r7, #0]
 4aa:	1dfb      	adds	r3, r7, #7
 4ac:	701a      	strb	r2, [r3, #0]
    GPIO_PRT_Type* base;
    base = GET_GPIO_BASE(portNum);
 4ae:	1dfb      	adds	r3, r7, #7
 4b0:	781b      	ldrb	r3, [r3, #0]
 4b2:	4a09      	ldr	r2, [pc, #36]	@ (4d8 <GPIO_ClearInterrupt+0x38>)
 4b4:	4694      	mov	ip, r2
 4b6:	4463      	add	r3, ip
 4b8:	021b      	lsls	r3, r3, #8
 4ba:	60fb      	str	r3, [r7, #12]
    /* Any INTR MMIO registers AHB clearing must be preceded with an AHB read access */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 4bc:	68fb      	ldr	r3, [r7, #12]
 4be:	691b      	ldr	r3, [r3, #16]

    (((GPIO_PRT_Type*)(base))->INTR) = (0x01UL) << pinNum;
 4c0:	2201      	movs	r2, #1
 4c2:	683b      	ldr	r3, [r7, #0]
 4c4:	409a      	lsls	r2, r3
 4c6:	68fb      	ldr	r3, [r7, #12]
 4c8:	611a      	str	r2, [r3, #16]

    /* This read ensures that the initial write has been flushed out to the hardware */
    (void)(((GPIO_PRT_Type*)(base))->INTR);
 4ca:	68fb      	ldr	r3, [r7, #12]
 4cc:	691b      	ldr	r3, [r3, #16]
 4ce:	46c0      	nop			@ (mov r8, r8)
 4d0:	46bd      	mov	sp, r7
 4d2:	b004      	add	sp, #16
 4d4:	bd80      	pop	{r7, pc}
 4d6:	46c0      	nop			@ (mov r8, r8)
 4d8:	00400400 	.word	0x00400400

000004dc <IRQ_EnableGlobal>:
#include <stdint.h>

/*
 * Uses the Thumb-2 "CPSIE i" instruction.
 */
void IRQ_EnableGlobal(void) {
 4dc:	b580      	push	{r7, lr}
 4de:	af00      	add	r7, sp, #0
    __asm volatile ("cpsie i" : : : "memory");
 4e0:	b662      	cpsie	i
}
 4e2:	46c0      	nop			@ (mov r8, r8)
 4e4:	46bd      	mov	sp, r7
 4e6:	bd80      	pop	{r7, pc}

000004e8 <IRQ_DisableGlobal>:

/*
 * Uses the Thumb-2 "CPSID i" instruction.
 */
void IRQ_DisableGlobal(void) {
 4e8:	b580      	push	{r7, lr}
 4ea:	af00      	add	r7, sp, #0
    __asm volatile ("cpsid i" : : : "memory");
 4ec:	b672      	cpsid	i
}
 4ee:	46c0      	nop			@ (mov r8, r8)
 4f0:	46bd      	mov	sp, r7
 4f2:	bd80      	pop	{r7, pc}

000004f4 <NVIC_SetPriority>:

void NVIC_SetPriority(uint32_t IRQn, uint32_t priority)
{
 4f4:	b580      	push	{r7, lr}
 4f6:	b084      	sub	sp, #16
 4f8:	af00      	add	r7, sp, #0
 4fa:	6078      	str	r0, [r7, #4]
 4fc:	6039      	str	r1, [r7, #0]
    if ((int32_t)(IRQn) >= 0){
 4fe:	687b      	ldr	r3, [r7, #4]
 500:	2b00      	cmp	r3, #0
 502:	db20      	blt.n	546 <NVIC_SetPriority+0x52>
        uint32_t IRQ_LDX = IRQn >> 2u;
 504:	687b      	ldr	r3, [r7, #4]
 506:	089b      	lsrs	r3, r3, #2
 508:	60fb      	str	r3, [r7, #12]
        NVIC->IPR[IRQ_LDX] = (NVIC->IPR[IRQ_LDX] & ~(0xFFUL << ((IRQn & 0x03) << 3))) | (((priority & 0x03) << 6) << ((IRQn & 0x03) << 3));
 50a:	4a11      	ldr	r2, [pc, #68]	@ (550 <NVIC_SetPriority+0x5c>)
 50c:	68fb      	ldr	r3, [r7, #12]
 50e:	33c0      	adds	r3, #192	@ 0xc0
 510:	009b      	lsls	r3, r3, #2
 512:	589b      	ldr	r3, [r3, r2]
 514:	687a      	ldr	r2, [r7, #4]
 516:	00d2      	lsls	r2, r2, #3
 518:	2118      	movs	r1, #24
 51a:	400a      	ands	r2, r1
 51c:	21ff      	movs	r1, #255	@ 0xff
 51e:	4091      	lsls	r1, r2
 520:	000a      	movs	r2, r1
 522:	43d2      	mvns	r2, r2
 524:	401a      	ands	r2, r3
 526:	683b      	ldr	r3, [r7, #0]
 528:	019b      	lsls	r3, r3, #6
 52a:	21ff      	movs	r1, #255	@ 0xff
 52c:	4019      	ands	r1, r3
 52e:	687b      	ldr	r3, [r7, #4]
 530:	00db      	lsls	r3, r3, #3
 532:	2018      	movs	r0, #24
 534:	4003      	ands	r3, r0
 536:	4099      	lsls	r1, r3
 538:	000b      	movs	r3, r1
 53a:	4905      	ldr	r1, [pc, #20]	@ (550 <NVIC_SetPriority+0x5c>)
 53c:	431a      	orrs	r2, r3
 53e:	68fb      	ldr	r3, [r7, #12]
 540:	33c0      	adds	r3, #192	@ 0xc0
 542:	009b      	lsls	r3, r3, #2
 544:	505a      	str	r2, [r3, r1]
    }
}
 546:	46c0      	nop			@ (mov r8, r8)
 548:	46bd      	mov	sp, r7
 54a:	b004      	add	sp, #16
 54c:	bd80      	pop	{r7, pc}
 54e:	46c0      	nop			@ (mov r8, r8)
 550:	e000e100 	.word	0xe000e100

00000554 <NVIC_ClearPendingIRQ>:

void NVIC_ClearPendingIRQ(uint32_t IRQn)
{
 554:	b580      	push	{r7, lr}
 556:	b082      	sub	sp, #8
 558:	af00      	add	r7, sp, #0
 55a:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 55c:	687b      	ldr	r3, [r7, #4]
 55e:	2b00      	cmp	r3, #0
 560:	db08      	blt.n	574 <NVIC_ClearPendingIRQ+0x20>
  {
    NVIC->ICPR = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 562:	687b      	ldr	r3, [r7, #4]
 564:	221f      	movs	r2, #31
 566:	4013      	ands	r3, r2
 568:	4904      	ldr	r1, [pc, #16]	@ (57c <NVIC_ClearPendingIRQ+0x28>)
 56a:	2201      	movs	r2, #1
 56c:	409a      	lsls	r2, r3
 56e:	23c0      	movs	r3, #192	@ 0xc0
 570:	005b      	lsls	r3, r3, #1
 572:	50ca      	str	r2, [r1, r3]
  }
}
 574:	46c0      	nop			@ (mov r8, r8)
 576:	46bd      	mov	sp, r7
 578:	b002      	add	sp, #8
 57a:	bd80      	pop	{r7, pc}
 57c:	e000e100 	.word	0xe000e100

00000580 <NVIC_EnableIRQ>:

void NVIC_EnableIRQ(uint32_t IRQn)
{
 580:	b580      	push	{r7, lr}
 582:	b082      	sub	sp, #8
 584:	af00      	add	r7, sp, #0
 586:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 588:	687b      	ldr	r3, [r7, #4]
 58a:	2b00      	cmp	r3, #0
 58c:	db07      	blt.n	59e <NVIC_EnableIRQ+0x1e>
  {
    __asm volatile("":::"memory");
    NVIC->ISER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 58e:	687b      	ldr	r3, [r7, #4]
 590:	221f      	movs	r2, #31
 592:	401a      	ands	r2, r3
 594:	4b04      	ldr	r3, [pc, #16]	@ (5a8 <NVIC_EnableIRQ+0x28>)
 596:	2101      	movs	r1, #1
 598:	4091      	lsls	r1, r2
 59a:	000a      	movs	r2, r1
 59c:	601a      	str	r2, [r3, #0]
    __asm volatile("":::"memory");
  }
}
 59e:	46c0      	nop			@ (mov r8, r8)
 5a0:	46bd      	mov	sp, r7
 5a2:	b002      	add	sp, #8
 5a4:	bd80      	pop	{r7, pc}
 5a6:	46c0      	nop			@ (mov r8, r8)
 5a8:	e000e100 	.word	0xe000e100

000005ac <NVIC_DisableIRQ>:

void NVIC_DisableIRQ(uint32_t IRQn)
{
 5ac:	b580      	push	{r7, lr}
 5ae:	b082      	sub	sp, #8
 5b0:	af00      	add	r7, sp, #0
 5b2:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 5b4:	687b      	ldr	r3, [r7, #4]
 5b6:	2b00      	cmp	r3, #0
 5b8:	db0c      	blt.n	5d4 <NVIC_DisableIRQ+0x28>
  {
    NVIC->ICER = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 5ba:	687b      	ldr	r3, [r7, #4]
 5bc:	221f      	movs	r2, #31
 5be:	4013      	ands	r3, r2
 5c0:	4906      	ldr	r1, [pc, #24]	@ (5dc <NVIC_DisableIRQ+0x30>)
 5c2:	2201      	movs	r2, #1
 5c4:	409a      	lsls	r2, r3
 5c6:	0013      	movs	r3, r2
 5c8:	2280      	movs	r2, #128	@ 0x80
 5ca:	508b      	str	r3, [r1, r2]
    __asm volatile ("dsb 0xF":::"memory");
 5cc:	f3bf 8f4f 	dsb	sy
    __asm volatile ("isb 0xF":::"memory");
 5d0:	f3bf 8f6f 	isb	sy
  }
}
 5d4:	46c0      	nop			@ (mov r8, r8)
 5d6:	46bd      	mov	sp, r7
 5d8:	b002      	add	sp, #8
 5da:	bd80      	pop	{r7, pc}
 5dc:	e000e100 	.word	0xe000e100

000005e0 <_init>:

extern uint32_t __stack_Start__;
extern uint32_t __STACK_START;
extern uint32_t __STACK_END;

extern void _init(void) {;}
 5e0:	b580      	push	{r7, lr}
 5e2:	af00      	add	r7, sp, #0
 5e4:	46c0      	nop			@ (mov r8, r8)
 5e6:	46bd      	mov	sp, r7
 5e8:	bd80      	pop	{r7, pc}

000005ea <Reset_handler>:
    (uint32_t)can_interrupt_can_IRQHandler,             /*  26 CAN Interrupt */
    (uint32_t)crypto_interrupt_IRQHandler               /*  27 Crypto Interrupt */
};

void Reset_handler(void)
{
 5ea:	b580      	push	{r7, lr}
 5ec:	b086      	sub	sp, #24
 5ee:	af00      	add	r7, sp, #0
    //disable watchdog
    (*(uint32_t *) CYREG_WDT_DISABLE_KEY) = CY_SYS_WDT_KEY;
 5f0:	4b1c      	ldr	r3, [pc, #112]	@ (664 <Reset_handler+0x7a>)
 5f2:	4a1d      	ldr	r2, [pc, #116]	@ (668 <Reset_handler+0x7e>)
 5f4:	601a      	str	r2, [r3, #0]

    //copy .data section to SRAM
    uint32_t size = &__data_end - &__data_start;
 5f6:	4a1d      	ldr	r2, [pc, #116]	@ (66c <Reset_handler+0x82>)
 5f8:	4b1d      	ldr	r3, [pc, #116]	@ (670 <Reset_handler+0x86>)
 5fa:	1ad3      	subs	r3, r2, r3
 5fc:	109b      	asrs	r3, r3, #2
 5fe:	607b      	str	r3, [r7, #4]
    uint32_t *pDst = (uint32_t*)&__data_start;
 600:	4b1b      	ldr	r3, [pc, #108]	@ (670 <Reset_handler+0x86>)
 602:	617b      	str	r3, [r7, #20]
    uint32_t *pSrc = (uint32_t*)&_la_data;
 604:	4b1b      	ldr	r3, [pc, #108]	@ (674 <Reset_handler+0x8a>)
 606:	613b      	str	r3, [r7, #16]

    for(uint32_t i = 0; i< size; i++)
 608:	2300      	movs	r3, #0
 60a:	60fb      	str	r3, [r7, #12]
 60c:	e00a      	b.n	624 <Reset_handler+0x3a>
    {
        *pDst++ = *pSrc++;
 60e:	693a      	ldr	r2, [r7, #16]
 610:	1d13      	adds	r3, r2, #4
 612:	613b      	str	r3, [r7, #16]
 614:	697b      	ldr	r3, [r7, #20]
 616:	1d19      	adds	r1, r3, #4
 618:	6179      	str	r1, [r7, #20]
 61a:	6812      	ldr	r2, [r2, #0]
 61c:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 61e:	68fb      	ldr	r3, [r7, #12]
 620:	3301      	adds	r3, #1
 622:	60fb      	str	r3, [r7, #12]
 624:	68fa      	ldr	r2, [r7, #12]
 626:	687b      	ldr	r3, [r7, #4]
 628:	429a      	cmp	r2, r3
 62a:	d3f0      	bcc.n	60e <Reset_handler+0x24>
    }
    //int the .bss section to zero in SRAM
    size = &__bss_end__ - &__bss_start__;
 62c:	4a12      	ldr	r2, [pc, #72]	@ (678 <Reset_handler+0x8e>)
 62e:	4b13      	ldr	r3, [pc, #76]	@ (67c <Reset_handler+0x92>)
 630:	1ad3      	subs	r3, r2, r3
 632:	109b      	asrs	r3, r3, #2
 634:	607b      	str	r3, [r7, #4]
    pDst = (uint32_t*)&__bss_start__;
 636:	4b11      	ldr	r3, [pc, #68]	@ (67c <Reset_handler+0x92>)
 638:	617b      	str	r3, [r7, #20]

    for(uint32_t i = 0; i< size; i++)
 63a:	2300      	movs	r3, #0
 63c:	60bb      	str	r3, [r7, #8]
 63e:	e007      	b.n	650 <Reset_handler+0x66>
    {
        *pDst++ = 0;
 640:	697b      	ldr	r3, [r7, #20]
 642:	1d1a      	adds	r2, r3, #4
 644:	617a      	str	r2, [r7, #20]
 646:	2200      	movs	r2, #0
 648:	601a      	str	r2, [r3, #0]
    for(uint32_t i = 0; i< size; i++)
 64a:	68bb      	ldr	r3, [r7, #8]
 64c:	3301      	adds	r3, #1
 64e:	60bb      	str	r3, [r7, #8]
 650:	68ba      	ldr	r2, [r7, #8]
 652:	687b      	ldr	r3, [r7, #4]
 654:	429a      	cmp	r2, r3
 656:	d3f3      	bcc.n	640 <Reset_handler+0x56>
    }

    // Init C std libs
    __libc_init_array();
 658:	f000 f81a 	bl	690 <__libc_init_array>

    //call main()
    main();
 65c:	f7ff fd30 	bl	c0 <main>

    while (1)
 660:	46c0      	nop			@ (mov r8, r8)
 662:	e7fd      	b.n	660 <Reset_handler+0x76>
 664:	40030038 	.word	0x40030038
 668:	aced8865 	.word	0xaced8865
 66c:	20000000 	.word	0x20000000
 670:	20000000 	.word	0x20000000
 674:	00000708 	.word	0x00000708
 678:	20000000 	.word	0x20000000
 67c:	20000000 	.word	0x20000000

00000680 <Default_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Exceptions / Interrupts
 *----------------------------------------------------------------------------*/
void Default_Handler(void)
{
 680:	b580      	push	{r7, lr}
 682:	af00      	add	r7, sp, #0
    while(1);
 684:	46c0      	nop			@ (mov r8, r8)
 686:	e7fd      	b.n	684 <Default_Handler+0x4>

00000688 <HRDFLT_Handler>:

/*----------------------------------------------------------------------------
  Default Handler for Hard Fault
 *----------------------------------------------------------------------------*/
void HRDFLT_Handler(void)
{
 688:	b580      	push	{r7, lr}
 68a:	af00      	add	r7, sp, #0
    while (1)
 68c:	46c0      	nop			@ (mov r8, r8)
 68e:	e7fd      	b.n	68c <HRDFLT_Handler+0x4>

00000690 <__libc_init_array>:
 690:	b570      	push	{r4, r5, r6, lr}
 692:	2600      	movs	r6, #0
 694:	4c0c      	ldr	r4, [pc, #48]	@ (6c8 <__libc_init_array+0x38>)
 696:	4d0d      	ldr	r5, [pc, #52]	@ (6cc <__libc_init_array+0x3c>)
 698:	1b64      	subs	r4, r4, r5
 69a:	10a4      	asrs	r4, r4, #2
 69c:	42a6      	cmp	r6, r4
 69e:	d109      	bne.n	6b4 <__libc_init_array+0x24>
 6a0:	2600      	movs	r6, #0
 6a2:	f7ff ff9d 	bl	5e0 <_init>
 6a6:	4c0a      	ldr	r4, [pc, #40]	@ (6d0 <__libc_init_array+0x40>)
 6a8:	4d0a      	ldr	r5, [pc, #40]	@ (6d4 <__libc_init_array+0x44>)
 6aa:	1b64      	subs	r4, r4, r5
 6ac:	10a4      	asrs	r4, r4, #2
 6ae:	42a6      	cmp	r6, r4
 6b0:	d105      	bne.n	6be <__libc_init_array+0x2e>
 6b2:	bd70      	pop	{r4, r5, r6, pc}
 6b4:	00b3      	lsls	r3, r6, #2
 6b6:	58eb      	ldr	r3, [r5, r3]
 6b8:	4798      	blx	r3
 6ba:	3601      	adds	r6, #1
 6bc:	e7ee      	b.n	69c <__libc_init_array+0xc>
 6be:	00b3      	lsls	r3, r6, #2
 6c0:	58eb      	ldr	r3, [r5, r3]
 6c2:	4798      	blx	r3
 6c4:	3601      	adds	r6, #1
 6c6:	e7f2      	b.n	6ae <__libc_init_array+0x1e>
	...

000006d8 <LED10_P2_2_config>:
 6d8:	0001 0000 000e 0000 0000 0000               ............

000006e4 <SW_LED9_P2_0_config>:
 6e4:	0001 0000 0002 0000 0002 0000               ............

000006f0 <LED8_P1_6_config>:
 6f0:	0001 0000 0006 0000 0000 0000               ............

000006fc <SW2_P3_7_config>:
 6fc:	0001 0000 0002 0000 0002 0000               ............
